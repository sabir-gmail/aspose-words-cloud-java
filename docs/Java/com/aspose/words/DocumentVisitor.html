<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
><HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- Generated by javadoc - compatibility string-->
<!-- Generated by Aspose.JavaDoc 09 Aug 2018 -->
<TITLE>DocumentVisitor</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style"></HEAD>
<BODY BGCOLOR="white">
<!-- ======== START OF CLASS DATA ======== -->
<H2><a href="package-summary.html"><FONT SIZE="-1">
com.aspose.words
</FONT></a><BR>Class DocumentVisitor</H2>
<PRE>
java.lang.Object
    <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.aspose.words.DocumentVisitor</B>
</PRE>
<HR>
<DL>
<DT><PRE>public abstract class <B>DocumentVisitor </B><DT>extends java.lang.Object</DL>
</PRE>

<P>

<summary>
            Base class for custom document visitors.
            </summary><remarks><p>With <b>DocumentVisitor</b> you can define and execute custom operations
            that require enumeration over the document tree.</p><p>For example, Aspose.Words uses <b>DocumentVisitor</b> internally for saving <b>Document</b>
            in various formats and for other operations like finding fields or bookmarks over
            a fragment of a document.</p><p>To use <b>DocumentVisitor</b>:</p><ol><li>Create a class derived from <b>DocumentVisitor</b>.</li><li>Override and provide implementations for some or all of the VisitXXX methods
            to perform some custom operations.</li><li>Call <cref><A HREF="Node.html#accept(com.aspose.words.DocumentVisitor)" title="method in class com.aspose.words.Node">Node.accept(com.aspose.words.DocumentVisitor)</A></cref> on the <b>Node</b> that
            you want to start the enumeration from.</li></ol><p><b>DocumentVisitor</b> provides default implementations for all of the VisitXXX methods 
            to make it easier to create new document visitors as only the methods required for the particular
            visitor need to be overridden. It is not necessary to override all of the visitor methods.</p><p>For more information see the Visitor design pattern.</p></remarks><example><p><b>Example:</b></p>Shows how to use the Visitor pattern to add new operations to the Aspose.Words object model. In this case we create a simple document converter into a text format.<pre>
public void toText() throws Exception
{
    // Open the document we want to convert.
    Document doc = new Document(getMyDir() + "Visitor.ToText.doc");

    // Create an object that inherits from the DocumentVisitor class.
    MyDocToTxtWriter myConverter = new MyDocToTxtWriter();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).
    //
    // Note that every node in the object model has the Accept method so the visiting
    // can be executed not only for the whole document, but for any node in the document.
    doc.accept(myConverter);

    // Once the visiting is complete, we can retrieve the result of the operation,
    // that in this example, has accumulated in the visitor.
    System.out.println(myConverter.getText());
}

/**
 * Simple implementation of saving a document in the plain text format. Implemented as a Visitor.
 */
public class MyDocToTxtWriter extends DocumentVisitor
{
    public MyDocToTxtWriter()
    {
        mIsSkipText = false;
        mBuilder = new StringBuilder();
    }

    /**
     * Gets the plain text of the document that was accumulated by the visitor.
     */
    public String getText()
    {
        return mBuilder.toString();
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        appendText(run.getText());

        // Let the visitor continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart)
    {
        // In Microsoft Word, a field code (such as "MERGEFIELD FieldName") follows
        // after a field start character. We want to skip field codes and output field
        // result only, therefore we use a flag to suspend the output while inside a field code.
        //
        // Note this is a very simplistic implementation and will not work very well
        // if you have nested fields in a document.
        mIsSkipText = true;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator)
    {
        // Once reached a field separator node, we enable the output because we are
        // now entering the field result nodes.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd)
    {
        // Make sure we enable the output when reached a field end because some fields
        // do not have field separator and do not have field result.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Paragraph node is ended in the document.
     */
    public int visitParagraphEnd(Paragraph paragraph) throws Exception
    {
        // When outputting to plain text we output Cr+Lf characters.
        appendText(ControlChar.CR_LF);

        return VisitorAction.CONTINUE;
    }

    public int visitBodyStart(Body body)
    {
        // We can detect beginning and end of all composite nodes such as Section, Body,
        // Table, Paragraph etc and provide custom handling for them.
        mBuilder.append("*** Body Started ***\r\n");

        return VisitorAction.CONTINUE;
    }

    public int visitBodyEnd(Body body)
    {
        mBuilder.append("*** Body Ended ***\r\n");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a HeaderFooter node is encountered in the document.
     */
    public int visitHeaderFooterStart(HeaderFooter headerFooter)
    {
        // Returning this value from a visitor method causes visiting of this
        // node to stop and move on to visiting the next sibling node.
        // The net effect in this example is that the text of headers and footers
        // is not included in the resulting output.
        return VisitorAction.SKIP_THIS_NODE;
    }

    /**
     * Called when an AbsolutePositionTab is encountered in the document.
     */
    public int visitAbsolutePositionTab(AbsolutePositionTab tab)
    {
        mBuilder.append("\t");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkStart is encountered in the document.
     */
    public int visitBookmarkStart(BookmarkStart bookmarkStart)
    {
        mBuilder.append("[");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkEnd is encountered in the document.
     */
    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd)
    {
        mBuilder.append("]");
        return VisitorAction.CONTINUE;
    }

    /**
     * Adds text to the current output. Honours the enabled/disabled output flag.
     */
    private void appendText(String text)
    {
        if (!mIsSkipText) mBuilder.append(text);
    }

    private final StringBuilder mBuilder;
    private boolean mIsSkipText;
}</pre></example>
<HR>
<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" RULES="GROUPS" FRAME="BOX" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitAbsolutePositionTab(com.aspose.words.AbsolutePositionTab)">visitAbsolutePositionTab</A></B>(<A HREF="AbsolutePositionTab.html" title="class in com.aspose.words">AbsolutePositionTab</A>&nbsp;tab)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a <cref><A HREF="AbsolutePositionTab.html" title="class in com.aspose.words">AbsolutePositionTab</A></cref> node is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitBodyEnd(com.aspose.words.Body)">visitBodyEnd</A></B>(<A HREF="Body.html" title="class in com.aspose.words">Body</A>&nbsp;body)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of the main text story in a section has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitBodyStart(com.aspose.words.Body)">visitBodyStart</A></B>(<A HREF="Body.html" title="class in com.aspose.words">Body</A>&nbsp;body)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of the main text story in a section has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitBookmarkEnd(com.aspose.words.BookmarkEnd)">visitBookmarkEnd</A></B>(<A HREF="BookmarkEnd.html" title="class in com.aspose.words">BookmarkEnd</A>&nbsp;bookmarkEnd)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when an end of a bookmark is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitBookmarkStart(com.aspose.words.BookmarkStart)">visitBookmarkStart</A></B>(<A HREF="BookmarkStart.html" title="class in com.aspose.words">BookmarkStart</A>&nbsp;bookmarkStart)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a start of a bookmark is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitBuildingBlockEnd(com.aspose.words.BuildingBlock)">visitBuildingBlockEnd</A></B>(<A HREF="BuildingBlock.html" title="class in com.aspose.words">BuildingBlock</A>&nbsp;block)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a building block has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitBuildingBlockStart(com.aspose.words.BuildingBlock)">visitBuildingBlockStart</A></B>(<A HREF="BuildingBlock.html" title="class in com.aspose.words">BuildingBlock</A>&nbsp;block)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a building block has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitCellEnd(com.aspose.words.Cell)">visitCellEnd</A></B>(<A HREF="Cell.html" title="class in com.aspose.words">Cell</A>&nbsp;cell)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a table cell has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitCellStart(com.aspose.words.Cell)">visitCellStart</A></B>(<A HREF="Cell.html" title="class in com.aspose.words">Cell</A>&nbsp;cell)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a table cell has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitCommentEnd(com.aspose.words.Comment)">visitCommentEnd</A></B>(<A HREF="Comment.html" title="class in com.aspose.words">Comment</A>&nbsp;comment)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a comment text has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitCommentRangeEnd(com.aspose.words.CommentRangeEnd)">visitCommentRangeEnd</A></B>(<A HREF="CommentRangeEnd.html" title="class in com.aspose.words">CommentRangeEnd</A>&nbsp;commentRangeEnd)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when the end of a commented range of text is encountered.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitCommentRangeStart(com.aspose.words.CommentRangeStart)">visitCommentRangeStart</A></B>(<A HREF="CommentRangeStart.html" title="class in com.aspose.words">CommentRangeStart</A>&nbsp;commentRangeStart)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when the start of a commented range of text is encountered.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitCommentStart(com.aspose.words.Comment)">visitCommentStart</A></B>(<A HREF="Comment.html" title="class in com.aspose.words">Comment</A>&nbsp;comment)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a comment text has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitDocumentEnd(com.aspose.words.Document)">visitDocumentEnd</A></B>(<A HREF="Document.html" title="class in com.aspose.words">Document</A>&nbsp;doc)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of the document has finished.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitDocumentStart(com.aspose.words.Document)">visitDocumentStart</A></B>(<A HREF="Document.html" title="class in com.aspose.words">Document</A>&nbsp;doc)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of the document has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitEditableRangeEnd(com.aspose.words.EditableRangeEnd)">visitEditableRangeEnd</A></B>(<A HREF="EditableRangeEnd.html" title="class in com.aspose.words">EditableRangeEnd</A>&nbsp;editableRangeEnd)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when an end of an editable range is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitEditableRangeStart(com.aspose.words.EditableRangeStart)">visitEditableRangeStart</A></B>(<A HREF="EditableRangeStart.html" title="class in com.aspose.words">EditableRangeStart</A>&nbsp;editableRangeStart)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a start of an editable range is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitFieldEnd(com.aspose.words.FieldEnd)">visitFieldEnd</A></B>(<A HREF="FieldEnd.html" title="class in com.aspose.words">FieldEnd</A>&nbsp;fieldEnd)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a field ends in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitFieldSeparator(com.aspose.words.FieldSeparator)">visitFieldSeparator</A></B>(<A HREF="FieldSeparator.html" title="class in com.aspose.words">FieldSeparator</A>&nbsp;fieldSeparator)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a field separator is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitFieldStart(com.aspose.words.FieldStart)">visitFieldStart</A></B>(<A HREF="FieldStart.html" title="class in com.aspose.words">FieldStart</A>&nbsp;fieldStart)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a field starts in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitFootnoteEnd(com.aspose.words.Footnote)">visitFootnoteEnd</A></B>(<A HREF="Footnote.html" title="class in com.aspose.words">Footnote</A>&nbsp;footnote)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a footnote or endnote text has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitFootnoteStart(com.aspose.words.Footnote)">visitFootnoteStart</A></B>(<A HREF="Footnote.html" title="class in com.aspose.words">Footnote</A>&nbsp;footnote)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a footnote or endnote text has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitFormField(com.aspose.words.FormField)">visitFormField</A></B>(<A HREF="FormField.html" title="class in com.aspose.words">FormField</A>&nbsp;formField)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a form field is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitGlossaryDocumentEnd(com.aspose.words.GlossaryDocument)">visitGlossaryDocumentEnd</A></B>(<A HREF="GlossaryDocument.html" title="class in com.aspose.words">GlossaryDocument</A>&nbsp;glossary)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a glossary document has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitGlossaryDocumentStart(com.aspose.words.GlossaryDocument)">visitGlossaryDocumentStart</A></B>(<A HREF="GlossaryDocument.html" title="class in com.aspose.words">GlossaryDocument</A>&nbsp;glossary)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a glossary document has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitGroupShapeEnd(com.aspose.words.GroupShape)">visitGroupShapeEnd</A></B>(<A HREF="GroupShape.html" title="class in com.aspose.words">GroupShape</A>&nbsp;groupShape)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a group shape has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitGroupShapeStart(com.aspose.words.GroupShape)">visitGroupShapeStart</A></B>(<A HREF="GroupShape.html" title="class in com.aspose.words">GroupShape</A>&nbsp;groupShape)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a group shape has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitHeaderFooterEnd(com.aspose.words.HeaderFooter)">visitHeaderFooterEnd</A></B>(<A HREF="HeaderFooter.html" title="class in com.aspose.words">HeaderFooter</A>&nbsp;headerFooter)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a header or footer in a section has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitHeaderFooterStart(com.aspose.words.HeaderFooter)">visitHeaderFooterStart</A></B>(<A HREF="HeaderFooter.html" title="class in com.aspose.words">HeaderFooter</A>&nbsp;headerFooter)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a header or footer in a section has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitOfficeMathEnd(com.aspose.words.OfficeMath)">visitOfficeMathEnd</A></B>(<A HREF="OfficeMath.html" title="class in com.aspose.words">OfficeMath</A>&nbsp;officeMath)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a Office Math object has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitOfficeMathStart(com.aspose.words.OfficeMath)">visitOfficeMathStart</A></B>(<A HREF="OfficeMath.html" title="class in com.aspose.words">OfficeMath</A>&nbsp;officeMath)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a Office Math object has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitParagraphEnd(com.aspose.words.Paragraph)">visitParagraphEnd</A></B>(<A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A>&nbsp;paragraph)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a paragraph has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitParagraphStart(com.aspose.words.Paragraph)">visitParagraphStart</A></B>(<A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A>&nbsp;paragraph)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a paragraph has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitRowEnd(com.aspose.words.Row)">visitRowEnd</A></B>(<A HREF="Row.html" title="class in com.aspose.words">Row</A>&nbsp;row)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a table row has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitRowStart(com.aspose.words.Row)">visitRowStart</A></B>(<A HREF="Row.html" title="class in com.aspose.words">Row</A>&nbsp;row)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a table row has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitRun(com.aspose.words.Run)">visitRun</A></B>(<A HREF="Run.html" title="class in com.aspose.words">Run</A>&nbsp;run)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a run of text in the is encountered.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitSectionEnd(com.aspose.words.Section)">visitSectionEnd</A></B>(<A HREF="Section.html" title="class in com.aspose.words">Section</A>&nbsp;section)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a section has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitSectionStart(com.aspose.words.Section)">visitSectionStart</A></B>(<A HREF="Section.html" title="class in com.aspose.words">Section</A>&nbsp;section)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a section has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitShapeEnd(com.aspose.words.Shape)">visitShapeEnd</A></B>(<A HREF="Shape.html" title="class in com.aspose.words">Shape</A>&nbsp;shape)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a shape has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitShapeStart(com.aspose.words.Shape)">visitShapeStart</A></B>(<A HREF="Shape.html" title="class in com.aspose.words">Shape</A>&nbsp;shape)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a shape has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitSmartTagEnd(com.aspose.words.SmartTag)">visitSmartTagEnd</A></B>(<A HREF="SmartTag.html" title="class in com.aspose.words">SmartTag</A>&nbsp;smartTag)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a smart tag has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitSmartTagStart(com.aspose.words.SmartTag)">visitSmartTagStart</A></B>(<A HREF="SmartTag.html" title="class in com.aspose.words">SmartTag</A>&nbsp;smartTag)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a smart tag has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitSpecialChar(com.aspose.words.SpecialChar)">visitSpecialChar</A></B>(<A HREF="SpecialChar.html" title="class in com.aspose.words">SpecialChar</A>&nbsp;specialChar)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a <cref><A HREF="SpecialChar.html" title="class in com.aspose.words">SpecialChar</A></cref> node is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitStructuredDocumentTagEnd(com.aspose.words.StructuredDocumentTag)">visitStructuredDocumentTagEnd</A></B>(<A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A>&nbsp;sdt)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a structured document tag has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitStructuredDocumentTagStart(com.aspose.words.StructuredDocumentTag)">visitStructuredDocumentTagStart</A></B>(<A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A>&nbsp;sdt)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a structured document tag has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitSubDocument(com.aspose.words.SubDocument)">visitSubDocument</A></B>(<A HREF="SubDocument.html" title="class in com.aspose.words">SubDocument</A>&nbsp;subDocument)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a subDocument is encountered.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitTableEnd(com.aspose.words.Table)">visitTableEnd</A></B>(<A HREF="Table.html" title="class in com.aspose.words">Table</A>&nbsp;table)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a table has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitTableStart(com.aspose.words.Table)">visitTableStart</A></B>(<A HREF="Table.html" title="class in com.aspose.words">Table</A>&nbsp;table)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a table has started.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="visitAbsolutePositionTab(com.aspose.words.AbsolutePositionTab)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitAbsolutePositionTab</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitAbsolutePositionTab</B>(<A HREF="AbsolutePositionTab.html" title="class in com.aspose.words">AbsolutePositionTab</A>&nbsp;tab)
                            throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a <cref><A HREF="AbsolutePositionTab.html" title="class in com.aspose.words">AbsolutePositionTab</A></cref> node is encountered in the document.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="tab"><CODE>tab</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use the Visitor pattern to add new operations to the Aspose.Words object model. In this case we create a simple document converter into a text format.<pre>
public void toText() throws Exception
{
    // Open the document we want to convert.
    Document doc = new Document(getMyDir() + "Visitor.ToText.doc");

    // Create an object that inherits from the DocumentVisitor class.
    MyDocToTxtWriter myConverter = new MyDocToTxtWriter();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).
    //
    // Note that every node in the object model has the Accept method so the visiting
    // can be executed not only for the whole document, but for any node in the document.
    doc.accept(myConverter);

    // Once the visiting is complete, we can retrieve the result of the operation,
    // that in this example, has accumulated in the visitor.
    System.out.println(myConverter.getText());
}

/**
 * Simple implementation of saving a document in the plain text format. Implemented as a Visitor.
 */
public class MyDocToTxtWriter extends DocumentVisitor
{
    public MyDocToTxtWriter()
    {
        mIsSkipText = false;
        mBuilder = new StringBuilder();
    }

    /**
     * Gets the plain text of the document that was accumulated by the visitor.
     */
    public String getText()
    {
        return mBuilder.toString();
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        appendText(run.getText());

        // Let the visitor continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart)
    {
        // In Microsoft Word, a field code (such as "MERGEFIELD FieldName") follows
        // after a field start character. We want to skip field codes and output field
        // result only, therefore we use a flag to suspend the output while inside a field code.
        //
        // Note this is a very simplistic implementation and will not work very well
        // if you have nested fields in a document.
        mIsSkipText = true;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator)
    {
        // Once reached a field separator node, we enable the output because we are
        // now entering the field result nodes.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd)
    {
        // Make sure we enable the output when reached a field end because some fields
        // do not have field separator and do not have field result.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Paragraph node is ended in the document.
     */
    public int visitParagraphEnd(Paragraph paragraph) throws Exception
    {
        // When outputting to plain text we output Cr+Lf characters.
        appendText(ControlChar.CR_LF);

        return VisitorAction.CONTINUE;
    }

    public int visitBodyStart(Body body)
    {
        // We can detect beginning and end of all composite nodes such as Section, Body,
        // Table, Paragraph etc and provide custom handling for them.
        mBuilder.append("*** Body Started ***\r\n");

        return VisitorAction.CONTINUE;
    }

    public int visitBodyEnd(Body body)
    {
        mBuilder.append("*** Body Ended ***\r\n");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a HeaderFooter node is encountered in the document.
     */
    public int visitHeaderFooterStart(HeaderFooter headerFooter)
    {
        // Returning this value from a visitor method causes visiting of this
        // node to stop and move on to visiting the next sibling node.
        // The net effect in this example is that the text of headers and footers
        // is not included in the resulting output.
        return VisitorAction.SKIP_THIS_NODE;
    }

    /**
     * Called when an AbsolutePositionTab is encountered in the document.
     */
    public int visitAbsolutePositionTab(AbsolutePositionTab tab)
    {
        mBuilder.append("\t");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkStart is encountered in the document.
     */
    public int visitBookmarkStart(BookmarkStart bookmarkStart)
    {
        mBuilder.append("[");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkEnd is encountered in the document.
     */
    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd)
    {
        mBuilder.append("]");
        return VisitorAction.CONTINUE;
    }

    /**
     * Adds text to the current output. Honours the enabled/disabled output flag.
     */
    private void appendText(String text)
    {
        if (!mIsSkipText) mBuilder.append(text);
    }

    private final StringBuilder mBuilder;
    private boolean mIsSkipText;
}</pre></example>
</DL>
<HR>

<A NAME="visitBodyEnd(com.aspose.words.Body)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitBodyEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitBodyEnd</B>(<A HREF="Body.html" title="class in com.aspose.words">Body</A>&nbsp;body)
                throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of the main text story in a section has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="body"><CODE>body</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use the Visitor pattern to add new operations to the Aspose.Words object model. In this case we create a simple document converter into a text format.<pre>
public void toText() throws Exception
{
    // Open the document we want to convert.
    Document doc = new Document(getMyDir() + "Visitor.ToText.doc");

    // Create an object that inherits from the DocumentVisitor class.
    MyDocToTxtWriter myConverter = new MyDocToTxtWriter();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).
    //
    // Note that every node in the object model has the Accept method so the visiting
    // can be executed not only for the whole document, but for any node in the document.
    doc.accept(myConverter);

    // Once the visiting is complete, we can retrieve the result of the operation,
    // that in this example, has accumulated in the visitor.
    System.out.println(myConverter.getText());
}

/**
 * Simple implementation of saving a document in the plain text format. Implemented as a Visitor.
 */
public class MyDocToTxtWriter extends DocumentVisitor
{
    public MyDocToTxtWriter()
    {
        mIsSkipText = false;
        mBuilder = new StringBuilder();
    }

    /**
     * Gets the plain text of the document that was accumulated by the visitor.
     */
    public String getText()
    {
        return mBuilder.toString();
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        appendText(run.getText());

        // Let the visitor continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart)
    {
        // In Microsoft Word, a field code (such as "MERGEFIELD FieldName") follows
        // after a field start character. We want to skip field codes and output field
        // result only, therefore we use a flag to suspend the output while inside a field code.
        //
        // Note this is a very simplistic implementation and will not work very well
        // if you have nested fields in a document.
        mIsSkipText = true;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator)
    {
        // Once reached a field separator node, we enable the output because we are
        // now entering the field result nodes.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd)
    {
        // Make sure we enable the output when reached a field end because some fields
        // do not have field separator and do not have field result.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Paragraph node is ended in the document.
     */
    public int visitParagraphEnd(Paragraph paragraph) throws Exception
    {
        // When outputting to plain text we output Cr+Lf characters.
        appendText(ControlChar.CR_LF);

        return VisitorAction.CONTINUE;
    }

    public int visitBodyStart(Body body)
    {
        // We can detect beginning and end of all composite nodes such as Section, Body,
        // Table, Paragraph etc and provide custom handling for them.
        mBuilder.append("*** Body Started ***\r\n");

        return VisitorAction.CONTINUE;
    }

    public int visitBodyEnd(Body body)
    {
        mBuilder.append("*** Body Ended ***\r\n");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a HeaderFooter node is encountered in the document.
     */
    public int visitHeaderFooterStart(HeaderFooter headerFooter)
    {
        // Returning this value from a visitor method causes visiting of this
        // node to stop and move on to visiting the next sibling node.
        // The net effect in this example is that the text of headers and footers
        // is not included in the resulting output.
        return VisitorAction.SKIP_THIS_NODE;
    }

    /**
     * Called when an AbsolutePositionTab is encountered in the document.
     */
    public int visitAbsolutePositionTab(AbsolutePositionTab tab)
    {
        mBuilder.append("\t");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkStart is encountered in the document.
     */
    public int visitBookmarkStart(BookmarkStart bookmarkStart)
    {
        mBuilder.append("[");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkEnd is encountered in the document.
     */
    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd)
    {
        mBuilder.append("]");
        return VisitorAction.CONTINUE;
    }

    /**
     * Adds text to the current output. Honours the enabled/disabled output flag.
     */
    private void appendText(String text)
    {
        if (!mIsSkipText) mBuilder.append(text);
    }

    private final StringBuilder mBuilder;
    private boolean mIsSkipText;
}</pre></example>
</DL>
<HR>

<A NAME="visitBodyStart(com.aspose.words.Body)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitBodyStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitBodyStart</B>(<A HREF="Body.html" title="class in com.aspose.words">Body</A>&nbsp;body)
                  throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of the main text story in a section has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="body"><CODE>body</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use the Visitor pattern to add new operations to the Aspose.Words object model. In this case we create a simple document converter into a text format.<pre>
public void toText() throws Exception
{
    // Open the document we want to convert.
    Document doc = new Document(getMyDir() + "Visitor.ToText.doc");

    // Create an object that inherits from the DocumentVisitor class.
    MyDocToTxtWriter myConverter = new MyDocToTxtWriter();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).
    //
    // Note that every node in the object model has the Accept method so the visiting
    // can be executed not only for the whole document, but for any node in the document.
    doc.accept(myConverter);

    // Once the visiting is complete, we can retrieve the result of the operation,
    // that in this example, has accumulated in the visitor.
    System.out.println(myConverter.getText());
}

/**
 * Simple implementation of saving a document in the plain text format. Implemented as a Visitor.
 */
public class MyDocToTxtWriter extends DocumentVisitor
{
    public MyDocToTxtWriter()
    {
        mIsSkipText = false;
        mBuilder = new StringBuilder();
    }

    /**
     * Gets the plain text of the document that was accumulated by the visitor.
     */
    public String getText()
    {
        return mBuilder.toString();
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        appendText(run.getText());

        // Let the visitor continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart)
    {
        // In Microsoft Word, a field code (such as "MERGEFIELD FieldName") follows
        // after a field start character. We want to skip field codes and output field
        // result only, therefore we use a flag to suspend the output while inside a field code.
        //
        // Note this is a very simplistic implementation and will not work very well
        // if you have nested fields in a document.
        mIsSkipText = true;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator)
    {
        // Once reached a field separator node, we enable the output because we are
        // now entering the field result nodes.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd)
    {
        // Make sure we enable the output when reached a field end because some fields
        // do not have field separator and do not have field result.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Paragraph node is ended in the document.
     */
    public int visitParagraphEnd(Paragraph paragraph) throws Exception
    {
        // When outputting to plain text we output Cr+Lf characters.
        appendText(ControlChar.CR_LF);

        return VisitorAction.CONTINUE;
    }

    public int visitBodyStart(Body body)
    {
        // We can detect beginning and end of all composite nodes such as Section, Body,
        // Table, Paragraph etc and provide custom handling for them.
        mBuilder.append("*** Body Started ***\r\n");

        return VisitorAction.CONTINUE;
    }

    public int visitBodyEnd(Body body)
    {
        mBuilder.append("*** Body Ended ***\r\n");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a HeaderFooter node is encountered in the document.
     */
    public int visitHeaderFooterStart(HeaderFooter headerFooter)
    {
        // Returning this value from a visitor method causes visiting of this
        // node to stop and move on to visiting the next sibling node.
        // The net effect in this example is that the text of headers and footers
        // is not included in the resulting output.
        return VisitorAction.SKIP_THIS_NODE;
    }

    /**
     * Called when an AbsolutePositionTab is encountered in the document.
     */
    public int visitAbsolutePositionTab(AbsolutePositionTab tab)
    {
        mBuilder.append("\t");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkStart is encountered in the document.
     */
    public int visitBookmarkStart(BookmarkStart bookmarkStart)
    {
        mBuilder.append("[");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkEnd is encountered in the document.
     */
    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd)
    {
        mBuilder.append("]");
        return VisitorAction.CONTINUE;
    }

    /**
     * Adds text to the current output. Honours the enabled/disabled output flag.
     */
    private void appendText(String text)
    {
        if (!mIsSkipText) mBuilder.append(text);
    }

    private final StringBuilder mBuilder;
    private boolean mIsSkipText;
}</pre></example>
</DL>
<HR>

<A NAME="visitBookmarkEnd(com.aspose.words.BookmarkEnd)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitBookmarkEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitBookmarkEnd</B>(<A HREF="BookmarkEnd.html" title="class in com.aspose.words">BookmarkEnd</A>&nbsp;bookmarkEnd)
                    throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when an end of a bookmark is encountered in the document.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="bookmarkEnd"><CODE>bookmarkEnd</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use the Visitor pattern to add new operations to the Aspose.Words object model. In this case we create a simple document converter into a text format.<pre>
public void toText() throws Exception
{
    // Open the document we want to convert.
    Document doc = new Document(getMyDir() + "Visitor.ToText.doc");

    // Create an object that inherits from the DocumentVisitor class.
    MyDocToTxtWriter myConverter = new MyDocToTxtWriter();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).
    //
    // Note that every node in the object model has the Accept method so the visiting
    // can be executed not only for the whole document, but for any node in the document.
    doc.accept(myConverter);

    // Once the visiting is complete, we can retrieve the result of the operation,
    // that in this example, has accumulated in the visitor.
    System.out.println(myConverter.getText());
}

/**
 * Simple implementation of saving a document in the plain text format. Implemented as a Visitor.
 */
public class MyDocToTxtWriter extends DocumentVisitor
{
    public MyDocToTxtWriter()
    {
        mIsSkipText = false;
        mBuilder = new StringBuilder();
    }

    /**
     * Gets the plain text of the document that was accumulated by the visitor.
     */
    public String getText()
    {
        return mBuilder.toString();
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        appendText(run.getText());

        // Let the visitor continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart)
    {
        // In Microsoft Word, a field code (such as "MERGEFIELD FieldName") follows
        // after a field start character. We want to skip field codes and output field
        // result only, therefore we use a flag to suspend the output while inside a field code.
        //
        // Note this is a very simplistic implementation and will not work very well
        // if you have nested fields in a document.
        mIsSkipText = true;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator)
    {
        // Once reached a field separator node, we enable the output because we are
        // now entering the field result nodes.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd)
    {
        // Make sure we enable the output when reached a field end because some fields
        // do not have field separator and do not have field result.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Paragraph node is ended in the document.
     */
    public int visitParagraphEnd(Paragraph paragraph) throws Exception
    {
        // When outputting to plain text we output Cr+Lf characters.
        appendText(ControlChar.CR_LF);

        return VisitorAction.CONTINUE;
    }

    public int visitBodyStart(Body body)
    {
        // We can detect beginning and end of all composite nodes such as Section, Body,
        // Table, Paragraph etc and provide custom handling for them.
        mBuilder.append("*** Body Started ***\r\n");

        return VisitorAction.CONTINUE;
    }

    public int visitBodyEnd(Body body)
    {
        mBuilder.append("*** Body Ended ***\r\n");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a HeaderFooter node is encountered in the document.
     */
    public int visitHeaderFooterStart(HeaderFooter headerFooter)
    {
        // Returning this value from a visitor method causes visiting of this
        // node to stop and move on to visiting the next sibling node.
        // The net effect in this example is that the text of headers and footers
        // is not included in the resulting output.
        return VisitorAction.SKIP_THIS_NODE;
    }

    /**
     * Called when an AbsolutePositionTab is encountered in the document.
     */
    public int visitAbsolutePositionTab(AbsolutePositionTab tab)
    {
        mBuilder.append("\t");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkStart is encountered in the document.
     */
    public int visitBookmarkStart(BookmarkStart bookmarkStart)
    {
        mBuilder.append("[");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkEnd is encountered in the document.
     */
    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd)
    {
        mBuilder.append("]");
        return VisitorAction.CONTINUE;
    }

    /**
     * Adds text to the current output. Honours the enabled/disabled output flag.
     */
    private void appendText(String text)
    {
        if (!mIsSkipText) mBuilder.append(text);
    }

    private final StringBuilder mBuilder;
    private boolean mIsSkipText;
}</pre></example>
</DL>
<HR>

<A NAME="visitBookmarkStart(com.aspose.words.BookmarkStart)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitBookmarkStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitBookmarkStart</B>(<A HREF="BookmarkStart.html" title="class in com.aspose.words">BookmarkStart</A>&nbsp;bookmarkStart)
                      throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a start of a bookmark is encountered in the document.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="bookmarkStart"><CODE>bookmarkStart</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use the Visitor pattern to add new operations to the Aspose.Words object model. In this case we create a simple document converter into a text format.<pre>
public void toText() throws Exception
{
    // Open the document we want to convert.
    Document doc = new Document(getMyDir() + "Visitor.ToText.doc");

    // Create an object that inherits from the DocumentVisitor class.
    MyDocToTxtWriter myConverter = new MyDocToTxtWriter();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).
    //
    // Note that every node in the object model has the Accept method so the visiting
    // can be executed not only for the whole document, but for any node in the document.
    doc.accept(myConverter);

    // Once the visiting is complete, we can retrieve the result of the operation,
    // that in this example, has accumulated in the visitor.
    System.out.println(myConverter.getText());
}

/**
 * Simple implementation of saving a document in the plain text format. Implemented as a Visitor.
 */
public class MyDocToTxtWriter extends DocumentVisitor
{
    public MyDocToTxtWriter()
    {
        mIsSkipText = false;
        mBuilder = new StringBuilder();
    }

    /**
     * Gets the plain text of the document that was accumulated by the visitor.
     */
    public String getText()
    {
        return mBuilder.toString();
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        appendText(run.getText());

        // Let the visitor continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart)
    {
        // In Microsoft Word, a field code (such as "MERGEFIELD FieldName") follows
        // after a field start character. We want to skip field codes and output field
        // result only, therefore we use a flag to suspend the output while inside a field code.
        //
        // Note this is a very simplistic implementation and will not work very well
        // if you have nested fields in a document.
        mIsSkipText = true;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator)
    {
        // Once reached a field separator node, we enable the output because we are
        // now entering the field result nodes.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd)
    {
        // Make sure we enable the output when reached a field end because some fields
        // do not have field separator and do not have field result.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Paragraph node is ended in the document.
     */
    public int visitParagraphEnd(Paragraph paragraph) throws Exception
    {
        // When outputting to plain text we output Cr+Lf characters.
        appendText(ControlChar.CR_LF);

        return VisitorAction.CONTINUE;
    }

    public int visitBodyStart(Body body)
    {
        // We can detect beginning and end of all composite nodes such as Section, Body,
        // Table, Paragraph etc and provide custom handling for them.
        mBuilder.append("*** Body Started ***\r\n");

        return VisitorAction.CONTINUE;
    }

    public int visitBodyEnd(Body body)
    {
        mBuilder.append("*** Body Ended ***\r\n");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a HeaderFooter node is encountered in the document.
     */
    public int visitHeaderFooterStart(HeaderFooter headerFooter)
    {
        // Returning this value from a visitor method causes visiting of this
        // node to stop and move on to visiting the next sibling node.
        // The net effect in this example is that the text of headers and footers
        // is not included in the resulting output.
        return VisitorAction.SKIP_THIS_NODE;
    }

    /**
     * Called when an AbsolutePositionTab is encountered in the document.
     */
    public int visitAbsolutePositionTab(AbsolutePositionTab tab)
    {
        mBuilder.append("\t");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkStart is encountered in the document.
     */
    public int visitBookmarkStart(BookmarkStart bookmarkStart)
    {
        mBuilder.append("[");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkEnd is encountered in the document.
     */
    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd)
    {
        mBuilder.append("]");
        return VisitorAction.CONTINUE;
    }

    /**
     * Adds text to the current output. Honours the enabled/disabled output flag.
     */
    private void appendText(String text)
    {
        if (!mIsSkipText) mBuilder.append(text);
    }

    private final StringBuilder mBuilder;
    private boolean mIsSkipText;
}</pre></example>
</DL>
<HR>

<A NAME="visitBuildingBlockEnd(com.aspose.words.BuildingBlock)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitBuildingBlockEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitBuildingBlockEnd</B>(<A HREF="BuildingBlock.html" title="class in com.aspose.words">BuildingBlock</A>&nbsp;block)
                         throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a building block has ended.
            </summary><remarks><p>
Note: A building block node and its children are not visited when you execute a
Visitor over a <cref><A HREF="Document.html" title="class in com.aspose.words">Document</A></cref>. If you want to execute a Visitor over a
building block, you need to execute the visitor over <cref><A HREF="GlossaryDocument.html" title="class in com.aspose.words">GlossaryDocument</A></cref> or
call <cref><A HREF="BuildingBlock.html#accept(com.aspose.words.DocumentVisitor)" title="method in class com.aspose.words.BuildingBlock">BuildingBlock.accept(com.aspose.words.DocumentVisitor)</A></cref>.
</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="block"><CODE>block</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitBuildingBlockStart(com.aspose.words.BuildingBlock)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitBuildingBlockStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitBuildingBlockStart</B>(<A HREF="BuildingBlock.html" title="class in com.aspose.words">BuildingBlock</A>&nbsp;block)
                           throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a building block has started.
            </summary><remarks><p>
Note: A building block node and its children are not visited when you execute a
Visitor over a <cref><A HREF="Document.html" title="class in com.aspose.words">Document</A></cref>. If you want to execute a Visitor over a
building block, you need to execute the visitor over <cref><A HREF="GlossaryDocument.html" title="class in com.aspose.words">GlossaryDocument</A></cref> or
call <cref><A HREF="BuildingBlock.html#accept(com.aspose.words.DocumentVisitor)" title="method in class com.aspose.words.BuildingBlock">BuildingBlock.accept(com.aspose.words.DocumentVisitor)</A></cref>.
</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="block"><CODE>block</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitCellEnd(com.aspose.words.Cell)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitCellEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitCellEnd</B>(<A HREF="Cell.html" title="class in com.aspose.words">Cell</A>&nbsp;cell)
                throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a table cell has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="cell"><CODE>cell</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Implements the Visitor Pattern to remove all content formatted as hidden from the document.<pre>
public void removeHiddenContentFromDocument() throws Exception
{
    // Open the document we want to remove hidden content from.
    Document doc = new Document(getMyDir() + "Font.Hidden.doc");

    // Create an object that inherits from the DocumentVisitor class.
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).

    // We can run it over the entire the document like so:
    doc.accept(hiddenContentRemover);

    // Or we can run it on only a specific node.
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // Or over a different type of node like below.
    Table table = (Table) doc.getChild(NodeType.TABLE, 0, true);
    table.accept(hiddenContentRemover);

    doc.save(getMyDir() + "\\Artifacts\\Font.Hidden.doc");

}

/**
 * This class when executed will remove all hidden content from the Document. Implemented as a Visitor.
 */
private class RemoveHiddenContentVisitor extends DocumentVisitor
{
    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart) throws Exception
    {
        // If this node is hidden, then remove it.
        if (isHidden(fieldStart)) fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd) throws Exception
    {
        if (isHidden(fieldEnd)) fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator) throws Exception
    {
        if (isHidden(fieldSeparator)) fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        if (isHidden(run)) run.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Paragraph node is encountered in the document.
     */
    public int visitParagraphStart(Paragraph paragraph) throws Exception
    {
        if (isHidden(paragraph)) paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FormField is encountered in the document.
     */
    public int visitFormField(FormField field) throws Exception
    {
        if (isHidden(field)) field.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a GroupShape is encountered in the document.
     */
    public int visitGroupShapeStart(GroupShape groupShape) throws Exception
    {
        if (isHidden(groupShape)) groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Shape is encountered in the document.
     */
    public int visitShapeStart(Shape shape) throws Exception
    {
        if (isHidden(shape)) shape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Comment is encountered in the document.
     */
    public int visitCommentStart(Comment comment) throws Exception
    {
        if (isHidden(comment)) comment.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Footnote is encountered in the document.
     */
    public int visitFootnoteStart(Footnote footnote) throws Exception
    {
        if (isHidden(footnote)) footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Table node is ended in the document.
     */
    public int visitTableEnd(Table table)
    {
        // At the moment there is no way to tell if a particular Table/Row/Cell is hidden.
        // Instead, if the content of a table is hidden, then all inline child nodes of the table should be
        // hidden and thus removed by previous visits as well. This will result in the container being empty
        // so if this is the case we know to remove the table node.
        //
        // Note that a table which is not hidden but simply has no content will not be affected by this algorthim,
        // as technically they are not completely empty (for example a properly formed Cell will have at least
        // an empty paragraph in it)
        if (!table.hasChildNodes()) table.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Cell node is ended in the document.
     */
    public int visitCellEnd(Cell cell)
    {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null) cell.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Row node is ended in the document.
     */
    public int visitRowEnd(Row row)
    {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null) row.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a SpecialCharacter is encountered in the document.
     */
    public int visitSpecialChar(SpecialChar character) throws Exception
    {
        if (isHidden(character)) character.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Returns true if the node passed is set as hidden, returns false if it is visible.
     */
    private boolean isHidden(Node node)
    {
        if (node instanceof Inline)
        {
            // If the node is Inline then cast it to retrieve the Font property which contains the hidden property
            Inline currentNode = (Inline) node;
            return currentNode.getFont().getHidden();
        } else if (node.getNodeType() == NodeType.PARAGRAPH)
        {
            // If the node is a paragraph cast it to retrieve the ParagraphBreakFont which contains the hidden property
            Paragraph para = (Paragraph) node;
            return para.getParagraphBreakFont().getHidden();
        } else if (node instanceof ShapeBase)
        {
            // Node is a shape or groupshape.
            ShapeBase shape = (ShapeBase) node;
            return shape.getFont().getHidden();
        } else if (node instanceof InlineStory)
        {
            // Node is a comment or footnote.
            InlineStory inlineStory = (InlineStory) node;
            return inlineStory.getFont().getHidden();
        }

        // A node that is passed to this method which does not contain a hidden property will end up here.
        // By default nodes are not hidden so return false.
        return false;
    }
}</pre></example>
</DL>
<HR>

<A NAME="visitCellStart(com.aspose.words.Cell)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitCellStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitCellStart</B>(<A HREF="Cell.html" title="class in com.aspose.words">Cell</A>&nbsp;cell)
                  throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a table cell has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="cell"><CODE>cell</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitCommentEnd(com.aspose.words.Comment)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitCommentEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitCommentEnd</B>(<A HREF="Comment.html" title="class in com.aspose.words">Comment</A>&nbsp;comment)
                   throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a comment text has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="comment"><CODE>comment</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitCommentRangeEnd(com.aspose.words.CommentRangeEnd)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitCommentRangeEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitCommentRangeEnd</B>(<A HREF="CommentRangeEnd.html" title="class in com.aspose.words">CommentRangeEnd</A>&nbsp;commentRangeEnd)
                        throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when the end of a commented range of text is encountered.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="commentRangeEnd"><CODE>commentRangeEnd</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitCommentRangeStart(com.aspose.words.CommentRangeStart)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitCommentRangeStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitCommentRangeStart</B>(<A HREF="CommentRangeStart.html" title="class in com.aspose.words">CommentRangeStart</A>&nbsp;commentRangeStart)
                          throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when the start of a commented range of text is encountered.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="commentRangeStart"><CODE>commentRangeStart</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitCommentStart(com.aspose.words.Comment)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitCommentStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitCommentStart</B>(<A HREF="Comment.html" title="class in com.aspose.words">Comment</A>&nbsp;comment)
                     throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a comment text has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="comment"><CODE>comment</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Implements the Visitor Pattern to remove all content formatted as hidden from the document.<pre>
public void removeHiddenContentFromDocument() throws Exception
{
    // Open the document we want to remove hidden content from.
    Document doc = new Document(getMyDir() + "Font.Hidden.doc");

    // Create an object that inherits from the DocumentVisitor class.
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).

    // We can run it over the entire the document like so:
    doc.accept(hiddenContentRemover);

    // Or we can run it on only a specific node.
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // Or over a different type of node like below.
    Table table = (Table) doc.getChild(NodeType.TABLE, 0, true);
    table.accept(hiddenContentRemover);

    doc.save(getMyDir() + "\\Artifacts\\Font.Hidden.doc");

}

/**
 * This class when executed will remove all hidden content from the Document. Implemented as a Visitor.
 */
private class RemoveHiddenContentVisitor extends DocumentVisitor
{
    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart) throws Exception
    {
        // If this node is hidden, then remove it.
        if (isHidden(fieldStart)) fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd) throws Exception
    {
        if (isHidden(fieldEnd)) fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator) throws Exception
    {
        if (isHidden(fieldSeparator)) fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        if (isHidden(run)) run.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Paragraph node is encountered in the document.
     */
    public int visitParagraphStart(Paragraph paragraph) throws Exception
    {
        if (isHidden(paragraph)) paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FormField is encountered in the document.
     */
    public int visitFormField(FormField field) throws Exception
    {
        if (isHidden(field)) field.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a GroupShape is encountered in the document.
     */
    public int visitGroupShapeStart(GroupShape groupShape) throws Exception
    {
        if (isHidden(groupShape)) groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Shape is encountered in the document.
     */
    public int visitShapeStart(Shape shape) throws Exception
    {
        if (isHidden(shape)) shape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Comment is encountered in the document.
     */
    public int visitCommentStart(Comment comment) throws Exception
    {
        if (isHidden(comment)) comment.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Footnote is encountered in the document.
     */
    public int visitFootnoteStart(Footnote footnote) throws Exception
    {
        if (isHidden(footnote)) footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Table node is ended in the document.
     */
    public int visitTableEnd(Table table)
    {
        // At the moment there is no way to tell if a particular Table/Row/Cell is hidden.
        // Instead, if the content of a table is hidden, then all inline child nodes of the table should be
        // hidden and thus removed by previous visits as well. This will result in the container being empty
        // so if this is the case we know to remove the table node.
        //
        // Note that a table which is not hidden but simply has no content will not be affected by this algorthim,
        // as technically they are not completely empty (for example a properly formed Cell will have at least
        // an empty paragraph in it)
        if (!table.hasChildNodes()) table.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Cell node is ended in the document.
     */
    public int visitCellEnd(Cell cell)
    {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null) cell.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Row node is ended in the document.
     */
    public int visitRowEnd(Row row)
    {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null) row.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a SpecialCharacter is encountered in the document.
     */
    public int visitSpecialChar(SpecialChar character) throws Exception
    {
        if (isHidden(character)) character.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Returns true if the node passed is set as hidden, returns false if it is visible.
     */
    private boolean isHidden(Node node)
    {
        if (node instanceof Inline)
        {
            // If the node is Inline then cast it to retrieve the Font property which contains the hidden property
            Inline currentNode = (Inline) node;
            return currentNode.getFont().getHidden();
        } else if (node.getNodeType() == NodeType.PARAGRAPH)
        {
            // If the node is a paragraph cast it to retrieve the ParagraphBreakFont which contains the hidden property
            Paragraph para = (Paragraph) node;
            return para.getParagraphBreakFont().getHidden();
        } else if (node instanceof ShapeBase)
        {
            // Node is a shape or groupshape.
            ShapeBase shape = (ShapeBase) node;
            return shape.getFont().getHidden();
        } else if (node instanceof InlineStory)
        {
            // Node is a comment or footnote.
            InlineStory inlineStory = (InlineStory) node;
            return inlineStory.getFont().getHidden();
        }

        // A node that is passed to this method which does not contain a hidden property will end up here.
        // By default nodes are not hidden so return false.
        return false;
    }
}</pre></example>
</DL>
<HR>

<A NAME="visitDocumentEnd(com.aspose.words.Document)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitDocumentEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitDocumentEnd</B>(<A HREF="Document.html" title="class in com.aspose.words">Document</A>&nbsp;doc)
                    throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of the document has finished.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="doc"><CODE>doc</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitDocumentStart(com.aspose.words.Document)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitDocumentStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitDocumentStart</B>(<A HREF="Document.html" title="class in com.aspose.words">Document</A>&nbsp;doc)
                      throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of the document has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="doc"><CODE>doc</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitEditableRangeEnd(com.aspose.words.EditableRangeEnd)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitEditableRangeEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitEditableRangeEnd</B>(<A HREF="EditableRangeEnd.html" title="class in com.aspose.words">EditableRangeEnd</A>&nbsp;editableRangeEnd)
                         throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when an end of an editable range is encountered in the document.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="editableRangeEnd"><CODE>editableRangeEnd</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitEditableRangeStart(com.aspose.words.EditableRangeStart)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitEditableRangeStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitEditableRangeStart</B>(<A HREF="EditableRangeStart.html" title="class in com.aspose.words">EditableRangeStart</A>&nbsp;editableRangeStart)
                           throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a start of an editable range is encountered in the document.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="editableRangeStart"><CODE>editableRangeStart</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitFieldEnd(com.aspose.words.FieldEnd)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitFieldEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitFieldEnd</B>(<A HREF="FieldEnd.html" title="class in com.aspose.words">FieldEnd</A>&nbsp;fieldEnd)
                 throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a field ends in the document.
            </summary><remarks><p>For more info see <cref><A HREF="#visitFieldStart(com.aspose.words.FieldStart)" title="method in class com.aspose.words.DocumentVisitor">visitFieldStart(com.aspose.words.FieldStart)</A></cref></p></remarks><DL><DT><B>Parameters:</B></DT><DD param="fieldEnd"><CODE>fieldEnd</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use the Visitor pattern to add new operations to the Aspose.Words object model. In this case we create a simple document converter into a text format.<pre>
public void toText() throws Exception
{
    // Open the document we want to convert.
    Document doc = new Document(getMyDir() + "Visitor.ToText.doc");

    // Create an object that inherits from the DocumentVisitor class.
    MyDocToTxtWriter myConverter = new MyDocToTxtWriter();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).
    //
    // Note that every node in the object model has the Accept method so the visiting
    // can be executed not only for the whole document, but for any node in the document.
    doc.accept(myConverter);

    // Once the visiting is complete, we can retrieve the result of the operation,
    // that in this example, has accumulated in the visitor.
    System.out.println(myConverter.getText());
}

/**
 * Simple implementation of saving a document in the plain text format. Implemented as a Visitor.
 */
public class MyDocToTxtWriter extends DocumentVisitor
{
    public MyDocToTxtWriter()
    {
        mIsSkipText = false;
        mBuilder = new StringBuilder();
    }

    /**
     * Gets the plain text of the document that was accumulated by the visitor.
     */
    public String getText()
    {
        return mBuilder.toString();
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        appendText(run.getText());

        // Let the visitor continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart)
    {
        // In Microsoft Word, a field code (such as "MERGEFIELD FieldName") follows
        // after a field start character. We want to skip field codes and output field
        // result only, therefore we use a flag to suspend the output while inside a field code.
        //
        // Note this is a very simplistic implementation and will not work very well
        // if you have nested fields in a document.
        mIsSkipText = true;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator)
    {
        // Once reached a field separator node, we enable the output because we are
        // now entering the field result nodes.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd)
    {
        // Make sure we enable the output when reached a field end because some fields
        // do not have field separator and do not have field result.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Paragraph node is ended in the document.
     */
    public int visitParagraphEnd(Paragraph paragraph) throws Exception
    {
        // When outputting to plain text we output Cr+Lf characters.
        appendText(ControlChar.CR_LF);

        return VisitorAction.CONTINUE;
    }

    public int visitBodyStart(Body body)
    {
        // We can detect beginning and end of all composite nodes such as Section, Body,
        // Table, Paragraph etc and provide custom handling for them.
        mBuilder.append("*** Body Started ***\r\n");

        return VisitorAction.CONTINUE;
    }

    public int visitBodyEnd(Body body)
    {
        mBuilder.append("*** Body Ended ***\r\n");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a HeaderFooter node is encountered in the document.
     */
    public int visitHeaderFooterStart(HeaderFooter headerFooter)
    {
        // Returning this value from a visitor method causes visiting of this
        // node to stop and move on to visiting the next sibling node.
        // The net effect in this example is that the text of headers and footers
        // is not included in the resulting output.
        return VisitorAction.SKIP_THIS_NODE;
    }

    /**
     * Called when an AbsolutePositionTab is encountered in the document.
     */
    public int visitAbsolutePositionTab(AbsolutePositionTab tab)
    {
        mBuilder.append("\t");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkStart is encountered in the document.
     */
    public int visitBookmarkStart(BookmarkStart bookmarkStart)
    {
        mBuilder.append("[");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkEnd is encountered in the document.
     */
    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd)
    {
        mBuilder.append("]");
        return VisitorAction.CONTINUE;
    }

    /**
     * Adds text to the current output. Honours the enabled/disabled output flag.
     */
    private void appendText(String text)
    {
        if (!mIsSkipText) mBuilder.append(text);
    }

    private final StringBuilder mBuilder;
    private boolean mIsSkipText;
}</pre></example>
</DL>
<HR>

<A NAME="visitFieldSeparator(com.aspose.words.FieldSeparator)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitFieldSeparator</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitFieldSeparator</B>(<A HREF="FieldSeparator.html" title="class in com.aspose.words">FieldSeparator</A>&nbsp;fieldSeparator)
                       throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a field separator is encountered in the document.
            </summary><remarks><p>The field separator separates field code from field value in the document. Note that some 
            fields have only field code and do not have field separator and field value.</p><p>For more info see <cref><A HREF="#visitFieldStart(com.aspose.words.FieldStart)" title="method in class com.aspose.words.DocumentVisitor">visitFieldStart(com.aspose.words.FieldStart)</A></cref></p></remarks><DL><DT><B>Parameters:</B></DT><DD param="fieldSeparator"><CODE>fieldSeparator</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use the Visitor pattern to add new operations to the Aspose.Words object model. In this case we create a simple document converter into a text format.<pre>
public void toText() throws Exception
{
    // Open the document we want to convert.
    Document doc = new Document(getMyDir() + "Visitor.ToText.doc");

    // Create an object that inherits from the DocumentVisitor class.
    MyDocToTxtWriter myConverter = new MyDocToTxtWriter();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).
    //
    // Note that every node in the object model has the Accept method so the visiting
    // can be executed not only for the whole document, but for any node in the document.
    doc.accept(myConverter);

    // Once the visiting is complete, we can retrieve the result of the operation,
    // that in this example, has accumulated in the visitor.
    System.out.println(myConverter.getText());
}

/**
 * Simple implementation of saving a document in the plain text format. Implemented as a Visitor.
 */
public class MyDocToTxtWriter extends DocumentVisitor
{
    public MyDocToTxtWriter()
    {
        mIsSkipText = false;
        mBuilder = new StringBuilder();
    }

    /**
     * Gets the plain text of the document that was accumulated by the visitor.
     */
    public String getText()
    {
        return mBuilder.toString();
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        appendText(run.getText());

        // Let the visitor continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart)
    {
        // In Microsoft Word, a field code (such as "MERGEFIELD FieldName") follows
        // after a field start character. We want to skip field codes and output field
        // result only, therefore we use a flag to suspend the output while inside a field code.
        //
        // Note this is a very simplistic implementation and will not work very well
        // if you have nested fields in a document.
        mIsSkipText = true;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator)
    {
        // Once reached a field separator node, we enable the output because we are
        // now entering the field result nodes.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd)
    {
        // Make sure we enable the output when reached a field end because some fields
        // do not have field separator and do not have field result.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Paragraph node is ended in the document.
     */
    public int visitParagraphEnd(Paragraph paragraph) throws Exception
    {
        // When outputting to plain text we output Cr+Lf characters.
        appendText(ControlChar.CR_LF);

        return VisitorAction.CONTINUE;
    }

    public int visitBodyStart(Body body)
    {
        // We can detect beginning and end of all composite nodes such as Section, Body,
        // Table, Paragraph etc and provide custom handling for them.
        mBuilder.append("*** Body Started ***\r\n");

        return VisitorAction.CONTINUE;
    }

    public int visitBodyEnd(Body body)
    {
        mBuilder.append("*** Body Ended ***\r\n");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a HeaderFooter node is encountered in the document.
     */
    public int visitHeaderFooterStart(HeaderFooter headerFooter)
    {
        // Returning this value from a visitor method causes visiting of this
        // node to stop and move on to visiting the next sibling node.
        // The net effect in this example is that the text of headers and footers
        // is not included in the resulting output.
        return VisitorAction.SKIP_THIS_NODE;
    }

    /**
     * Called when an AbsolutePositionTab is encountered in the document.
     */
    public int visitAbsolutePositionTab(AbsolutePositionTab tab)
    {
        mBuilder.append("\t");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkStart is encountered in the document.
     */
    public int visitBookmarkStart(BookmarkStart bookmarkStart)
    {
        mBuilder.append("[");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkEnd is encountered in the document.
     */
    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd)
    {
        mBuilder.append("]");
        return VisitorAction.CONTINUE;
    }

    /**
     * Adds text to the current output. Honours the enabled/disabled output flag.
     */
    private void appendText(String text)
    {
        if (!mIsSkipText) mBuilder.append(text);
    }

    private final StringBuilder mBuilder;
    private boolean mIsSkipText;
}</pre></example>
</DL>
<HR>

<A NAME="visitFieldStart(com.aspose.words.FieldStart)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitFieldStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitFieldStart</B>(<A HREF="FieldStart.html" title="class in com.aspose.words">FieldStart</A>&nbsp;fieldStart)
                   throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a field starts in the document.
            </summary><remarks><p>A field in a Word Word document consists of a field code and field value.</p><p>For example, a field that displays a page number can be represented as follows:</p><p>[FieldStart]PAGE[FieldSeparator]98[FieldEnd]</p><p>The field separator separates field code from field value in the document. Note that some 
            fields have only field code and do not have field separator and field value.</p><p>Fields can be nested.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="fieldStart"><CODE>fieldStart</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use the Visitor pattern to add new operations to the Aspose.Words object model. In this case we create a simple document converter into a text format.<pre>
public void toText() throws Exception
{
    // Open the document we want to convert.
    Document doc = new Document(getMyDir() + "Visitor.ToText.doc");

    // Create an object that inherits from the DocumentVisitor class.
    MyDocToTxtWriter myConverter = new MyDocToTxtWriter();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).
    //
    // Note that every node in the object model has the Accept method so the visiting
    // can be executed not only for the whole document, but for any node in the document.
    doc.accept(myConverter);

    // Once the visiting is complete, we can retrieve the result of the operation,
    // that in this example, has accumulated in the visitor.
    System.out.println(myConverter.getText());
}

/**
 * Simple implementation of saving a document in the plain text format. Implemented as a Visitor.
 */
public class MyDocToTxtWriter extends DocumentVisitor
{
    public MyDocToTxtWriter()
    {
        mIsSkipText = false;
        mBuilder = new StringBuilder();
    }

    /**
     * Gets the plain text of the document that was accumulated by the visitor.
     */
    public String getText()
    {
        return mBuilder.toString();
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        appendText(run.getText());

        // Let the visitor continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart)
    {
        // In Microsoft Word, a field code (such as "MERGEFIELD FieldName") follows
        // after a field start character. We want to skip field codes and output field
        // result only, therefore we use a flag to suspend the output while inside a field code.
        //
        // Note this is a very simplistic implementation and will not work very well
        // if you have nested fields in a document.
        mIsSkipText = true;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator)
    {
        // Once reached a field separator node, we enable the output because we are
        // now entering the field result nodes.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd)
    {
        // Make sure we enable the output when reached a field end because some fields
        // do not have field separator and do not have field result.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Paragraph node is ended in the document.
     */
    public int visitParagraphEnd(Paragraph paragraph) throws Exception
    {
        // When outputting to plain text we output Cr+Lf characters.
        appendText(ControlChar.CR_LF);

        return VisitorAction.CONTINUE;
    }

    public int visitBodyStart(Body body)
    {
        // We can detect beginning and end of all composite nodes such as Section, Body,
        // Table, Paragraph etc and provide custom handling for them.
        mBuilder.append("*** Body Started ***\r\n");

        return VisitorAction.CONTINUE;
    }

    public int visitBodyEnd(Body body)
    {
        mBuilder.append("*** Body Ended ***\r\n");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a HeaderFooter node is encountered in the document.
     */
    public int visitHeaderFooterStart(HeaderFooter headerFooter)
    {
        // Returning this value from a visitor method causes visiting of this
        // node to stop and move on to visiting the next sibling node.
        // The net effect in this example is that the text of headers and footers
        // is not included in the resulting output.
        return VisitorAction.SKIP_THIS_NODE;
    }

    /**
     * Called when an AbsolutePositionTab is encountered in the document.
     */
    public int visitAbsolutePositionTab(AbsolutePositionTab tab)
    {
        mBuilder.append("\t");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkStart is encountered in the document.
     */
    public int visitBookmarkStart(BookmarkStart bookmarkStart)
    {
        mBuilder.append("[");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkEnd is encountered in the document.
     */
    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd)
    {
        mBuilder.append("]");
        return VisitorAction.CONTINUE;
    }

    /**
     * Adds text to the current output. Honours the enabled/disabled output flag.
     */
    private void appendText(String text)
    {
        if (!mIsSkipText) mBuilder.append(text);
    }

    private final StringBuilder mBuilder;
    private boolean mIsSkipText;
}</pre></example>
</DL>
<HR>

<A NAME="visitFootnoteEnd(com.aspose.words.Footnote)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitFootnoteEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitFootnoteEnd</B>(<A HREF="Footnote.html" title="class in com.aspose.words">Footnote</A>&nbsp;footnote)
                    throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a footnote or endnote text has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="footnote"><CODE>footnote</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitFootnoteStart(com.aspose.words.Footnote)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitFootnoteStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitFootnoteStart</B>(<A HREF="Footnote.html" title="class in com.aspose.words">Footnote</A>&nbsp;footnote)
                      throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a footnote or endnote text has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="footnote"><CODE>footnote</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Implements the Visitor Pattern to remove all content formatted as hidden from the document.<pre>
public void removeHiddenContentFromDocument() throws Exception
{
    // Open the document we want to remove hidden content from.
    Document doc = new Document(getMyDir() + "Font.Hidden.doc");

    // Create an object that inherits from the DocumentVisitor class.
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).

    // We can run it over the entire the document like so:
    doc.accept(hiddenContentRemover);

    // Or we can run it on only a specific node.
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // Or over a different type of node like below.
    Table table = (Table) doc.getChild(NodeType.TABLE, 0, true);
    table.accept(hiddenContentRemover);

    doc.save(getMyDir() + "\\Artifacts\\Font.Hidden.doc");

}

/**
 * This class when executed will remove all hidden content from the Document. Implemented as a Visitor.
 */
private class RemoveHiddenContentVisitor extends DocumentVisitor
{
    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart) throws Exception
    {
        // If this node is hidden, then remove it.
        if (isHidden(fieldStart)) fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd) throws Exception
    {
        if (isHidden(fieldEnd)) fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator) throws Exception
    {
        if (isHidden(fieldSeparator)) fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        if (isHidden(run)) run.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Paragraph node is encountered in the document.
     */
    public int visitParagraphStart(Paragraph paragraph) throws Exception
    {
        if (isHidden(paragraph)) paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FormField is encountered in the document.
     */
    public int visitFormField(FormField field) throws Exception
    {
        if (isHidden(field)) field.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a GroupShape is encountered in the document.
     */
    public int visitGroupShapeStart(GroupShape groupShape) throws Exception
    {
        if (isHidden(groupShape)) groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Shape is encountered in the document.
     */
    public int visitShapeStart(Shape shape) throws Exception
    {
        if (isHidden(shape)) shape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Comment is encountered in the document.
     */
    public int visitCommentStart(Comment comment) throws Exception
    {
        if (isHidden(comment)) comment.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Footnote is encountered in the document.
     */
    public int visitFootnoteStart(Footnote footnote) throws Exception
    {
        if (isHidden(footnote)) footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Table node is ended in the document.
     */
    public int visitTableEnd(Table table)
    {
        // At the moment there is no way to tell if a particular Table/Row/Cell is hidden.
        // Instead, if the content of a table is hidden, then all inline child nodes of the table should be
        // hidden and thus removed by previous visits as well. This will result in the container being empty
        // so if this is the case we know to remove the table node.
        //
        // Note that a table which is not hidden but simply has no content will not be affected by this algorthim,
        // as technically they are not completely empty (for example a properly formed Cell will have at least
        // an empty paragraph in it)
        if (!table.hasChildNodes()) table.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Cell node is ended in the document.
     */
    public int visitCellEnd(Cell cell)
    {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null) cell.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Row node is ended in the document.
     */
    public int visitRowEnd(Row row)
    {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null) row.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a SpecialCharacter is encountered in the document.
     */
    public int visitSpecialChar(SpecialChar character) throws Exception
    {
        if (isHidden(character)) character.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Returns true if the node passed is set as hidden, returns false if it is visible.
     */
    private boolean isHidden(Node node)
    {
        if (node instanceof Inline)
        {
            // If the node is Inline then cast it to retrieve the Font property which contains the hidden property
            Inline currentNode = (Inline) node;
            return currentNode.getFont().getHidden();
        } else if (node.getNodeType() == NodeType.PARAGRAPH)
        {
            // If the node is a paragraph cast it to retrieve the ParagraphBreakFont which contains the hidden property
            Paragraph para = (Paragraph) node;
            return para.getParagraphBreakFont().getHidden();
        } else if (node instanceof ShapeBase)
        {
            // Node is a shape or groupshape.
            ShapeBase shape = (ShapeBase) node;
            return shape.getFont().getHidden();
        } else if (node instanceof InlineStory)
        {
            // Node is a comment or footnote.
            InlineStory inlineStory = (InlineStory) node;
            return inlineStory.getFont().getHidden();
        }

        // A node that is passed to this method which does not contain a hidden property will end up here.
        // By default nodes are not hidden so return false.
        return false;
    }
}</pre></example>
</DL>
<HR>

<A NAME="visitFormField(com.aspose.words.FormField)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitFormField</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitFormField</B>(<A HREF="FormField.html" title="class in com.aspose.words">FormField</A>&nbsp;formField)
                  throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a form field is encountered in the document.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="formField"><CODE>formField</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Implements the Visitor Pattern to remove all content formatted as hidden from the document.<pre>
public void removeHiddenContentFromDocument() throws Exception
{
    // Open the document we want to remove hidden content from.
    Document doc = new Document(getMyDir() + "Font.Hidden.doc");

    // Create an object that inherits from the DocumentVisitor class.
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).

    // We can run it over the entire the document like so:
    doc.accept(hiddenContentRemover);

    // Or we can run it on only a specific node.
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // Or over a different type of node like below.
    Table table = (Table) doc.getChild(NodeType.TABLE, 0, true);
    table.accept(hiddenContentRemover);

    doc.save(getMyDir() + "\\Artifacts\\Font.Hidden.doc");

}

/**
 * This class when executed will remove all hidden content from the Document. Implemented as a Visitor.
 */
private class RemoveHiddenContentVisitor extends DocumentVisitor
{
    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart) throws Exception
    {
        // If this node is hidden, then remove it.
        if (isHidden(fieldStart)) fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd) throws Exception
    {
        if (isHidden(fieldEnd)) fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator) throws Exception
    {
        if (isHidden(fieldSeparator)) fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        if (isHidden(run)) run.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Paragraph node is encountered in the document.
     */
    public int visitParagraphStart(Paragraph paragraph) throws Exception
    {
        if (isHidden(paragraph)) paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FormField is encountered in the document.
     */
    public int visitFormField(FormField field) throws Exception
    {
        if (isHidden(field)) field.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a GroupShape is encountered in the document.
     */
    public int visitGroupShapeStart(GroupShape groupShape) throws Exception
    {
        if (isHidden(groupShape)) groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Shape is encountered in the document.
     */
    public int visitShapeStart(Shape shape) throws Exception
    {
        if (isHidden(shape)) shape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Comment is encountered in the document.
     */
    public int visitCommentStart(Comment comment) throws Exception
    {
        if (isHidden(comment)) comment.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Footnote is encountered in the document.
     */
    public int visitFootnoteStart(Footnote footnote) throws Exception
    {
        if (isHidden(footnote)) footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Table node is ended in the document.
     */
    public int visitTableEnd(Table table)
    {
        // At the moment there is no way to tell if a particular Table/Row/Cell is hidden.
        // Instead, if the content of a table is hidden, then all inline child nodes of the table should be
        // hidden and thus removed by previous visits as well. This will result in the container being empty
        // so if this is the case we know to remove the table node.
        //
        // Note that a table which is not hidden but simply has no content will not be affected by this algorthim,
        // as technically they are not completely empty (for example a properly formed Cell will have at least
        // an empty paragraph in it)
        if (!table.hasChildNodes()) table.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Cell node is ended in the document.
     */
    public int visitCellEnd(Cell cell)
    {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null) cell.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Row node is ended in the document.
     */
    public int visitRowEnd(Row row)
    {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null) row.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a SpecialCharacter is encountered in the document.
     */
    public int visitSpecialChar(SpecialChar character) throws Exception
    {
        if (isHidden(character)) character.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Returns true if the node passed is set as hidden, returns false if it is visible.
     */
    private boolean isHidden(Node node)
    {
        if (node instanceof Inline)
        {
            // If the node is Inline then cast it to retrieve the Font property which contains the hidden property
            Inline currentNode = (Inline) node;
            return currentNode.getFont().getHidden();
        } else if (node.getNodeType() == NodeType.PARAGRAPH)
        {
            // If the node is a paragraph cast it to retrieve the ParagraphBreakFont which contains the hidden property
            Paragraph para = (Paragraph) node;
            return para.getParagraphBreakFont().getHidden();
        } else if (node instanceof ShapeBase)
        {
            // Node is a shape or groupshape.
            ShapeBase shape = (ShapeBase) node;
            return shape.getFont().getHidden();
        } else if (node instanceof InlineStory)
        {
            // Node is a comment or footnote.
            InlineStory inlineStory = (InlineStory) node;
            return inlineStory.getFont().getHidden();
        }

        // A node that is passed to this method which does not contain a hidden property will end up here.
        // By default nodes are not hidden so return false.
        return false;
    }
}</pre></example>
</DL>
<HR>

<A NAME="visitGlossaryDocumentEnd(com.aspose.words.GlossaryDocument)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitGlossaryDocumentEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitGlossaryDocumentEnd</B>(<A HREF="GlossaryDocument.html" title="class in com.aspose.words">GlossaryDocument</A>&nbsp;glossary)
                            throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a glossary document has ended.
            </summary><remarks><p>
Note: A glossary document node and its children are not visited when you execute a
Visitor over a <cref><A HREF="Document.html" title="class in com.aspose.words">Document</A></cref>. If you want to execute a Visitor over a
glossary document, you need to call <cref><A HREF="GlossaryDocument.html#accept(com.aspose.words.DocumentVisitor)" title="method in class com.aspose.words.GlossaryDocument">GlossaryDocument.accept(com.aspose.words.DocumentVisitor)</A></cref>.
</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="glossary"><CODE>glossary</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitGlossaryDocumentStart(com.aspose.words.GlossaryDocument)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitGlossaryDocumentStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitGlossaryDocumentStart</B>(<A HREF="GlossaryDocument.html" title="class in com.aspose.words">GlossaryDocument</A>&nbsp;glossary)
                              throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a glossary document has started.
            </summary><remarks><p>
Note: A glossary document node and its children are not visited when you execute a
Visitor over a <cref><A HREF="Document.html" title="class in com.aspose.words">Document</A></cref>. If you want to execute a Visitor over a
glossary document, you need to call <cref><A HREF="GlossaryDocument.html#accept(com.aspose.words.DocumentVisitor)" title="method in class com.aspose.words.GlossaryDocument">GlossaryDocument.accept(com.aspose.words.DocumentVisitor)</A></cref>.
</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="glossary"><CODE>glossary</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitGroupShapeEnd(com.aspose.words.GroupShape)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitGroupShapeEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitGroupShapeEnd</B>(<A HREF="GroupShape.html" title="class in com.aspose.words">GroupShape</A>&nbsp;groupShape)
                      throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a group shape has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="groupShape"><CODE>groupShape</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitGroupShapeStart(com.aspose.words.GroupShape)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitGroupShapeStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitGroupShapeStart</B>(<A HREF="GroupShape.html" title="class in com.aspose.words">GroupShape</A>&nbsp;groupShape)
                        throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a group shape has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="groupShape"><CODE>groupShape</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Implements the Visitor Pattern to remove all content formatted as hidden from the document.<pre>
public void removeHiddenContentFromDocument() throws Exception
{
    // Open the document we want to remove hidden content from.
    Document doc = new Document(getMyDir() + "Font.Hidden.doc");

    // Create an object that inherits from the DocumentVisitor class.
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).

    // We can run it over the entire the document like so:
    doc.accept(hiddenContentRemover);

    // Or we can run it on only a specific node.
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // Or over a different type of node like below.
    Table table = (Table) doc.getChild(NodeType.TABLE, 0, true);
    table.accept(hiddenContentRemover);

    doc.save(getMyDir() + "\\Artifacts\\Font.Hidden.doc");

}

/**
 * This class when executed will remove all hidden content from the Document. Implemented as a Visitor.
 */
private class RemoveHiddenContentVisitor extends DocumentVisitor
{
    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart) throws Exception
    {
        // If this node is hidden, then remove it.
        if (isHidden(fieldStart)) fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd) throws Exception
    {
        if (isHidden(fieldEnd)) fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator) throws Exception
    {
        if (isHidden(fieldSeparator)) fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        if (isHidden(run)) run.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Paragraph node is encountered in the document.
     */
    public int visitParagraphStart(Paragraph paragraph) throws Exception
    {
        if (isHidden(paragraph)) paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FormField is encountered in the document.
     */
    public int visitFormField(FormField field) throws Exception
    {
        if (isHidden(field)) field.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a GroupShape is encountered in the document.
     */
    public int visitGroupShapeStart(GroupShape groupShape) throws Exception
    {
        if (isHidden(groupShape)) groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Shape is encountered in the document.
     */
    public int visitShapeStart(Shape shape) throws Exception
    {
        if (isHidden(shape)) shape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Comment is encountered in the document.
     */
    public int visitCommentStart(Comment comment) throws Exception
    {
        if (isHidden(comment)) comment.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Footnote is encountered in the document.
     */
    public int visitFootnoteStart(Footnote footnote) throws Exception
    {
        if (isHidden(footnote)) footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Table node is ended in the document.
     */
    public int visitTableEnd(Table table)
    {
        // At the moment there is no way to tell if a particular Table/Row/Cell is hidden.
        // Instead, if the content of a table is hidden, then all inline child nodes of the table should be
        // hidden and thus removed by previous visits as well. This will result in the container being empty
        // so if this is the case we know to remove the table node.
        //
        // Note that a table which is not hidden but simply has no content will not be affected by this algorthim,
        // as technically they are not completely empty (for example a properly formed Cell will have at least
        // an empty paragraph in it)
        if (!table.hasChildNodes()) table.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Cell node is ended in the document.
     */
    public int visitCellEnd(Cell cell)
    {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null) cell.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Row node is ended in the document.
     */
    public int visitRowEnd(Row row)
    {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null) row.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a SpecialCharacter is encountered in the document.
     */
    public int visitSpecialChar(SpecialChar character) throws Exception
    {
        if (isHidden(character)) character.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Returns true if the node passed is set as hidden, returns false if it is visible.
     */
    private boolean isHidden(Node node)
    {
        if (node instanceof Inline)
        {
            // If the node is Inline then cast it to retrieve the Font property which contains the hidden property
            Inline currentNode = (Inline) node;
            return currentNode.getFont().getHidden();
        } else if (node.getNodeType() == NodeType.PARAGRAPH)
        {
            // If the node is a paragraph cast it to retrieve the ParagraphBreakFont which contains the hidden property
            Paragraph para = (Paragraph) node;
            return para.getParagraphBreakFont().getHidden();
        } else if (node instanceof ShapeBase)
        {
            // Node is a shape or groupshape.
            ShapeBase shape = (ShapeBase) node;
            return shape.getFont().getHidden();
        } else if (node instanceof InlineStory)
        {
            // Node is a comment or footnote.
            InlineStory inlineStory = (InlineStory) node;
            return inlineStory.getFont().getHidden();
        }

        // A node that is passed to this method which does not contain a hidden property will end up here.
        // By default nodes are not hidden so return false.
        return false;
    }
}</pre></example>
</DL>
<HR>

<A NAME="visitHeaderFooterEnd(com.aspose.words.HeaderFooter)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitHeaderFooterEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitHeaderFooterEnd</B>(<A HREF="HeaderFooter.html" title="class in com.aspose.words">HeaderFooter</A>&nbsp;headerFooter)
                        throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a header or footer in a section has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="headerFooter"><CODE>headerFooter</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitHeaderFooterStart(com.aspose.words.HeaderFooter)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitHeaderFooterStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitHeaderFooterStart</B>(<A HREF="HeaderFooter.html" title="class in com.aspose.words">HeaderFooter</A>&nbsp;headerFooter)
                          throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a header or footer in a section has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="headerFooter"><CODE>headerFooter</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use the Visitor pattern to add new operations to the Aspose.Words object model. In this case we create a simple document converter into a text format.<pre>
public void toText() throws Exception
{
    // Open the document we want to convert.
    Document doc = new Document(getMyDir() + "Visitor.ToText.doc");

    // Create an object that inherits from the DocumentVisitor class.
    MyDocToTxtWriter myConverter = new MyDocToTxtWriter();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).
    //
    // Note that every node in the object model has the Accept method so the visiting
    // can be executed not only for the whole document, but for any node in the document.
    doc.accept(myConverter);

    // Once the visiting is complete, we can retrieve the result of the operation,
    // that in this example, has accumulated in the visitor.
    System.out.println(myConverter.getText());
}

/**
 * Simple implementation of saving a document in the plain text format. Implemented as a Visitor.
 */
public class MyDocToTxtWriter extends DocumentVisitor
{
    public MyDocToTxtWriter()
    {
        mIsSkipText = false;
        mBuilder = new StringBuilder();
    }

    /**
     * Gets the plain text of the document that was accumulated by the visitor.
     */
    public String getText()
    {
        return mBuilder.toString();
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        appendText(run.getText());

        // Let the visitor continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart)
    {
        // In Microsoft Word, a field code (such as "MERGEFIELD FieldName") follows
        // after a field start character. We want to skip field codes and output field
        // result only, therefore we use a flag to suspend the output while inside a field code.
        //
        // Note this is a very simplistic implementation and will not work very well
        // if you have nested fields in a document.
        mIsSkipText = true;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator)
    {
        // Once reached a field separator node, we enable the output because we are
        // now entering the field result nodes.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd)
    {
        // Make sure we enable the output when reached a field end because some fields
        // do not have field separator and do not have field result.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Paragraph node is ended in the document.
     */
    public int visitParagraphEnd(Paragraph paragraph) throws Exception
    {
        // When outputting to plain text we output Cr+Lf characters.
        appendText(ControlChar.CR_LF);

        return VisitorAction.CONTINUE;
    }

    public int visitBodyStart(Body body)
    {
        // We can detect beginning and end of all composite nodes such as Section, Body,
        // Table, Paragraph etc and provide custom handling for them.
        mBuilder.append("*** Body Started ***\r\n");

        return VisitorAction.CONTINUE;
    }

    public int visitBodyEnd(Body body)
    {
        mBuilder.append("*** Body Ended ***\r\n");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a HeaderFooter node is encountered in the document.
     */
    public int visitHeaderFooterStart(HeaderFooter headerFooter)
    {
        // Returning this value from a visitor method causes visiting of this
        // node to stop and move on to visiting the next sibling node.
        // The net effect in this example is that the text of headers and footers
        // is not included in the resulting output.
        return VisitorAction.SKIP_THIS_NODE;
    }

    /**
     * Called when an AbsolutePositionTab is encountered in the document.
     */
    public int visitAbsolutePositionTab(AbsolutePositionTab tab)
    {
        mBuilder.append("\t");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkStart is encountered in the document.
     */
    public int visitBookmarkStart(BookmarkStart bookmarkStart)
    {
        mBuilder.append("[");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkEnd is encountered in the document.
     */
    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd)
    {
        mBuilder.append("]");
        return VisitorAction.CONTINUE;
    }

    /**
     * Adds text to the current output. Honours the enabled/disabled output flag.
     */
    private void appendText(String text)
    {
        if (!mIsSkipText) mBuilder.append(text);
    }

    private final StringBuilder mBuilder;
    private boolean mIsSkipText;
}</pre></example>
</DL>
<HR>

<A NAME="visitOfficeMathEnd(com.aspose.words.OfficeMath)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitOfficeMathEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitOfficeMathEnd</B>(<A HREF="OfficeMath.html" title="class in com.aspose.words">OfficeMath</A>&nbsp;officeMath)
                      throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a Office Math object has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="officeMath"><CODE>officeMath</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitOfficeMathStart(com.aspose.words.OfficeMath)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitOfficeMathStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitOfficeMathStart</B>(<A HREF="OfficeMath.html" title="class in com.aspose.words">OfficeMath</A>&nbsp;officeMath)
                        throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a Office Math object has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="officeMath"><CODE>officeMath</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitParagraphEnd(com.aspose.words.Paragraph)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitParagraphEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitParagraphEnd</B>(<A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A>&nbsp;paragraph)
                     throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a paragraph has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="paragraph"><CODE>paragraph</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use the Visitor pattern to add new operations to the Aspose.Words object model. In this case we create a simple document converter into a text format.<pre>
public void toText() throws Exception
{
    // Open the document we want to convert.
    Document doc = new Document(getMyDir() + "Visitor.ToText.doc");

    // Create an object that inherits from the DocumentVisitor class.
    MyDocToTxtWriter myConverter = new MyDocToTxtWriter();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).
    //
    // Note that every node in the object model has the Accept method so the visiting
    // can be executed not only for the whole document, but for any node in the document.
    doc.accept(myConverter);

    // Once the visiting is complete, we can retrieve the result of the operation,
    // that in this example, has accumulated in the visitor.
    System.out.println(myConverter.getText());
}

/**
 * Simple implementation of saving a document in the plain text format. Implemented as a Visitor.
 */
public class MyDocToTxtWriter extends DocumentVisitor
{
    public MyDocToTxtWriter()
    {
        mIsSkipText = false;
        mBuilder = new StringBuilder();
    }

    /**
     * Gets the plain text of the document that was accumulated by the visitor.
     */
    public String getText()
    {
        return mBuilder.toString();
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        appendText(run.getText());

        // Let the visitor continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart)
    {
        // In Microsoft Word, a field code (such as "MERGEFIELD FieldName") follows
        // after a field start character. We want to skip field codes and output field
        // result only, therefore we use a flag to suspend the output while inside a field code.
        //
        // Note this is a very simplistic implementation and will not work very well
        // if you have nested fields in a document.
        mIsSkipText = true;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator)
    {
        // Once reached a field separator node, we enable the output because we are
        // now entering the field result nodes.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd)
    {
        // Make sure we enable the output when reached a field end because some fields
        // do not have field separator and do not have field result.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Paragraph node is ended in the document.
     */
    public int visitParagraphEnd(Paragraph paragraph) throws Exception
    {
        // When outputting to plain text we output Cr+Lf characters.
        appendText(ControlChar.CR_LF);

        return VisitorAction.CONTINUE;
    }

    public int visitBodyStart(Body body)
    {
        // We can detect beginning and end of all composite nodes such as Section, Body,
        // Table, Paragraph etc and provide custom handling for them.
        mBuilder.append("*** Body Started ***\r\n");

        return VisitorAction.CONTINUE;
    }

    public int visitBodyEnd(Body body)
    {
        mBuilder.append("*** Body Ended ***\r\n");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a HeaderFooter node is encountered in the document.
     */
    public int visitHeaderFooterStart(HeaderFooter headerFooter)
    {
        // Returning this value from a visitor method causes visiting of this
        // node to stop and move on to visiting the next sibling node.
        // The net effect in this example is that the text of headers and footers
        // is not included in the resulting output.
        return VisitorAction.SKIP_THIS_NODE;
    }

    /**
     * Called when an AbsolutePositionTab is encountered in the document.
     */
    public int visitAbsolutePositionTab(AbsolutePositionTab tab)
    {
        mBuilder.append("\t");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkStart is encountered in the document.
     */
    public int visitBookmarkStart(BookmarkStart bookmarkStart)
    {
        mBuilder.append("[");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkEnd is encountered in the document.
     */
    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd)
    {
        mBuilder.append("]");
        return VisitorAction.CONTINUE;
    }

    /**
     * Adds text to the current output. Honours the enabled/disabled output flag.
     */
    private void appendText(String text)
    {
        if (!mIsSkipText) mBuilder.append(text);
    }

    private final StringBuilder mBuilder;
    private boolean mIsSkipText;
}</pre></example>
</DL>
<HR>

<A NAME="visitParagraphStart(com.aspose.words.Paragraph)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitParagraphStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitParagraphStart</B>(<A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A>&nbsp;paragraph)
                       throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a paragraph has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="paragraph"><CODE>paragraph</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Implements the Visitor Pattern to remove all content formatted as hidden from the document.<pre>
public void removeHiddenContentFromDocument() throws Exception
{
    // Open the document we want to remove hidden content from.
    Document doc = new Document(getMyDir() + "Font.Hidden.doc");

    // Create an object that inherits from the DocumentVisitor class.
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).

    // We can run it over the entire the document like so:
    doc.accept(hiddenContentRemover);

    // Or we can run it on only a specific node.
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // Or over a different type of node like below.
    Table table = (Table) doc.getChild(NodeType.TABLE, 0, true);
    table.accept(hiddenContentRemover);

    doc.save(getMyDir() + "\\Artifacts\\Font.Hidden.doc");

}

/**
 * This class when executed will remove all hidden content from the Document. Implemented as a Visitor.
 */
private class RemoveHiddenContentVisitor extends DocumentVisitor
{
    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart) throws Exception
    {
        // If this node is hidden, then remove it.
        if (isHidden(fieldStart)) fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd) throws Exception
    {
        if (isHidden(fieldEnd)) fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator) throws Exception
    {
        if (isHidden(fieldSeparator)) fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        if (isHidden(run)) run.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Paragraph node is encountered in the document.
     */
    public int visitParagraphStart(Paragraph paragraph) throws Exception
    {
        if (isHidden(paragraph)) paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FormField is encountered in the document.
     */
    public int visitFormField(FormField field) throws Exception
    {
        if (isHidden(field)) field.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a GroupShape is encountered in the document.
     */
    public int visitGroupShapeStart(GroupShape groupShape) throws Exception
    {
        if (isHidden(groupShape)) groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Shape is encountered in the document.
     */
    public int visitShapeStart(Shape shape) throws Exception
    {
        if (isHidden(shape)) shape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Comment is encountered in the document.
     */
    public int visitCommentStart(Comment comment) throws Exception
    {
        if (isHidden(comment)) comment.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Footnote is encountered in the document.
     */
    public int visitFootnoteStart(Footnote footnote) throws Exception
    {
        if (isHidden(footnote)) footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Table node is ended in the document.
     */
    public int visitTableEnd(Table table)
    {
        // At the moment there is no way to tell if a particular Table/Row/Cell is hidden.
        // Instead, if the content of a table is hidden, then all inline child nodes of the table should be
        // hidden and thus removed by previous visits as well. This will result in the container being empty
        // so if this is the case we know to remove the table node.
        //
        // Note that a table which is not hidden but simply has no content will not be affected by this algorthim,
        // as technically they are not completely empty (for example a properly formed Cell will have at least
        // an empty paragraph in it)
        if (!table.hasChildNodes()) table.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Cell node is ended in the document.
     */
    public int visitCellEnd(Cell cell)
    {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null) cell.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Row node is ended in the document.
     */
    public int visitRowEnd(Row row)
    {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null) row.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a SpecialCharacter is encountered in the document.
     */
    public int visitSpecialChar(SpecialChar character) throws Exception
    {
        if (isHidden(character)) character.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Returns true if the node passed is set as hidden, returns false if it is visible.
     */
    private boolean isHidden(Node node)
    {
        if (node instanceof Inline)
        {
            // If the node is Inline then cast it to retrieve the Font property which contains the hidden property
            Inline currentNode = (Inline) node;
            return currentNode.getFont().getHidden();
        } else if (node.getNodeType() == NodeType.PARAGRAPH)
        {
            // If the node is a paragraph cast it to retrieve the ParagraphBreakFont which contains the hidden property
            Paragraph para = (Paragraph) node;
            return para.getParagraphBreakFont().getHidden();
        } else if (node instanceof ShapeBase)
        {
            // Node is a shape or groupshape.
            ShapeBase shape = (ShapeBase) node;
            return shape.getFont().getHidden();
        } else if (node instanceof InlineStory)
        {
            // Node is a comment or footnote.
            InlineStory inlineStory = (InlineStory) node;
            return inlineStory.getFont().getHidden();
        }

        // A node that is passed to this method which does not contain a hidden property will end up here.
        // By default nodes are not hidden so return false.
        return false;
    }
}</pre></example>
</DL>
<HR>

<A NAME="visitRowEnd(com.aspose.words.Row)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitRowEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitRowEnd</B>(<A HREF="Row.html" title="class in com.aspose.words">Row</A>&nbsp;row)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a table row has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="row"><CODE>row</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Implements the Visitor Pattern to remove all content formatted as hidden from the document.<pre>
public void removeHiddenContentFromDocument() throws Exception
{
    // Open the document we want to remove hidden content from.
    Document doc = new Document(getMyDir() + "Font.Hidden.doc");

    // Create an object that inherits from the DocumentVisitor class.
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).

    // We can run it over the entire the document like so:
    doc.accept(hiddenContentRemover);

    // Or we can run it on only a specific node.
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // Or over a different type of node like below.
    Table table = (Table) doc.getChild(NodeType.TABLE, 0, true);
    table.accept(hiddenContentRemover);

    doc.save(getMyDir() + "\\Artifacts\\Font.Hidden.doc");

}

/**
 * This class when executed will remove all hidden content from the Document. Implemented as a Visitor.
 */
private class RemoveHiddenContentVisitor extends DocumentVisitor
{
    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart) throws Exception
    {
        // If this node is hidden, then remove it.
        if (isHidden(fieldStart)) fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd) throws Exception
    {
        if (isHidden(fieldEnd)) fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator) throws Exception
    {
        if (isHidden(fieldSeparator)) fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        if (isHidden(run)) run.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Paragraph node is encountered in the document.
     */
    public int visitParagraphStart(Paragraph paragraph) throws Exception
    {
        if (isHidden(paragraph)) paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FormField is encountered in the document.
     */
    public int visitFormField(FormField field) throws Exception
    {
        if (isHidden(field)) field.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a GroupShape is encountered in the document.
     */
    public int visitGroupShapeStart(GroupShape groupShape) throws Exception
    {
        if (isHidden(groupShape)) groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Shape is encountered in the document.
     */
    public int visitShapeStart(Shape shape) throws Exception
    {
        if (isHidden(shape)) shape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Comment is encountered in the document.
     */
    public int visitCommentStart(Comment comment) throws Exception
    {
        if (isHidden(comment)) comment.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Footnote is encountered in the document.
     */
    public int visitFootnoteStart(Footnote footnote) throws Exception
    {
        if (isHidden(footnote)) footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Table node is ended in the document.
     */
    public int visitTableEnd(Table table)
    {
        // At the moment there is no way to tell if a particular Table/Row/Cell is hidden.
        // Instead, if the content of a table is hidden, then all inline child nodes of the table should be
        // hidden and thus removed by previous visits as well. This will result in the container being empty
        // so if this is the case we know to remove the table node.
        //
        // Note that a table which is not hidden but simply has no content will not be affected by this algorthim,
        // as technically they are not completely empty (for example a properly formed Cell will have at least
        // an empty paragraph in it)
        if (!table.hasChildNodes()) table.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Cell node is ended in the document.
     */
    public int visitCellEnd(Cell cell)
    {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null) cell.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Row node is ended in the document.
     */
    public int visitRowEnd(Row row)
    {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null) row.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a SpecialCharacter is encountered in the document.
     */
    public int visitSpecialChar(SpecialChar character) throws Exception
    {
        if (isHidden(character)) character.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Returns true if the node passed is set as hidden, returns false if it is visible.
     */
    private boolean isHidden(Node node)
    {
        if (node instanceof Inline)
        {
            // If the node is Inline then cast it to retrieve the Font property which contains the hidden property
            Inline currentNode = (Inline) node;
            return currentNode.getFont().getHidden();
        } else if (node.getNodeType() == NodeType.PARAGRAPH)
        {
            // If the node is a paragraph cast it to retrieve the ParagraphBreakFont which contains the hidden property
            Paragraph para = (Paragraph) node;
            return para.getParagraphBreakFont().getHidden();
        } else if (node instanceof ShapeBase)
        {
            // Node is a shape or groupshape.
            ShapeBase shape = (ShapeBase) node;
            return shape.getFont().getHidden();
        } else if (node instanceof InlineStory)
        {
            // Node is a comment or footnote.
            InlineStory inlineStory = (InlineStory) node;
            return inlineStory.getFont().getHidden();
        }

        // A node that is passed to this method which does not contain a hidden property will end up here.
        // By default nodes are not hidden so return false.
        return false;
    }
}</pre></example>
</DL>
<HR>

<A NAME="visitRowStart(com.aspose.words.Row)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitRowStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitRowStart</B>(<A HREF="Row.html" title="class in com.aspose.words">Row</A>&nbsp;row)
                 throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a table row has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="row"><CODE>row</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitRun(com.aspose.words.Run)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitRun</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitRun</B>(<A HREF="Run.html" title="class in com.aspose.words">Run</A>&nbsp;run)
            throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a run of text in the is encountered.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="run"><CODE>run</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use the Visitor pattern to add new operations to the Aspose.Words object model. In this case we create a simple document converter into a text format.<pre>
public void toText() throws Exception
{
    // Open the document we want to convert.
    Document doc = new Document(getMyDir() + "Visitor.ToText.doc");

    // Create an object that inherits from the DocumentVisitor class.
    MyDocToTxtWriter myConverter = new MyDocToTxtWriter();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).
    //
    // Note that every node in the object model has the Accept method so the visiting
    // can be executed not only for the whole document, but for any node in the document.
    doc.accept(myConverter);

    // Once the visiting is complete, we can retrieve the result of the operation,
    // that in this example, has accumulated in the visitor.
    System.out.println(myConverter.getText());
}

/**
 * Simple implementation of saving a document in the plain text format. Implemented as a Visitor.
 */
public class MyDocToTxtWriter extends DocumentVisitor
{
    public MyDocToTxtWriter()
    {
        mIsSkipText = false;
        mBuilder = new StringBuilder();
    }

    /**
     * Gets the plain text of the document that was accumulated by the visitor.
     */
    public String getText()
    {
        return mBuilder.toString();
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        appendText(run.getText());

        // Let the visitor continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart)
    {
        // In Microsoft Word, a field code (such as "MERGEFIELD FieldName") follows
        // after a field start character. We want to skip field codes and output field
        // result only, therefore we use a flag to suspend the output while inside a field code.
        //
        // Note this is a very simplistic implementation and will not work very well
        // if you have nested fields in a document.
        mIsSkipText = true;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator)
    {
        // Once reached a field separator node, we enable the output because we are
        // now entering the field result nodes.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd)
    {
        // Make sure we enable the output when reached a field end because some fields
        // do not have field separator and do not have field result.
        mIsSkipText = false;

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Paragraph node is ended in the document.
     */
    public int visitParagraphEnd(Paragraph paragraph) throws Exception
    {
        // When outputting to plain text we output Cr+Lf characters.
        appendText(ControlChar.CR_LF);

        return VisitorAction.CONTINUE;
    }

    public int visitBodyStart(Body body)
    {
        // We can detect beginning and end of all composite nodes such as Section, Body,
        // Table, Paragraph etc and provide custom handling for them.
        mBuilder.append("*** Body Started ***\r\n");

        return VisitorAction.CONTINUE;
    }

    public int visitBodyEnd(Body body)
    {
        mBuilder.append("*** Body Ended ***\r\n");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a HeaderFooter node is encountered in the document.
     */
    public int visitHeaderFooterStart(HeaderFooter headerFooter)
    {
        // Returning this value from a visitor method causes visiting of this
        // node to stop and move on to visiting the next sibling node.
        // The net effect in this example is that the text of headers and footers
        // is not included in the resulting output.
        return VisitorAction.SKIP_THIS_NODE;
    }

    /**
     * Called when an AbsolutePositionTab is encountered in the document.
     */
    public int visitAbsolutePositionTab(AbsolutePositionTab tab)
    {
        mBuilder.append("\t");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkStart is encountered in the document.
     */
    public int visitBookmarkStart(BookmarkStart bookmarkStart)
    {
        mBuilder.append("[");
        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a BookmarkEnd is encountered in the document.
     */
    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd)
    {
        mBuilder.append("]");
        return VisitorAction.CONTINUE;
    }

    /**
     * Adds text to the current output. Honours the enabled/disabled output flag.
     */
    private void appendText(String text)
    {
        if (!mIsSkipText) mBuilder.append(text);
    }

    private final StringBuilder mBuilder;
    private boolean mIsSkipText;
}</pre></example>
</DL>
<HR>

<A NAME="visitSectionEnd(com.aspose.words.Section)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitSectionEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitSectionEnd</B>(<A HREF="Section.html" title="class in com.aspose.words">Section</A>&nbsp;section)
                   throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a section has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="section"><CODE>section</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitSectionStart(com.aspose.words.Section)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitSectionStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitSectionStart</B>(<A HREF="Section.html" title="class in com.aspose.words">Section</A>&nbsp;section)
                     throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a section has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="section"><CODE>section</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitShapeEnd(com.aspose.words.Shape)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitShapeEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitShapeEnd</B>(<A HREF="Shape.html" title="class in com.aspose.words">Shape</A>&nbsp;shape)
                 throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a shape has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="shape"><CODE>shape</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitShapeStart(com.aspose.words.Shape)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitShapeStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitShapeStart</B>(<A HREF="Shape.html" title="class in com.aspose.words">Shape</A>&nbsp;shape)
                   throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a shape has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="shape"><CODE>shape</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Implements the Visitor Pattern to remove all content formatted as hidden from the document.<pre>
public void removeHiddenContentFromDocument() throws Exception
{
    // Open the document we want to remove hidden content from.
    Document doc = new Document(getMyDir() + "Font.Hidden.doc");

    // Create an object that inherits from the DocumentVisitor class.
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).

    // We can run it over the entire the document like so:
    doc.accept(hiddenContentRemover);

    // Or we can run it on only a specific node.
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // Or over a different type of node like below.
    Table table = (Table) doc.getChild(NodeType.TABLE, 0, true);
    table.accept(hiddenContentRemover);

    doc.save(getMyDir() + "\\Artifacts\\Font.Hidden.doc");

}

/**
 * This class when executed will remove all hidden content from the Document. Implemented as a Visitor.
 */
private class RemoveHiddenContentVisitor extends DocumentVisitor
{
    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart) throws Exception
    {
        // If this node is hidden, then remove it.
        if (isHidden(fieldStart)) fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd) throws Exception
    {
        if (isHidden(fieldEnd)) fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator) throws Exception
    {
        if (isHidden(fieldSeparator)) fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        if (isHidden(run)) run.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Paragraph node is encountered in the document.
     */
    public int visitParagraphStart(Paragraph paragraph) throws Exception
    {
        if (isHidden(paragraph)) paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FormField is encountered in the document.
     */
    public int visitFormField(FormField field) throws Exception
    {
        if (isHidden(field)) field.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a GroupShape is encountered in the document.
     */
    public int visitGroupShapeStart(GroupShape groupShape) throws Exception
    {
        if (isHidden(groupShape)) groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Shape is encountered in the document.
     */
    public int visitShapeStart(Shape shape) throws Exception
    {
        if (isHidden(shape)) shape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Comment is encountered in the document.
     */
    public int visitCommentStart(Comment comment) throws Exception
    {
        if (isHidden(comment)) comment.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Footnote is encountered in the document.
     */
    public int visitFootnoteStart(Footnote footnote) throws Exception
    {
        if (isHidden(footnote)) footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Table node is ended in the document.
     */
    public int visitTableEnd(Table table)
    {
        // At the moment there is no way to tell if a particular Table/Row/Cell is hidden.
        // Instead, if the content of a table is hidden, then all inline child nodes of the table should be
        // hidden and thus removed by previous visits as well. This will result in the container being empty
        // so if this is the case we know to remove the table node.
        //
        // Note that a table which is not hidden but simply has no content will not be affected by this algorthim,
        // as technically they are not completely empty (for example a properly formed Cell will have at least
        // an empty paragraph in it)
        if (!table.hasChildNodes()) table.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Cell node is ended in the document.
     */
    public int visitCellEnd(Cell cell)
    {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null) cell.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Row node is ended in the document.
     */
    public int visitRowEnd(Row row)
    {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null) row.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a SpecialCharacter is encountered in the document.
     */
    public int visitSpecialChar(SpecialChar character) throws Exception
    {
        if (isHidden(character)) character.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Returns true if the node passed is set as hidden, returns false if it is visible.
     */
    private boolean isHidden(Node node)
    {
        if (node instanceof Inline)
        {
            // If the node is Inline then cast it to retrieve the Font property which contains the hidden property
            Inline currentNode = (Inline) node;
            return currentNode.getFont().getHidden();
        } else if (node.getNodeType() == NodeType.PARAGRAPH)
        {
            // If the node is a paragraph cast it to retrieve the ParagraphBreakFont which contains the hidden property
            Paragraph para = (Paragraph) node;
            return para.getParagraphBreakFont().getHidden();
        } else if (node instanceof ShapeBase)
        {
            // Node is a shape or groupshape.
            ShapeBase shape = (ShapeBase) node;
            return shape.getFont().getHidden();
        } else if (node instanceof InlineStory)
        {
            // Node is a comment or footnote.
            InlineStory inlineStory = (InlineStory) node;
            return inlineStory.getFont().getHidden();
        }

        // A node that is passed to this method which does not contain a hidden property will end up here.
        // By default nodes are not hidden so return false.
        return false;
    }
}</pre></example>
</DL>
<HR>

<A NAME="visitSmartTagEnd(com.aspose.words.SmartTag)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitSmartTagEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitSmartTagEnd</B>(<A HREF="SmartTag.html" title="class in com.aspose.words">SmartTag</A>&nbsp;smartTag)
                    throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a smart tag has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="smartTag"><CODE>smartTag</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitSmartTagStart(com.aspose.words.SmartTag)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitSmartTagStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitSmartTagStart</B>(<A HREF="SmartTag.html" title="class in com.aspose.words">SmartTag</A>&nbsp;smartTag)
                      throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a smart tag has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="smartTag"><CODE>smartTag</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitSpecialChar(com.aspose.words.SpecialChar)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitSpecialChar</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitSpecialChar</B>(<A HREF="SpecialChar.html" title="class in com.aspose.words">SpecialChar</A>&nbsp;specialChar)
                    throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a <cref><A HREF="SpecialChar.html" title="class in com.aspose.words">SpecialChar</A></cref> node is encountered in the document.
            </summary><remarks>
            This method is not be called for generic control characters (see <cref><A HREF="ControlChar.html" title="class in com.aspose.words">ControlChar</A></cref>) that can be present in the document.
            </remarks><DL><DT><B>Parameters:</B></DT><DD param="specialChar"><CODE>specialChar</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Implements the Visitor Pattern to remove all content formatted as hidden from the document.<pre>
public void removeHiddenContentFromDocument() throws Exception
{
    // Open the document we want to remove hidden content from.
    Document doc = new Document(getMyDir() + "Font.Hidden.doc");

    // Create an object that inherits from the DocumentVisitor class.
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).

    // We can run it over the entire the document like so:
    doc.accept(hiddenContentRemover);

    // Or we can run it on only a specific node.
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // Or over a different type of node like below.
    Table table = (Table) doc.getChild(NodeType.TABLE, 0, true);
    table.accept(hiddenContentRemover);

    doc.save(getMyDir() + "\\Artifacts\\Font.Hidden.doc");

}

/**
 * This class when executed will remove all hidden content from the Document. Implemented as a Visitor.
 */
private class RemoveHiddenContentVisitor extends DocumentVisitor
{
    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart) throws Exception
    {
        // If this node is hidden, then remove it.
        if (isHidden(fieldStart)) fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd) throws Exception
    {
        if (isHidden(fieldEnd)) fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator) throws Exception
    {
        if (isHidden(fieldSeparator)) fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        if (isHidden(run)) run.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Paragraph node is encountered in the document.
     */
    public int visitParagraphStart(Paragraph paragraph) throws Exception
    {
        if (isHidden(paragraph)) paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FormField is encountered in the document.
     */
    public int visitFormField(FormField field) throws Exception
    {
        if (isHidden(field)) field.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a GroupShape is encountered in the document.
     */
    public int visitGroupShapeStart(GroupShape groupShape) throws Exception
    {
        if (isHidden(groupShape)) groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Shape is encountered in the document.
     */
    public int visitShapeStart(Shape shape) throws Exception
    {
        if (isHidden(shape)) shape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Comment is encountered in the document.
     */
    public int visitCommentStart(Comment comment) throws Exception
    {
        if (isHidden(comment)) comment.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Footnote is encountered in the document.
     */
    public int visitFootnoteStart(Footnote footnote) throws Exception
    {
        if (isHidden(footnote)) footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Table node is ended in the document.
     */
    public int visitTableEnd(Table table)
    {
        // At the moment there is no way to tell if a particular Table/Row/Cell is hidden.
        // Instead, if the content of a table is hidden, then all inline child nodes of the table should be
        // hidden and thus removed by previous visits as well. This will result in the container being empty
        // so if this is the case we know to remove the table node.
        //
        // Note that a table which is not hidden but simply has no content will not be affected by this algorthim,
        // as technically they are not completely empty (for example a properly formed Cell will have at least
        // an empty paragraph in it)
        if (!table.hasChildNodes()) table.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Cell node is ended in the document.
     */
    public int visitCellEnd(Cell cell)
    {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null) cell.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Row node is ended in the document.
     */
    public int visitRowEnd(Row row)
    {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null) row.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a SpecialCharacter is encountered in the document.
     */
    public int visitSpecialChar(SpecialChar character) throws Exception
    {
        if (isHidden(character)) character.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Returns true if the node passed is set as hidden, returns false if it is visible.
     */
    private boolean isHidden(Node node)
    {
        if (node instanceof Inline)
        {
            // If the node is Inline then cast it to retrieve the Font property which contains the hidden property
            Inline currentNode = (Inline) node;
            return currentNode.getFont().getHidden();
        } else if (node.getNodeType() == NodeType.PARAGRAPH)
        {
            // If the node is a paragraph cast it to retrieve the ParagraphBreakFont which contains the hidden property
            Paragraph para = (Paragraph) node;
            return para.getParagraphBreakFont().getHidden();
        } else if (node instanceof ShapeBase)
        {
            // Node is a shape or groupshape.
            ShapeBase shape = (ShapeBase) node;
            return shape.getFont().getHidden();
        } else if (node instanceof InlineStory)
        {
            // Node is a comment or footnote.
            InlineStory inlineStory = (InlineStory) node;
            return inlineStory.getFont().getHidden();
        }

        // A node that is passed to this method which does not contain a hidden property will end up here.
        // By default nodes are not hidden so return false.
        return false;
    }
}</pre></example>
</DL>
<HR>

<A NAME="visitStructuredDocumentTagEnd(com.aspose.words.StructuredDocumentTag)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitStructuredDocumentTagEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitStructuredDocumentTagEnd</B>(<A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A>&nbsp;sdt)
                                 throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a structured document tag has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="sdt"><CODE>sdt</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitStructuredDocumentTagStart(com.aspose.words.StructuredDocumentTag)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitStructuredDocumentTagStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitStructuredDocumentTagStart</B>(<A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A>&nbsp;sdt)
                                   throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a structured document tag has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="sdt"><CODE>sdt</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitSubDocument(com.aspose.words.SubDocument)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitSubDocument</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitSubDocument</B>(<A HREF="SubDocument.html" title="class in com.aspose.words">SubDocument</A>&nbsp;subDocument)
                    throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a subDocument is encountered.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="subDocument"><CODE>subDocument</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL>
</DL>
<HR>

<A NAME="visitTableEnd(com.aspose.words.Table)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitTableEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitTableEnd</B>(<A HREF="Table.html" title="class in com.aspose.words">Table</A>&nbsp;table)
                 throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a table has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="table"><CODE>table</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Implements the Visitor Pattern to remove all content formatted as hidden from the document.<pre>
public void removeHiddenContentFromDocument() throws Exception
{
    // Open the document we want to remove hidden content from.
    Document doc = new Document(getMyDir() + "Font.Hidden.doc");

    // Create an object that inherits from the DocumentVisitor class.
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).

    // We can run it over the entire the document like so:
    doc.accept(hiddenContentRemover);

    // Or we can run it on only a specific node.
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // Or over a different type of node like below.
    Table table = (Table) doc.getChild(NodeType.TABLE, 0, true);
    table.accept(hiddenContentRemover);

    doc.save(getMyDir() + "\\Artifacts\\Font.Hidden.doc");

}

/**
 * This class when executed will remove all hidden content from the Document. Implemented as a Visitor.
 */
private class RemoveHiddenContentVisitor extends DocumentVisitor
{
    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart) throws Exception
    {
        // If this node is hidden, then remove it.
        if (isHidden(fieldStart)) fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd) throws Exception
    {
        if (isHidden(fieldEnd)) fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator) throws Exception
    {
        if (isHidden(fieldSeparator)) fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        if (isHidden(run)) run.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Paragraph node is encountered in the document.
     */
    public int visitParagraphStart(Paragraph paragraph) throws Exception
    {
        if (isHidden(paragraph)) paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FormField is encountered in the document.
     */
    public int visitFormField(FormField field) throws Exception
    {
        if (isHidden(field)) field.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a GroupShape is encountered in the document.
     */
    public int visitGroupShapeStart(GroupShape groupShape) throws Exception
    {
        if (isHidden(groupShape)) groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Shape is encountered in the document.
     */
    public int visitShapeStart(Shape shape) throws Exception
    {
        if (isHidden(shape)) shape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Comment is encountered in the document.
     */
    public int visitCommentStart(Comment comment) throws Exception
    {
        if (isHidden(comment)) comment.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Footnote is encountered in the document.
     */
    public int visitFootnoteStart(Footnote footnote) throws Exception
    {
        if (isHidden(footnote)) footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Table node is ended in the document.
     */
    public int visitTableEnd(Table table)
    {
        // At the moment there is no way to tell if a particular Table/Row/Cell is hidden.
        // Instead, if the content of a table is hidden, then all inline child nodes of the table should be
        // hidden and thus removed by previous visits as well. This will result in the container being empty
        // so if this is the case we know to remove the table node.
        //
        // Note that a table which is not hidden but simply has no content will not be affected by this algorthim,
        // as technically they are not completely empty (for example a properly formed Cell will have at least
        // an empty paragraph in it)
        if (!table.hasChildNodes()) table.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Cell node is ended in the document.
     */
    public int visitCellEnd(Cell cell)
    {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null) cell.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Row node is ended in the document.
     */
    public int visitRowEnd(Row row)
    {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null) row.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a SpecialCharacter is encountered in the document.
     */
    public int visitSpecialChar(SpecialChar character) throws Exception
    {
        if (isHidden(character)) character.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Returns true if the node passed is set as hidden, returns false if it is visible.
     */
    private boolean isHidden(Node node)
    {
        if (node instanceof Inline)
        {
            // If the node is Inline then cast it to retrieve the Font property which contains the hidden property
            Inline currentNode = (Inline) node;
            return currentNode.getFont().getHidden();
        } else if (node.getNodeType() == NodeType.PARAGRAPH)
        {
            // If the node is a paragraph cast it to retrieve the ParagraphBreakFont which contains the hidden property
            Paragraph para = (Paragraph) node;
            return para.getParagraphBreakFont().getHidden();
        } else if (node instanceof ShapeBase)
        {
            // Node is a shape or groupshape.
            ShapeBase shape = (ShapeBase) node;
            return shape.getFont().getHidden();
        } else if (node instanceof InlineStory)
        {
            // Node is a comment or footnote.
            InlineStory inlineStory = (InlineStory) node;
            return inlineStory.getFont().getHidden();
        }

        // A node that is passed to this method which does not contain a hidden property will end up here.
        // By default nodes are not hidden so return false.
        return false;
    }
}</pre></example>
</DL>
<HR>

<A NAME="visitTableStart(com.aspose.words.Table)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitTableStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitTableStart</B>(<A HREF="Table.html" title="class in com.aspose.words">Table</A>&nbsp;table)
                   throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a table has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="table"><CODE>table</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>This class provides a static method convert fields of a particular type to static text.<pre>
private static class FieldsHelper extends DocumentVisitor
{
    /**
     * Converts any fields of the specified type found in the descendants of the node into static text.
     *
     * @param compositeNode The node in which all descendants of the specified FieldType will be converted to static text.
     * @param targetFieldType The FieldType of the field to convert to static text.
     */
    public static void convertFieldsToStaticText(CompositeNode compositeNode, int targetFieldType) throws Exception
    {
        FieldsHelper helper = new FieldsHelper(targetFieldType);
        compositeNode.accept(helper);

    }

    private FieldsHelper(int targetFieldType)
    {
        mTargetFieldType = targetFieldType;
    }

    public int visitFieldStart(FieldStart fieldStart)
    {
        // We must keep track of the starts and ends of fields incase of any nested fields.
        if (fieldStart.getFieldType() == mTargetFieldType)
        {
            mFieldDepth++;
            fieldStart.remove();
        }
        else
        {
            // This removes the field start if it's inside a field that is being converted.
            CheckDepthAndRemoveNode(fieldStart);
        }

        return VisitorAction.CONTINUE;
    }

    public int visitFieldSeparator(FieldSeparator fieldSeparator)
    {
        // When visiting a field separator we should decrease the depth level.
        if (fieldSeparator.getFieldType() == mTargetFieldType)
        {
            mFieldDepth--;
            fieldSeparator.remove();
        }
        else
        {
            // This removes the field separator if it's inside a field that is being converted.
            CheckDepthAndRemoveNode(fieldSeparator);
        }

        return VisitorAction.CONTINUE;
    }

    public int visitFieldEnd(FieldEnd fieldEnd)
    {
        if (fieldEnd.getFieldType() == mTargetFieldType)
            fieldEnd.remove();
        else
            CheckDepthAndRemoveNode(fieldEnd); // This removes the field end if it's inside a field that is being converted.

        return VisitorAction.CONTINUE;
    }

    public int visitRun(Run run)
    {
        // Remove the run if it is between the FieldStart and FieldSeparator of the field being converted.
        CheckDepthAndRemoveNode(run);

        return VisitorAction.CONTINUE;
    }

    public int visitParagraphEnd(Paragraph paragraph)
    {
        if (mFieldDepth &gt; 0)
        {
            // The field code that is being converted continues onto another paragraph. We
            // need to copy the remaining content from this paragraph onto the next paragraph.
            Node nextParagraph = paragraph.getNextSibling();

            // Skip ahead to the next available paragraph.
            while (nextParagraph != null &amp;&amp; nextParagraph.getNodeType() != NodeType.PARAGRAPH)
                nextParagraph = nextParagraph.getNextSibling();

            // Copy all of the nodes over. Keep a list of these nodes so we know not to remove them.
            while (paragraph.hasChildNodes())
            {
                mNodesToSkip.add(paragraph.getLastChild());
                ((Paragraph)nextParagraph).prependChild(paragraph.getLastChild());
            }

            paragraph.remove();
        }

        return VisitorAction.CONTINUE;
    }

    public int visitTableStart(Table table)
    {
        CheckDepthAndRemoveNode(table);

        return VisitorAction.CONTINUE;
    }

    /**
     * Checks whether the node is inside a field or should be skipped and then removes it if necessary.
     */
    private void CheckDepthAndRemoveNode(Node node)
    {
        if (mFieldDepth &gt; 0 &amp;&amp; !mNodesToSkip.contains(node))
            node.remove();
    }

    private int mFieldDepth = 0;
    private ArrayList mNodesToSkip = new ArrayList();
    private int mTargetFieldType;
}</pre></example>
</DL>
<HR>

<B>See Also:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Products/Aspose.Words/Api/index.html" TARGET="_blank">Aspose.Words Documentation</A> - the home page for the Aspose.Words Product Documentation.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Community/forums/ShowForum.aspx?ForumID=75" TARGET="_blank">Aspose.Words Support Forum</A> - our preferred method of support.<P>
<div class="footer"><hr><p><a href='http://www.aspose.com/Wiki/default.aspx/Aspose.Corporate/ContactAspose.html'>We guarantee a prompt response to any inquiry!</a></p><p>&copy; 2003-2007 Aspose Pty Ltd. All rights reserved.</p></div></BODY></HTML>