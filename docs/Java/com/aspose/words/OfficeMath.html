<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
><HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- Generated by javadoc - compatibility string-->
<!-- Generated by Aspose.JavaDoc 09 Aug 2018 -->
<TITLE>OfficeMath</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style"></HEAD>
<BODY BGCOLOR="white">
<!-- ======== START OF CLASS DATA ======== -->
<H2><a href="package-summary.html"><FONT SIZE="-1">
com.aspose.words
</FONT></a><BR>Class OfficeMath</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="Node.html" title="class in com.aspose.words">Node</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>
          <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.aspose.words.OfficeMath</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Iterable, java.lang.Cloneable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>OfficeMath </B><DT>extends <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></DL>
</PRE>

<P>

<summary>
            Represents an Office Math object such as function, equation, matrix or alike. Can contain child elements
            including runs of mathematical text, bookmarks, comments, other <cref><i>OfficeMath</i></cref> instances and some other nodes.
            </summary><remarks><p>In this version of Aspose.Words, <cref><i>OfficeMath</i></cref> nodes do not provide public methods
            and properties to create or modify a OfficeMath object. In this version you are not able to instantiate
            <cref href="Aspose.Words.Math" /> nodes or modify existing except deleting them.</p><p><cref><i>OfficeMath</i></cref> can only be a child of <cref><A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A></cref>.</p></remarks>
<HR>
<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<P>

<!-- ========== PROPERTY SUMMARY =========== -->

<A NAME="property_summary"><!-- --></A>
<TABLE RULES="GROUPS" BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Property Getters/Setters Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="NodeCollection.html" title="class in com.aspose.words">NodeCollection</A></CODE></TD><TD><CODE><B><A HREF="#ChildNodes">getChildNodes</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Gets all immediate child nodes of this node.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#Count">getCount</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the number of immediate children of this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#DisplayType">getDisplayType</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#DisplayType">setDisplayType</A></B>(int&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets/sets Office Math display format type which represents whether an equation is displayed inline with the text 
            or displayed on its own line.
            The value of the property is <A HREF="OfficeMathDisplayType.html" title="Utility class in com.aspose.words">OfficeMathDisplayType</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A></CODE></TD><TD><CODE><B><A HREF="#Document">getDocument</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the document to which this node belongs.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.nio.charset.Charset</CODE></TD><TD><CODE><B><A HREF="#EquationXmlEncoding">getEquationXmlEncoding</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#EquationXmlEncoding">setEquationXmlEncoding</A></B>(java.nio.charset.Charset&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets/sets an encoding that was used to encode equation XML, if this office math object is read from
            equation XML. We use the encoding on saving a document to write in same encoding that it was read.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#FirstChild">getFirstChild</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first child of the node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#HasChildNodes">hasChildNodes</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns true if this node has any child nodes.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsComposite">isComposite</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns true as this node can have child nodes.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#Justification">getJustification</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#Justification">setJustification</A></B>(int&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets/sets Office Math justification.
            The value of the property is <A HREF="OfficeMathJustification.html" title="Utility class in com.aspose.words">OfficeMathJustification</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#LastChild">getLastChild</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the last child of the node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#MathObjectType">getMathObjectType</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets type <cref><i>MathObjectType</i></cref> of this Office Math object. 
            The value of the property is <A HREF="MathObjectType.html" title="Utility class in com.aspose.words">MathObjectType</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#NextSibling">getNextSibling</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node immediately following this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#NodeType">getNodeType</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns <b>NodeType.OfficeMath</b>.
            The value of the property is <A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#ParentNode">getParentNode</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the immediate parent of this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A></CODE></TD><TD><CODE><B><A HREF="#ParentParagraph">getParentParagraph</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Retrieves the parent <cref><A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A></cref> of this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#PreviousSibling">getPreviousSibling</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node immediately preceding this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Range.html" title="class in com.aspose.words">Range</A></CODE></TD><TD><CODE><B><A HREF="#Range">getRange</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a <b>Range</b> object that represents the portion of a document that is contained in this node.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" RULES="GROUPS" FRAME="BOX" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#accept(com.aspose.words.DocumentVisitor)">accept</A></B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Accepts a visitor.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#appendChild(com.aspose.words.Node)">appendChild</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;newChild)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Adds the specified node to the end of the list of child nodes for this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#deepClone(boolean)">deepClone</A></B>(boolean&nbsp;isCloneChildren)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#getAncestor(int)">getAncestor</A></B>(int&nbsp;ancestorType)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first ancestor of the specified <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#getAncestor(java.lang.Class)">getAncestor</A></B>(java.lang.Class&nbsp;ancestorType)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first ancestor of the specified object type.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#getChild(int,int,boolean)">getChild</A></B>(int&nbsp;nodeType, int&nbsp;index, boolean&nbsp;isDeep)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns an Nth child node that matches the specified type.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="NodeCollection.html" title="class in com.aspose.words">NodeCollection</A></CODE></TD><TD><CODE><B><A HREF="#getChildNodes(int,boolean)">getChildNodes</A></B>(int&nbsp;nodeType, boolean&nbsp;isDeep)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Returns a live collection of child nodes that match the specified type.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="OfficeMathRenderer.html" title="class in com.aspose.words">OfficeMathRenderer</A></CODE></TD><TD><CODE><B><A HREF="#getMathRenderer()">getMathRenderer</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Creates and returns an object that can be used to render this equation into an image.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#getText()">getText</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Gets the text of this node and of all its children.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#indexOf(com.aspose.words.Node)">indexOf</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;child)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns the index of the specified child node in the child node array.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#insertAfter(com.aspose.words.Node,com.aspose.words.Node)">insertAfter</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;newChild, <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;refChild)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Inserts the specified node immediately after the specified reference node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#insertBefore(com.aspose.words.Node,com.aspose.words.Node)">insertBefore</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;newChild, <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;refChild)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Inserts the specified node immediately before the specified reference node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#nextPreOrder(com.aspose.words.Node)">nextPreOrder</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets next node according to the pre-order tree traversal algorithm.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#prependChild(com.aspose.words.Node)">prependChild</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;newChild)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Adds the specified node to the beginning of the list of child nodes for this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#previousPreOrder(com.aspose.words.Node)">previousPreOrder</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the previous node according to the pre-order tree traversal algorithm.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#remove()">remove</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes itself from the parent.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#removeAllChildren()">removeAllChildren</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes all the child nodes of the current node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#removeChild(com.aspose.words.Node)">removeChild</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;oldChild)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes the specified child node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#removeSmartTags()">removeSmartTags</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes all <cref><A HREF="SmartTag.html" title="class in com.aspose.words">SmartTag</A></cref> descendant nodes of the current node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="NodeList.html" title="class in com.aspose.words">NodeList</A></CODE></TD><TD><CODE><B><A HREF="#selectNodes(java.lang.String)">selectNodes</A></B>(java.lang.String&nbsp;xpath)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Selects a list of nodes matching the XPath expression.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#selectSingleNode(java.lang.String)">selectSingleNode</A></B>(java.lang.String&nbsp;xpath)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Selects the first Node that matches the XPath expression.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#toString()">toString</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#toString(com.aspose.words.SaveOptions)">toString</A></B>(<A HREF="SaveOptions.html" title="class in com.aspose.words">SaveOptions</A>&nbsp;saveOptions)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Exports the content of the node into a string using the specified save options.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#toString(int)">toString</A></B>(int&nbsp;saveFormat)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Exports the content of the node into a string in the specified format.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;<P>

<!-- ============ PROPERTY DETAIL ========== -->

<A NAME="property_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Property Getters/Setters Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ChildNodes"><!-- --></A><A NAME="getChildNodes()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getChildNodes</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="NodeCollection.html" title="class in com.aspose.words">NodeCollection</A>&nbsp;<B>getChildNodes</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Gets all immediate child nodes of this node.
             </summary><remarks><p>Note, <cref><A HREF="#ChildNodes" title="property in class com.aspose.words.OfficeMath">ChildNodes</A></cref> is equivalent to calling <code>GetChildNodes(NodeType.Any, false)</code>
             and creates and returns a new collection every time it is accessed.</p><p>If there are no child nodes, this property returns an empty collection.</p></remarks><example><p><b>Example:</b></p>Shows how to enumerate immediate children of a CompositeNode using the enumerator provided by the ChildNodes collection.<pre>
NodeCollection children = paragraph.getChildNodes();
for (Node child : (Iterable&lt;Node&gt;) children)
{
    // Paragraph may contain children of various types such as runs, shapes and so on.
    if (child.getNodeType() == NodeType.RUN)
    {
        // Say we found the node that we want, do something useful.
        Run run = (Run) child;
        System.out.println(run.getText());
    }
}</pre></example>
</DL>
<HR>

<A NAME="Count"><!-- --></A><A NAME="getCount()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getCount</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getCount</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the number of immediate children of this node.
            </summary>
</DL>
<HR>

<A NAME="DisplayType"><!-- --></A><A NAME="getDisplayType()"><!-- --></A><A NAME="setDisplayType(int)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getDisplayType/setDisplayType</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getDisplayType</B>()&nbsp;/&nbsp;public void&nbsp;<B>setDisplayType</B>(int&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets/sets Office Math display format type which represents whether an equation is displayed inline with the text 
            or displayed on its own line.
            The value of the property is <A HREF="OfficeMathDisplayType.html" title="Utility class in com.aspose.words">OfficeMathDisplayType</A> integer constant.</summary><remarks><p>Display format type has effect for top level Office Math only.</p><p>Returned display format type is always <cref><A HREF="OfficeMathDisplayType.html#INLINE" title="field in class com.aspose.words.OfficeMathDisplayType">OfficeMathDisplayType.INLINE</A></cref> for nested Office Math.</p></remarks><example><p><b>Example:</b></p>Shows how to set office math display formatting.<pre>
Document doc = new Document(getMyDir() + "Shape.OfficeMath.docx");

OfficeMath officeMath = (OfficeMath) doc.getChild(NodeType.OFFICE_MATH, 0, true);
officeMath.setDisplayType(OfficeMathDisplayType.DISPLAY);
officeMath.setJustification(OfficeMathJustification.LEFT);

doc.save(getMyDir() + "Artifacts\\Shape.OfficeMath.docx");</pre></example>
</DL>
<HR>

<A NAME="Document"><!-- --></A><A NAME="getDocument()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getDocument</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A>&nbsp;<B>getDocument</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the document to which this node belongs.
            </summary><remarks><p>The node always belongs to a document even if it has just been created
            and not yet added to the tree, or if it has been removed from the tree.</p></remarks><example><p><b>Example:</b></p>Shows that when you create any node, it requires a document that will own the node.<pre>
// Open a file from disk.
Document doc = new Document();

// Creating a new node of any type requires a document passed into the constructor.
Paragraph para = new Paragraph(doc);

// The new paragraph node does not yet have a parent.
System.out.println("Paragraph has no parent node: " + (para.getParentNode() == null));

// But the paragraph node knows its document.
System.out.println("Both nodes' documents are the same: " + (para.getDocument() == doc));

// The fact that a node always belongs to a document allows us to access and modify
// properties that reference the document-wide data such as styles or lists.
para.getParagraphFormat().setStyleName("Heading 1");

// Now add the paragraph to the main text of the first section.
doc.getFirstSection().getBody().appendChild(para);

// The paragraph node is now a child of the Body node.
System.out.println("Paragraph has a parent node: " + (para.getParentNode() != null));</pre></example>
</DL>
<HR>

<A NAME="EquationXmlEncoding"><!-- --></A><A NAME="getEquationXmlEncoding()"><!-- --></A><A NAME="setEquationXmlEncoding(java.nio.charset.Charset)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getEquationXmlEncoding/setEquationXmlEncoding</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.nio.charset.Charset&nbsp;<B>getEquationXmlEncoding</B>()&nbsp;/&nbsp;public void&nbsp;<B>setEquationXmlEncoding</B>(java.nio.charset.Charset&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets/sets an encoding that was used to encode equation XML, if this office math object is read from
            equation XML. We use the encoding on saving a document to write in same encoding that it was read.
            </summary>
</DL>
<HR>

<A NAME="FirstChild"><!-- --></A><A NAME="getFirstChild()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFirstChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getFirstChild</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first child of the node.
            </summary><remarks>
            If there is no first child node, a null is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to enumerate immediate child nodes of a composite node using NextSibling. In this example we enumerate all paragraphs of a section body.<pre>
// Get the section that we want to work on.
Section section = doc.getSections().get(0);
Body body = section.getBody();

// Loop starting from the first child until we reach null.
for (Node node = body.getFirstChild(); node != null; node = node.getNextSibling())
{
    // Output the types of the nodes that we come across.
    System.out.println(Node.nodeTypeToString(node.getNodeType()));
}</pre></example><example><p><b>Example:</b></p>Shows how to efficiently visit all direct and indirect children of a composite node.<pre>
public void recurseAllNodes() throws Exception
{
    // Open a document.
    Document doc = new Document(getMyDir() + "Node.RecurseAllNodes.doc");

    // Invoke the recursive function that will walk the tree.
    traverseAllNodes(doc);
}

/**
 * A simple function that will walk through all children of a specified node recursively
 * and print the type of each node to the screen.
 */
public void traverseAllNodes(CompositeNode parentNode)
{
    // This is the most efficient way to loop through immediate children of a node.
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling())
    {
        // Do some useful work.
        System.out.println(Node.nodeTypeToString(childNode.getNodeType()));

        // Recurse into the node if it is a composite node.
        if (childNode.isComposite()) traverseAllNodes((CompositeNode) childNode);
    }
}</pre></example>
</DL>
<HR>

<A NAME="HasChildNodes"><!-- --></A><A NAME="hasChildNodes()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>hasChildNodes</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>hasChildNodes</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns true if this node has any child nodes.
            </summary><example><p><b>Example:</b></p>Demonstrates how to use the InsertDocument method to insert a document into a merge field during mail merge.<pre>
public void insertDocumentAtMailMerge() throws Exception
{
    // Open the main document.
    Document mainDoc = new Document(getMyDir() + "InsertDocument1.doc");

    // Add a handler to MergeField event
    mainDoc.getMailMerge().setFieldMergingCallback(new InsertDocumentAtMailMergeHandler());

    // The main document has a merge field in it called "Document_1".
    // The corresponding data for this field contains fully qualified path to the document
    // that should be inserted to this field.
    mainDoc.getMailMerge().execute(new String[]{"Document_1"}, new String[]{getMyDir() + "InsertDocument2.doc"});

    mainDoc.save(getMyDir() + "\\Artifacts\\InsertDocumentAtMailMerge.doc");
}

private class InsertDocumentAtMailMergeHandler implements IFieldMergingCallback
{
    /**
     * This handler makes special processing for the "Document_1" field.
     * The field value contains the path to load the document.
     * We load the document and insert it into the current merge field.
     */
    public void fieldMerging(FieldMergingArgs e) throws Exception
    {
        if ("Document_1".equals(e.getDocumentFieldName()))
        {
            // Use document builder to navigate to the merge field with the specified name.
            DocumentBuilder builder = new DocumentBuilder(e.getDocument());
            builder.moveToMergeField(e.getDocumentFieldName());

            // The name of the document to load and insert is stored in the field value.
            Document subDoc = new Document((String) e.getFieldValue());

            // Insert the document.
            insertDocument(builder.getCurrentParagraph(), subDoc);

            // The paragraph that contained the merge field might be empty now and you probably want to delete it.
            if (!builder.getCurrentParagraph().hasChildNodes()) builder.getCurrentParagraph().remove();

            // Indicate to the mail merge engine that we have inserted what we wanted.
            e.setText(null);
        }
    }

    public void imageFieldMerging(ImageFieldMergingArgs args)
    {
        // Do nothing.
    }
}</pre></example>
</DL>
<HR>

<A NAME="IsComposite"><!-- --></A><A NAME="isComposite()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isComposite</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isComposite</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns true as this node can have child nodes.
            </summary><example><p><b>Example:</b></p>Shows how to efficiently visit all direct and indirect children of a composite node.<pre>
public void recurseAllNodes() throws Exception
{
    // Open a document.
    Document doc = new Document(getMyDir() + "Node.RecurseAllNodes.doc");

    // Invoke the recursive function that will walk the tree.
    traverseAllNodes(doc);
}

/**
 * A simple function that will walk through all children of a specified node recursively
 * and print the type of each node to the screen.
 */
public void traverseAllNodes(CompositeNode parentNode)
{
    // This is the most efficient way to loop through immediate children of a node.
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling())
    {
        // Do some useful work.
        System.out.println(Node.nodeTypeToString(childNode.getNodeType()));

        // Recurse into the node if it is a composite node.
        if (childNode.isComposite()) traverseAllNodes((CompositeNode) childNode);
    }
}</pre></example>
</DL>
<HR>

<A NAME="Justification"><!-- --></A><A NAME="getJustification()"><!-- --></A><A NAME="setJustification(int)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getJustification/setJustification</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getJustification</B>()&nbsp;/&nbsp;public void&nbsp;<B>setJustification</B>(int&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets/sets Office Math justification.
            The value of the property is <A HREF="OfficeMathJustification.html" title="Utility class in com.aspose.words">OfficeMathJustification</A> integer constant.</summary><remarks><p>Justification cannot be set to the Office Math with display format type <cref><A HREF="OfficeMathDisplayType.html#INLINE" title="field in class com.aspose.words.OfficeMathDisplayType">OfficeMathDisplayType.INLINE</A></cref>.</p><p>Inline justification cannot be set to the Office Math with display format type <cref><A HREF="OfficeMathDisplayType.html#DISPLAY" title="field in class com.aspose.words.OfficeMathDisplayType">OfficeMathDisplayType.DISPLAY</A></cref>.</p><p>Corresponding <cref><A HREF="#DisplayType" title="property in class com.aspose.words.OfficeMath">DisplayType</A></cref> has to be set before setting Office Math justification.</p></remarks><example><p><b>Example:</b></p>Shows how to set office math display formatting.<pre>
Document doc = new Document(getMyDir() + "Shape.OfficeMath.docx");

OfficeMath officeMath = (OfficeMath) doc.getChild(NodeType.OFFICE_MATH, 0, true);
officeMath.setDisplayType(OfficeMathDisplayType.DISPLAY);
officeMath.setJustification(OfficeMathJustification.LEFT);

doc.save(getMyDir() + "Artifacts\\Shape.OfficeMath.docx");</pre></example>
</DL>
<HR>

<A NAME="LastChild"><!-- --></A><A NAME="getLastChild()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getLastChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getLastChild</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the last child of the node.
            </summary><remarks>
            If there is no last child node, a null is returned.
            </remarks><example><p><b>Example:</b></p>Demonstrates use of methods of Node and CompositeNode to remove a section before the last section in the document.<pre>
// Document is a CompositeNode and LastChild returns the last child node in the Document node.
// Since the Document can contain only Section nodes, the last child is the last section.
Node lastSection = doc.getLastChild();

// Each node knows its next and previous sibling nodes.
// Previous sibling of a section is a section before the specified section.
// If the node is the first child, PreviousSibling will return null.
Node sectionBeforeLast = lastSection.getPreviousSibling();

if (sectionBeforeLast != null) doc.removeChild(sectionBeforeLast);</pre></example>
</DL>
<HR>

<A NAME="MathObjectType"><!-- --></A><A NAME="getMathObjectType()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getMathObjectType</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getMathObjectType</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets type <cref><i>MathObjectType</i></cref> of this Office Math object. 
            The value of the property is <A HREF="MathObjectType.html" title="Utility class in com.aspose.words">MathObjectType</A> integer constant.</summary>
</DL>
<HR>

<A NAME="NextSibling"><!-- --></A><A NAME="getNextSibling()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNextSibling</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getNextSibling</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node immediately following this node.
            </summary><remarks>
            If there is no next node, a null is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to enumerate immediate child nodes of a composite node using NextSibling. In this example we enumerate all paragraphs of a section body.<pre>
// Get the section that we want to work on.
Section section = doc.getSections().get(0);
Body body = section.getBody();

// Loop starting from the first child until we reach null.
for (Node node = body.getFirstChild(); node != null; node = node.getNextSibling())
{
    // Output the types of the nodes that we come across.
    System.out.println(Node.nodeTypeToString(node.getNodeType()));
}</pre></example><example><p><b>Example:</b></p>Shows how to efficiently visit all direct and indirect children of a composite node.<pre>
public void recurseAllNodes() throws Exception
{
    // Open a document.
    Document doc = new Document(getMyDir() + "Node.RecurseAllNodes.doc");

    // Invoke the recursive function that will walk the tree.
    traverseAllNodes(doc);
}

/**
 * A simple function that will walk through all children of a specified node recursively
 * and print the type of each node to the screen.
 */
public void traverseAllNodes(CompositeNode parentNode)
{
    // This is the most efficient way to loop through immediate children of a node.
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling())
    {
        // Do some useful work.
        System.out.println(Node.nodeTypeToString(childNode.getNodeType()));

        // Recurse into the node if it is a composite node.
        if (childNode.isComposite()) traverseAllNodes((CompositeNode) childNode);
    }
}</pre></example>
</DL>
<HR>

<A NAME="NodeType"><!-- --></A><A NAME="getNodeType()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNodeType</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getNodeType</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns <b>NodeType.OfficeMath</b>.
            The value of the property is <A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A> integer constant.</summary>
</DL>
<HR>

<A NAME="ParentNode"><!-- --></A><A NAME="getParentNode()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getParentNode</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getParentNode</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the immediate parent of this node.
            </summary><remarks><p>If a node has just been created and not yet added to the tree,
            or if it has been removed from the tree, the parent is null.</p></remarks><example><p><b>Example:</b></p>Shows how to access the parent node.<pre>
// Create a new empty document. It has one section.
Document doc = new Document();

// The section is the first child node of the document.
Node section = doc.getFirstChild();

// The section's parent node is the document.
System.out.println("Section parent is the document: " + (doc == section.getParentNode()));</pre></example><example><p><b>Example:</b></p>Shows that when you create any node, it requires a document that will own the node.<pre>
// Open a file from disk.
Document doc = new Document();

// Creating a new node of any type requires a document passed into the constructor.
Paragraph para = new Paragraph(doc);

// The new paragraph node does not yet have a parent.
System.out.println("Paragraph has no parent node: " + (para.getParentNode() == null));

// But the paragraph node knows its document.
System.out.println("Both nodes' documents are the same: " + (para.getDocument() == doc));

// The fact that a node always belongs to a document allows us to access and modify
// properties that reference the document-wide data such as styles or lists.
para.getParagraphFormat().setStyleName("Heading 1");

// Now add the paragraph to the main text of the first section.
doc.getFirstSection().getBody().appendChild(para);

// The paragraph node is now a child of the Body node.
System.out.println("Paragraph has a parent node: " + (para.getParentNode() != null));</pre></example>
</DL>
<HR>

<A NAME="ParentParagraph"><!-- --></A><A NAME="getParentParagraph()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getParentParagraph</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A>&nbsp;<B>getParentParagraph</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Retrieves the parent <cref><A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A></cref> of this node.
            </summary>
</DL>
<HR>

<A NAME="PreviousSibling"><!-- --></A><A NAME="getPreviousSibling()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getPreviousSibling</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getPreviousSibling</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node immediately preceding this node.
            </summary><remarks>
            If there is no preceding node, a null is returned.
            </remarks><example><p><b>Example:</b></p>Demonstrates use of methods of Node and CompositeNode to remove a section before the last section in the document.<pre>
// Document is a CompositeNode and LastChild returns the last child node in the Document node.
// Since the Document can contain only Section nodes, the last child is the last section.
Node lastSection = doc.getLastChild();

// Each node knows its next and previous sibling nodes.
// Previous sibling of a section is a section before the specified section.
// If the node is the first child, PreviousSibling will return null.
Node sectionBeforeLast = lastSection.getPreviousSibling();

if (sectionBeforeLast != null) doc.removeChild(sectionBeforeLast);</pre></example>
</DL>
<HR>

<A NAME="Range"><!-- --></A><A NAME="getRange()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getRange</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Range.html" title="class in com.aspose.words">Range</A>&nbsp;<B>getRange</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a <b>Range</b> object that represents the portion of a document that is contained in this node.
            </summary><example><p><b>Example:</b></p>Shows how to delete all characters of a range.<pre>
// Open Word document.
Document doc = new Document(getMyDir() + "Range.DeleteSection.doc");

// The document contains two sections. Each section has a paragraph of text.
System.out.println(doc.getText());

// Delete the first section from the document.
doc.getSections().get(0).getRange().delete();

// Check the first section was deleted by looking at the text of the whole document again.
System.out.println(doc.getText());</pre></example>
</DL>
<HR>



<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="accept(com.aspose.words.DocumentVisitor)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>accept</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>accept</B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)
              throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
Accepts a visitor.
</summary><remarks><p>Enumerates over this node and all of its children. Each node calls a corresponding method on DocumentVisitor.</p><p>For more info see the Visitor design pattern.</p></remarks><remarks>
            Calls <cref><A HREF="DocumentVisitor.html#visitOfficeMathStart(com.aspose.words.OfficeMath)" title="method in class com.aspose.words.DocumentVisitor">DocumentVisitor.visitOfficeMathStart(com.aspose.words.OfficeMath)</A></cref>, then calls <cref><A HREF="#accept(com.aspose.words.DocumentVisitor)" title="method in class com.aspose.words.OfficeMath">accept(com.aspose.words.DocumentVisitor)</A></cref> for all
            child nodes of the Office Math and calls <cref><A HREF="DocumentVisitor.html#visitOfficeMathEnd(com.aspose.words.OfficeMath)" title="method in class com.aspose.words.DocumentVisitor">DocumentVisitor.visitOfficeMathEnd(com.aspose.words.OfficeMath)</A></cref> at the end.
            </remarks><DL><DT><B>Parameters:</B></DT><DD param="visitor"><CODE>visitor</CODE> - The visitor that will visit the nodes.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">True if all nodes were visited; false if DocumentVisitor stopped the operation before visiting all nodes.</DD></DL>
</DL>
<HR>

<A NAME="appendChild(com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>appendChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>appendChild</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;newChild)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Adds the specified node to the end of the list of child nodes for this node.
            </summary><remarks><p>If the newChild is already in the tree, it is first removed.</p><p>If the node being inserted was created from another document, you should use 
<cref><A HREF="DocumentBase.html#importNode(com.aspose.words.Node,boolean,int)" title="method in class com.aspose.words.DocumentBase">DocumentBase.importNode(com.aspose.words.Node,boolean,int)</A></cref> to import the node to the current document. 
The imported node can then be inserted into the current document.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="newChild"><CODE>newChild</CODE> - The node to add.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The node added.</DD></DL><example><p><b>Example:</b></p>Creates a simple document from scratch using the Aspose.Words object model.<pre>
// Create an "empty" document. Note that like in Microsoft Word,
// the empty document has one section, body and one paragraph in it.
Document doc = new Document();

// This truly makes the document empty. No sections (not possible in Microsoft Word).
doc.removeAllChildren();

// Create a new section node.
// Note that the section has not yet been added to the document,
// but we have to specify the parent document.
Section section = new Section(doc);

// Append the section to the document.
doc.appendChild(section);

// Lets set some properties for the section.
section.getPageSetup().setSectionStart(SectionStart.NEW_PAGE);
section.getPageSetup().setPaperSize(PaperSize.LETTER);

// The section that we created is empty, lets populate it. The section needs at least the Body node.
Body body = new Body(doc);
section.appendChild(body);

// The body needs to have at least one paragraph.
// Note that the paragraph has not yet been added to the document,
// but we have to specify the parent document.
// The parent document is needed so the paragraph can correctly work
// with styles and other document-wide information.
Paragraph para = new Paragraph(doc);
body.appendChild(para);

// We can set some formatting for the paragraph
para.getParagraphFormat().setStyleName("Heading 1");
para.getParagraphFormat().setAlignment(ParagraphAlignment.CENTER);

// So far we have one empty paragraph in the document.
// The document is valid and can be saved, but lets add some text before saving.
// Create a new run of text and add it to our paragraph.
Run run = new Run(doc);
run.setText("Hello World!");
run.getFont().setColor(Color.RED);
para.appendChild(run);

// As a matter of interest, you can retrieve text of the whole document and
// see that \x000c is automatically appended. \x000c is the end of section character.
System.out.println(doc.getText());

// Save the document.
doc.save(getMyDir() + "\\Artifacts\\Section.CreateFromScratch.doc");</pre></example>
</DL>
<HR>

<A NAME="deepClone(boolean)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>deepClone</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>deepClone</B>(boolean&nbsp;isCloneChildren)</PRE></TD></TR></TABLE>
<DL><DD><!-- No matching elements were found for the following include tag --><include file="..\Docs\Text.xml" path="Topics/Topic[@name=&quot;Node.Clone&quot;]/*" /><summary /><example><p><b>Example:</b></p>Shows how to clone composite nodes with and without their child nodes.<pre>
// Create a new empty document.
Document doc = new Document();

// Add some text to the first paragraph
Paragraph para = doc.getFirstSection().getBody().getFirstParagraph();
para.appendChild(new Run(doc, "Some text"));

// Clone the paragraph and the child nodes.
Node cloneWithChildren = para.deepClone(true);
// Only clone the paragraph and no child nodes.
Node cloneWithoutChildren = para.deepClone(false);</pre></example>
</DL>
<HR>

<A NAME="getAncestor(int)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getAncestor</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getAncestor</B>(int&nbsp;ancestorType)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first ancestor of the specified <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref>.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="ancestorType"><CODE>ancestorType</CODE> - A <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref> value. The node type of the ancestor to retrieve.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The ancestor of the specified type or null if no ancestor of this type was found.</DD></DL><example><p><b>Example:</b></p>Shows how to find out if a table contains another table or if the table itself is nested inside another table.<pre>
public void calculateDepthOfNestedTables() throws Exception
{
    Document doc = new Document(getMyDir() + "Table.NestedTables.doc");
    int tableIndex = 0;

    for (Table table : (Iterable&lt;Table&gt;) doc.getChildNodes(NodeType.TABLE, true))
    {
        // First lets find if any cells in the table have tables themselves as children.
        int count = getChildTableCount(table);
        System.out.println(MessageFormat.format("Table #{0} has {1} tables directly within its cells", tableIndex, count));

        // Now let's try the other way around, lets try find if the table is nested inside another table and at what depth.
        int tableDepth = getNestedDepthOfTable(table);

        if (tableDepth &gt; 0)
            System.out.println(MessageFormat.format("Table #{0} is nested inside another table at depth of {1}", tableIndex, tableDepth));
        else
            System.out.println(MessageFormat.format("Table #{0} is a non nested table (is not a child of another table)", tableIndex));

        tableIndex++;
    }
}

/**
 * Calculates what level a table is nested inside other tables.
 *
 * @returns An integer containing the level the table is nested at.
 * 0 = Table is not nested inside any other table
 * 1 = Table is nested within one parent table
 * 2 = Table is nested within two parent tables etc..
 */
private static int getNestedDepthOfTable(Table table)
{
    int depth = 0;

    int type = table.getNodeType();
    // The parent of the table will be a Cell, instead attempt to find a grandparent that is of type Table
    Node parent = table.getAncestor(type);

    while (parent != null)
    {
        // Every time we find a table a level up we increase the depth counter and then try to find an
        // ancestor of type table from the parent.
        depth++;
        parent = parent.getAncestor(type);
    }

    return depth;
}

/**
 * Determines if a table contains any immediate child table within its cells.
 * Does not recursively traverse through those tables to check for further tables.
 *
 * @returns Returns true if at least one child cell contains a table.
 * Returns false if no cells in the table contains a table.
 */
private static int getChildTableCount(Table table)
{
    int tableCount = 0;
    // Iterate through all child rows in the table
    for (Row row : table.getRows())
    {
        // Iterate through all child cells in the row
        for (Cell Cell : row.getCells())
        {
            // Retrieve the collection of child tables of this cell
            TableCollection childTables = Cell.getTables();

            // If this cell has a table as a child then return true
            if (childTables.getCount() &gt; 0) tableCount++;
        }
    }

    // No cell contains a table
    return tableCount;
}</pre></example>
</DL>
<HR>

<A NAME="getAncestor(java.lang.Class)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getAncestor</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getAncestor</B>(java.lang.Class&nbsp;ancestorType)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first ancestor of the specified object type.
            </summary><remarks><p>The ancestor type matches if it is equal to ancestorType or derived from ancestorType.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="ancestorType"><CODE>ancestorType</CODE> - The object type of the ancestor to retrieve.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The ancestor of the specified type or null if no ancestor of this type was found.</DD></DL>
</DL>
<HR>

<A NAME="getChild(int,int,boolean)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getChild</B>(int&nbsp;nodeType, int&nbsp;index, boolean&nbsp;isDeep)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns an Nth child node that matches the specified type.
            </summary><remarks><p>If index is out of range, a null is returned.</p></remarks><remarks>Note that markup nodes (<cref><A HREF="NodeType.html#STRUCTURED_DOCUMENT_TAG" title="field in class com.aspose.words.NodeType">NodeType.STRUCTURED_DOCUMENT_TAG</A></cref> and <cref><A HREF="NodeType.html#SMART_TAG" title="field in class com.aspose.words.NodeType">NodeType.SMART_TAG</A></cref>)
            are traversed even when isDeep = false and GetChild is invoked for non-markup node type. For example if the first run in a para 
            is wrapped in a StructuredDocumentTag, it will still be returned by GetChild(NodeType.Run, 0, false).</remarks><DL><DT><B>Parameters:</B></DT><DD param="nodeType"><CODE>nodeType</CODE> - A <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref> value. Specifies the type of the child node.</DD><DD param="index"><CODE>index</CODE> - Zero based index of the child node to select.
            Negative indexes are also allowed and indicate access from the end,
            that is -1 means the last node.</DD><DD param="isDeep"><CODE>isDeep</CODE> - True to select from all child nodes recursively.
            False to select only among immediate children. See remarks for more info.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The child node that matches the criteria or null if no matching node is found.</DD></DL><example><p><b>Example:</b></p>Shows how to test if a node is inside a field by using an XPath expression.<pre>
// Let's pick a document we know has some fields in.
Document doc = new Document(getMyDir() + "MailMerge.MergeImage.doc");

// Let's say we want to check if the Run below is inside a field.
Run run = (Run) doc.getChild(NodeType.RUN, 5, true);

// Evaluate the XPath expression. The resulting NodeList will contain all nodes found inside a field a field (between FieldStart
// and FieldEnd exclusive). There can however be FieldStart and FieldEnd nodes in the list if there are nested fields
// in the path. Currently does not find rare fields in which the FieldCode or FieldResult spans across multiple paragraphs.
NodeList resultList = doc.selectNodes("//FieldStart/following-sibling::node()[following-sibling::FieldEnd]");

// Check if the specified run is one of the nodes that are inside the field.
for (Node node : (Iterable&lt;Node&gt;) resultList)
{
    if (node == run)
    {
        System.out.println("The node is found inside a field");
        break;
    }
}</pre></example><example><p><b>Example:</b></p>Shows how to extract a specific child node from a CompositeNode by using the GetChild method and passing the NodeType and index.<pre>
Paragraph paragraph = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 0, true);</pre></example>
</DL>
<HR>

<A NAME="getChildNodes(int,boolean)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getChildNodes</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="NodeCollection.html" title="class in com.aspose.words">NodeCollection</A>&nbsp;<B>getChildNodes</B>(int&nbsp;nodeType, boolean&nbsp;isDeep)</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Returns a live collection of child nodes that match the specified type.
             </summary><remarks><p>The collection of nodes returned by this method is always live.</p><remarks><p>A live collection is always in sync with the document. For example, if you
selected all sections in a document and enumerate through the collection
deleting the sections, the section is removed from the collection immediately
when it is removed from the document.</p></remarks></remarks><DL><DT><B>Parameters:</B></DT><DD param="nodeType"><CODE>nodeType</CODE> - A <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref> value. Specifies the type of nodes to select.</DD><DD param="isDeep"><CODE>isDeep</CODE> - True to select from all child nodes recursively.
             False to select only among immediate children. </DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A live collection of child nodes of the specified type.</DD></DL><example><p><b>Example:</b></p>Shows how to extract images from a document and save them as files.<pre>
public void extractImagesToFiles() throws Exception
{
    Document doc = new Document(getMyDir() + "Image.SampleImages.doc");

    NodeCollection shapes = doc.getChildNodes(NodeType.SHAPE, true);
    int imageIndex = 0;
    for (Shape shape : (Iterable&lt;Shape&gt;) shapes)
    {
        if (shape.hasImage())
        {
            String imageFileName = java.text.MessageFormat.format("\\Artifacts\\Image.ExportImages.{0} Out{1}", imageIndex, FileFormatUtil.imageTypeToExtension(shape.getImageData().getImageType()));
            shape.getImageData().save(getMyDir() + imageFileName);
            imageIndex++;
        }
    }
}</pre></example><example><p><b>Example:</b></p>Demonstrates how to remove a specified TOC from a document.<pre>
public void removeTOCFromDocument() throws Exception
{
    // Open a document which contains a TOC.
    Document doc = new Document(getMyDir() + "Document.TableOfContents.doc");

    // Remove the first TOC from the document.
    Field tocField = doc.getRange().getFields().get(0);
    tocField.remove();

    // Save the output.
    doc.save(getMyDir() + "\\Artifacts\\Document.TableOfContentsRemoveTOC.doc");
}</pre></example>
</DL>
<HR>

<A NAME="getMathRenderer()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getMathRenderer</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="OfficeMathRenderer.html" title="class in com.aspose.words">OfficeMathRenderer</A>&nbsp;<B>getMathRenderer</B>()
                                  throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Creates and returns an object that can be used to render this equation into an image.
            </summary><remarks><p>This method just invokes the <cref><A HREF="OfficeMathRenderer.html" title="class in com.aspose.words">OfficeMathRenderer</A></cref> constructor and passes 
            this object as a parameter.</p></remarks><DL><DT><B>Returns:</B></DT><DD returns="">The renderer object for this equation.</DD></DL><example><p><b>Example:</b></p>Shows how to convert specific object into image<pre>
Document doc = new Document(getMyDir() + "Shape.OfficeMath.docx");

//Get OfficeMath node from the document and render this as image (you can also do the same with the Shape node)
OfficeMath math = (OfficeMath) doc.getChild(NodeType.OFFICE_MATH, 0, true);
math.getMathRenderer().save(getMyDir() + "\\Artifacts\\Shape.OfficeMath.svg", new ImageSaveOptions(SaveFormat.SVG));</pre></example>
</DL>
<HR>

<A NAME="getText()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getText</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getText</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Gets the text of this node and of all its children.
             </summary><remarks><p>The returned string includes all control and special characters as described in <cref><A HREF="ControlChar.html" title="class in com.aspose.words">ControlChar</A></cref>.</p></remarks><example><p><b>Example:</b></p>Shows the difference between calling the GetText and ToString methods on a node.<pre>
Document doc = new Document();

// Enter a dummy field into the document.
DocumentBuilder builder = new DocumentBuilder(doc);
builder.insertField("MERGEFIELD Field");

// GetText will retrieve all field codes and special characters
System.out.println("GetText() Result: " + doc.getText());

// ToString will export the node to the specified format. When converted to text it will not retrieve fields code
// or special characters, but will still contain some natural formatting characters such as paragraph markers etc.
// This is the same as "viewing" the document as if it was opened in a text editor.
System.out.println("ToString() Result: " + doc.toString(SaveFormat.TEXT));</pre></example><example><p><b>Example:</b></p>Finds and outputs all paragraphs in a document that are bulleted or numbered.<pre>
NodeCollection paras = doc.getChildNodes(NodeType.PARAGRAPH, true);
for (Paragraph para : (Iterable&lt;Paragraph&gt;) paras)
{
    if (para.getListFormat().isListItem())
    {
        System.out.println(java.text.MessageFormat.format("*** A paragraph belongs to list {0}", para.getListFormat().getList().getListId()));
        System.out.println(para.getText());
    }
}</pre></example>
</DL>
<HR>

<A NAME="indexOf(com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>indexOf</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>indexOf</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;child)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns the index of the specified child node in the child node array.
            </summary><remarks>
            Returns -1 if the node is not found in the child nodes.
            </remarks><example><p><b>Example:</b></p>Shows how to get the index of a given child node from its parent.<pre>
Document doc = new Document(getMyDir() + "Rendering.doc");

// Get the body of the first section in the document.
Body body = doc.getFirstSection().getBody();
// Retrieve the index of the last paragraph in the body.
int index = body.getChildNodes().indexOf(body.getLastParagraph());</pre></example><example><p><b>Example:</b></p>Retrieves the index of a row in a table.<pre>
int rowIndex = table.indexOf(row);</pre></example><example><p><b>Example:</b></p>Retrieves the index of a cell in a row.<pre>
int cellIndex = row.indexOf(cell);</pre></example>
</DL>
<HR>

<A NAME="insertAfter(com.aspose.words.Node,com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>insertAfter</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>insertAfter</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;newChild, <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;refChild)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Inserts the specified node immediately after the specified reference node.
            </summary><remarks><p>If refChild is null, inserts newChild at the beginning of the list of child nodes.</p></remarks><remarks><p>If the newChild is already in the tree, it is first removed.</p><p>If the node being inserted was created from another document, you should use 
<cref><A HREF="DocumentBase.html#importNode(com.aspose.words.Node,boolean,int)" title="method in class com.aspose.words.DocumentBase">DocumentBase.importNode(com.aspose.words.Node,boolean,int)</A></cref> to import the node to the current document. 
The imported node can then be inserted into the current document.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="newChild"><CODE>newChild</CODE> - The Node to insert.</DD><DD param="refChild"><CODE>refChild</CODE> - The Node that is the reference node. The newNode is placed after the refNode. </DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The inserted node.</DD></DL><example><p><b>Example:</b></p>Shows how to replace all textboxes with images.<pre>
Document doc = new Document(getMyDir() + "Shape.ReplaceTextboxesWithImages.doc");

// This gets a live collection of all shape nodes in the document.
NodeCollection shapeCollection = doc.getChildNodes(NodeType.SHAPE, true);

// Since we will be adding/removing nodes, it is better to copy all collection
// into a fixed size array, otherwise iterator will be invalidated.
Node[] shapes = shapeCollection.toArray();

for (Node node : shapes)
{
    Shape shape = (Shape) node;
    // Filter out all shapes that we don't need.
    if (shape.getShapeType() == ShapeType.TEXT_BOX)
    {
        // Create a new shape that will replace the existing shape.
        Shape image = new Shape(doc, ShapeType.IMAGE);

        // Load the image into the new shape.
        image.getImageData().setImage(getImageDir() + "Hammer.wmf");

        // Make new shape's position to match the old shape.
        image.setLeft(shape.getLeft());
        image.setTop(shape.getTop());
        image.setWidth(shape.getWidth());
        image.setHeight(shape.getHeight());
        image.setRelativeHorizontalPosition(shape.getRelativeHorizontalPosition());
        image.setRelativeVerticalPosition(shape.getRelativeVerticalPosition());
        image.setHorizontalAlignment(shape.getHorizontalAlignment());
        image.setVerticalAlignment(shape.getVerticalAlignment());
        image.setWrapType(shape.getWrapType());
        image.setWrapSide(shape.getWrapSide());

        // Insert new shape after the old shape and remove the old shape.
        shape.getParentNode().insertAfter(image, shape);
        shape.remove();
    }
}

doc.save(getMyDir() + "\\Artifacts\\Shape.ReplaceTextboxesWithImages.doc");</pre></example>
</DL>
<HR>

<A NAME="insertBefore(com.aspose.words.Node,com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>insertBefore</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>insertBefore</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;newChild, <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;refChild)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Inserts the specified node immediately before the specified reference node.
            </summary><remarks><p>If refChild is null, inserts newChild at the end of the list of child nodes.</p></remarks><remarks><p>If the newChild is already in the tree, it is first removed.</p><p>If the node being inserted was created from another document, you should use 
<cref><A HREF="DocumentBase.html#importNode(com.aspose.words.Node,boolean,int)" title="method in class com.aspose.words.DocumentBase">DocumentBase.importNode(com.aspose.words.Node,boolean,int)</A></cref> to import the node to the current document. 
The imported node can then be inserted into the current document.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="newChild"><CODE>newChild</CODE> - The Node to insert.</DD><DD param="refChild"><CODE>refChild</CODE> - The Node that is the reference node. The newChild is placed before this node.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The inserted node.</DD></DL>
</DL>
<HR>

<A NAME="nextPreOrder(com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>nextPreOrder</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>nextPreOrder</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets next node according to the pre-order tree traversal algorithm.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="rootNode"><CODE>rootNode</CODE> - The top node (limit) of traversal.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">Next node in pre-order order. Null if reached the rootNode.</DD></DL><example><p><b>Example:</b></p>Shows how to delete all images from a document using pre-order tree traversal.<pre>
Node curNode = doc;
while (curNode != null)
{
    Node nextNode = curNode.nextPreOrder(doc);

    if (curNode.getNodeType() == NodeType.SHAPE)
    {
        Shape shape = (Shape) curNode;

        // Several shape types can have an image including image shapes and OLE objects.
        if (shape.hasImage()) shape.remove();
    }

    curNode = nextNode;
}</pre></example>
</DL>
<HR>

<A NAME="prependChild(com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>prependChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>prependChild</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;newChild)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Adds the specified node to the beginning of the list of child nodes for this node.
            </summary><remarks><p>If the newChild is already in the tree, it is first removed.</p><p>If the node being inserted was created from another document, you should use 
<cref><A HREF="DocumentBase.html#importNode(com.aspose.words.Node,boolean,int)" title="method in class com.aspose.words.DocumentBase">DocumentBase.importNode(com.aspose.words.Node,boolean,int)</A></cref> to import the node to the current document. 
The imported node can then be inserted into the current document.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="newChild"><CODE>newChild</CODE> - The node to add.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The node added.</DD></DL><example><p><b>Example:</b></p>Shows how to manually prepend the content from one document to the beginning of another document.<pre>
public static void prependDocumentMain() throws Exception
{
    Document dstDoc = new Document(gDataDir + "TestFile.Destination.doc");
    Document srcDoc = new Document(gDataDir + "TestFile.Source.doc");

    // Append the source document to the destination document. This causes the result to have line spacing problems.
    dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING);

    // Instead prepend the content of the destination document to the start of the source document.
    // This results in the same joined document but with no line spacing issues.
    prependDocument(srcDoc, dstDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING);
}


/**
 * A modified version of the AppendDocument method which prepends the content of one document to the start
 * of another.
 *
 * @param dstDoc The destination document where to prepend the source document to.
 * @param srcDoc The source document.
 */
public static void prependDocument(Document dstDoc, Document srcDoc, int mode) throws Exception
{
    // Loop through all sections in the source document.
    // Section nodes are immediate children of the Document node so we can just enumerate the Document.
    ArrayList sections = (ArrayList)Arrays.asList(srcDoc.getSections().toArray());

    // Reverse the order of the sections so they are prepended to start of the destination document in the correct order.
    Collections.reverse(sections);

    for (Section srcSection : (Iterable&lt;Section&gt;) sections)
    {
        // Import the nodes from the source document.
        Node dstSection = dstDoc.importNode(srcSection, true, mode);

        // Now the new section node can be prepended to the destination document.
        // Note how PrependChild is used instead of AppendChild. This is the only line changed compared
        // to the original method.
        dstDoc.prependChild(dstSection);
    }
}</pre></example>
</DL>
<HR>

<A NAME="previousPreOrder(com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>previousPreOrder</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>previousPreOrder</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the previous node according to the pre-order tree traversal algorithm.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="rootNode"><CODE>rootNode</CODE> - The top node (limit) of traversal.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">Previous node in pre-order order. Null if reached the rootNode.</DD></DL>
</DL>
<HR>

<A NAME="remove()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>remove</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>remove</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes itself from the parent.
            </summary><example><p><b>Example:</b></p>Shows how to remove all nodes of a specific type from a composite node. In this example we remove tables from a section body.<pre>
// Get the section that we want to work on.
Section section = doc.getSections().get(0);
Body body = section.getBody();

// Select the first child node in the body.
Node curNode = body.getFirstChild();

while (curNode != null)
{
    // Save the pointer to the next sibling node because if the current
    // node is removed from the parent in the next step, we will have
    // no way of finding the next node to continue the loop.
    Node nextNode = curNode.getNextSibling();

    // A section body can contain Paragraph and Table nodes.
    // If the node is a Table, remove it from the parent.
    if (curNode.getNodeType() == NodeType.TABLE) curNode.remove();

    // Continue going through child nodes until null (no more siblings) is reached.
    curNode = nextNode;
}</pre></example><example><p><b>Example:</b></p>Shows how to delete all images from a document.<pre>
// Here we get all shapes from the document node, but you can do this for any smaller
// node too, for example delete shapes from a single section or a paragraph.
NodeCollection shapes = doc.getChildNodes(NodeType.SHAPE, true);

// We cannot delete shape nodes while we enumerate through the collection.
// One solution is to add nodes that we want to delete to a temporary array and delete afterwards.
ArrayList shapesToDelete = new ArrayList();
for (Shape shape : (Iterable&lt;Shape&gt;) shapes)
{
    // Several shape types can have an image including image shapes and OLE objects.
    if (shape.hasImage()) shapesToDelete.add(shape);
}

// Now we can delete shapes.
for (Shape shape : (Iterable&lt;Shape&gt;) shapesToDelete)
    shape.remove();</pre></example>
</DL>
<HR>

<A NAME="removeAllChildren()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>removeAllChildren</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>removeAllChildren</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes all the child nodes of the current node.
            </summary><example><p><b>Example:</b></p>Creates a simple document from scratch using the Aspose.Words object model.<pre>
// Create an "empty" document. Note that like in Microsoft Word,
// the empty document has one section, body and one paragraph in it.
Document doc = new Document();

// This truly makes the document empty. No sections (not possible in Microsoft Word).
doc.removeAllChildren();

// Create a new section node.
// Note that the section has not yet been added to the document,
// but we have to specify the parent document.
Section section = new Section(doc);

// Append the section to the document.
doc.appendChild(section);

// Lets set some properties for the section.
section.getPageSetup().setSectionStart(SectionStart.NEW_PAGE);
section.getPageSetup().setPaperSize(PaperSize.LETTER);

// The section that we created is empty, lets populate it. The section needs at least the Body node.
Body body = new Body(doc);
section.appendChild(body);

// The body needs to have at least one paragraph.
// Note that the paragraph has not yet been added to the document,
// but we have to specify the parent document.
// The parent document is needed so the paragraph can correctly work
// with styles and other document-wide information.
Paragraph para = new Paragraph(doc);
body.appendChild(para);

// We can set some formatting for the paragraph
para.getParagraphFormat().setStyleName("Heading 1");
para.getParagraphFormat().setAlignment(ParagraphAlignment.CENTER);

// So far we have one empty paragraph in the document.
// The document is valid and can be saved, but lets add some text before saving.
// Create a new run of text and add it to our paragraph.
Run run = new Run(doc);
run.setText("Hello World!");
run.getFont().setColor(Color.RED);
para.appendChild(run);

// As a matter of interest, you can retrieve text of the whole document and
// see that \x000c is automatically appended. \x000c is the end of section character.
System.out.println(doc.getText());

// Save the document.
doc.save(getMyDir() + "\\Artifacts\\Section.CreateFromScratch.doc");</pre></example>
</DL>
<HR>

<A NAME="removeChild(com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>removeChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>removeChild</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;oldChild)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes the specified child node.
            </summary><remarks><p>The parent of oldChild is set to null after the node is removed.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="oldChild"><CODE>oldChild</CODE> - The node to remove.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The removed node.</DD></DL><example><p><b>Example:</b></p>Demonstrates use of methods of Node and CompositeNode to remove a section before the last section in the document.<pre>
// Document is a CompositeNode and LastChild returns the last child node in the Document node.
// Since the Document can contain only Section nodes, the last child is the last section.
Node lastSection = doc.getLastChild();

// Each node knows its next and previous sibling nodes.
// Previous sibling of a section is a section before the specified section.
// If the node is the first child, PreviousSibling will return null.
Node sectionBeforeLast = lastSection.getPreviousSibling();

if (sectionBeforeLast != null) doc.removeChild(sectionBeforeLast);</pre></example>
</DL>
<HR>

<A NAME="removeSmartTags()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>removeSmartTags</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>removeSmartTags</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes all <cref><A HREF="SmartTag.html" title="class in com.aspose.words">SmartTag</A></cref> descendant nodes of the current node.
            </summary><remarks>This method does not remove the content of the smart tags.</remarks><example><p><b>Example:</b></p>Removes all smart tags from descendant nodes of the composite node.<pre>
Document doc = new Document(getMyDir() + "Document.doc");

// Remove smart tags from the first paragraph in the document.
doc.getFirstSection().getBody().getFirstParagraph().removeSmartTags();</pre></example><example><p><b>Example:</b></p>Shows how to remove all smart tags from a document.<pre>
Document doc = new Document(getMyDir() + "Document.doc");
doc.removeSmartTags();</pre></example>
</DL>
<HR>

<A NAME="selectNodes(java.lang.String)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>selectNodes</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="NodeList.html" title="class in com.aspose.words">NodeList</A>&nbsp;<B>selectNodes</B>(java.lang.String&nbsp;xpath)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Selects a list of nodes matching the XPath expression.
            </summary><remarks><p>Only expressions with element names are supported at the moment. Expressions
            that use attribute names are not supported.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="xpath"><CODE>xpath</CODE> - The XPath expression.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A list of nodes matching the XPath query.</DD></DL><example><p><b>Example:</b></p>Shows how to test if a node is inside a field by using an XPath expression.<pre>
// Let's pick a document we know has some fields in.
Document doc = new Document(getMyDir() + "MailMerge.MergeImage.doc");

// Let's say we want to check if the Run below is inside a field.
Run run = (Run) doc.getChild(NodeType.RUN, 5, true);

// Evaluate the XPath expression. The resulting NodeList will contain all nodes found inside a field a field (between FieldStart
// and FieldEnd exclusive). There can however be FieldStart and FieldEnd nodes in the list if there are nested fields
// in the path. Currently does not find rare fields in which the FieldCode or FieldResult spans across multiple paragraphs.
NodeList resultList = doc.selectNodes("//FieldStart/following-sibling::node()[following-sibling::FieldEnd]");

// Check if the specified run is one of the nodes that are inside the field.
for (Node node : (Iterable&lt;Node&gt;) resultList)
{
    if (node == run)
    {
        System.out.println("The node is found inside a field");
        break;
    }
}</pre></example><example><p><b>Example:</b></p>Shows how to select certain nodes by using an XPath expression.<pre>
Document doc = new Document(getMyDir() + "Table.Document.doc");

// This expression will extract all paragraph nodes which are descendants of any table node in the document.
// This will return any paragraphs which are in a table.
NodeList nodeList = doc.selectNodes("//Table//Paragraph");

// This expression will select any paragraphs that are direct children of any body node in the document.
nodeList = doc.selectNodes("//Body/Paragraph");

// Use SelectSingleNode to select the first result of the same expression as above.
Node node = doc.selectSingleNode("//Body/Paragraph");</pre></example>
</DL>
<HR>

<A NAME="selectSingleNode(java.lang.String)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>selectSingleNode</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>selectSingleNode</B>(java.lang.String&nbsp;xpath)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Selects the first Node that matches the XPath expression.
            </summary><remarks><p>Only expressions with element names are supported at the moment. Expressions
            that use attribute names are not supported.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="xpath"><CODE>xpath</CODE> - The XPath expression.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The first Node that matches the XPath query or null if no matching node is found.</DD></DL><example><p><b>Example:</b></p>Shows how to select certain nodes by using an XPath expression.<pre>
Document doc = new Document(getMyDir() + "Table.Document.doc");

// This expression will extract all paragraph nodes which are descendants of any table node in the document.
// This will return any paragraphs which are in a table.
NodeList nodeList = doc.selectNodes("//Table//Paragraph");

// This expression will select any paragraphs that are direct children of any body node in the document.
nodeList = doc.selectNodes("//Body/Paragraph");

// Use SelectSingleNode to select the first result of the same expression as above.
Node node = doc.selectSingleNode("//Body/Paragraph");</pre></example>
</DL>
<HR>

<A NAME="toString()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>toString</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>toString</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary />
</DL>
<HR>

<A NAME="toString(com.aspose.words.SaveOptions)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>toString</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>toString</B>(<A HREF="SaveOptions.html" title="class in com.aspose.words">SaveOptions</A>&nbsp;saveOptions)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Exports the content of the node into a string using the specified save options.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="saveOptions"><CODE>saveOptions</CODE> - Specifies the options that control how the node is saved.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The content of the node in the specified format.</DD></DL><example><p><b>Example:</b></p>Exports the content of a node to string in HTML format using custom specified options.<pre>
Document doc = new Document(getMyDir() + "Document.doc");

// Extract the last paragraph in the document to convert to HTML.
Node node = doc.getLastSection().getBody().getLastParagraph();

// Create an instance of HtmlSaveOptions and set a few options.
HtmlSaveOptions saveOptions = new HtmlSaveOptions();
saveOptions.setExportHeadersFootersMode(ExportHeadersFootersMode.PER_SECTION);
saveOptions.setExportRelativeFontSize(true);

// Convert the document to HTML and return as a string. Pass the instance of HtmlSaveOptions to
// to use the specified options during the conversion.
String nodeAsHtml = node.toString(saveOptions);</pre></example>
</DL>
<HR>

<A NAME="toString(int)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>toString</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>toString</B>(int&nbsp;saveFormat)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Exports the content of the node into a string in the specified format.
            </summary><DL><DT><B>Returns:</B></DT><DD returns="">The content of the node in the specified format.</DD></DL><DL><DT><B>Parameters:</B></DT><DD><CODE>saveFormat</CODE> - A <A HREF="SaveFormat.html" title="Utility class in com.aspose.words">SaveFormat</A> value.</DD></DL><example><p><b>Example:</b></p>Shows how to extract the label of each paragraph in a list as a value or a String.<pre>
Document doc = new Document(getMyDir() + "Lists.PrintOutAllLists.doc");
doc.updateListLabels();
int listParaCount = 1;

for (Paragraph paragraph : (Iterable&lt;Paragraph&gt;) doc.getChildNodes(NodeType.PARAGRAPH, true))
{
    // Find if we have the paragraph list. In our document our list uses plain arabic numbers,
    // which start at three and ends at six.
    if (paragraph.getListFormat().isListItem())
    {
        System.out.println(MessageFormat.format("Paragraph #{0}", listParaCount));

        // This is the text we get when actually getting when we output this node to text format.
        // The list labels are not included in this text output. Trim any paragraph formatting characters.
        String paragraphText = paragraph.toString(SaveFormat.TEXT).trim();
        System.out.println("Exported Text: " + paragraphText);

        ListLabel label = paragraph.getListLabel();
        // This gets the position of the paragraph in current level of the list. If we have a list with multiple level then this
        // will tell us what position it is on that particular level.
        System.out.println("Numerical Id: " + label.getLabelValue());

        // Combine them together to include the list label with the text in the output.
        System.out.println("List label combined with text: " + label.getLabelString() + " " + paragraphText);

        listParaCount++;
    }
}</pre></example><example><p><b>Example:</b></p>Shows the difference between calling the GetText and ToString methods on a node.<pre>
Document doc = new Document();

// Enter a dummy field into the document.
DocumentBuilder builder = new DocumentBuilder(doc);
builder.insertField("MERGEFIELD Field");

// GetText will retrieve all field codes and special characters
System.out.println("GetText() Result: " + doc.getText());

// ToString will export the node to the specified format. When converted to text it will not retrieve fields code
// or special characters, but will still contain some natural formatting characters such as paragraph markers etc.
// This is the same as "viewing" the document as if it was opened in a text editor.
System.out.println("ToString() Result: " + doc.toString(SaveFormat.TEXT));</pre></example><example><p><b>Example:</b></p>Exports the content of a node to string in HTML format using default options.<pre>
Document doc = new Document(getMyDir() + "Document.doc");

// Extract the last paragraph in the document to convert to HTML.
Node node = doc.getLastSection().getBody().getLastParagraph();

// When ToString is called using the SaveFormat overload then conversion is executed using default save options.
// When saving to HTML using default options the following settings are set:
//   ExportImagesAsBase64 = true
//   CssStyleSheetType = CssStyleSheetType.Inline
//   ExportFontResources = false
String nodeAsHtml = node.toString(SaveFormat.HTML);</pre></example>
</DL>
<HR>

<B>See Also:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Products/Aspose.Words/Api/index.html" TARGET="_blank">Aspose.Words Documentation</A> - the home page for the Aspose.Words Product Documentation.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Community/forums/ShowForum.aspx?ForumID=75" TARGET="_blank">Aspose.Words Support Forum</A> - our preferred method of support.<P>
<div class="footer"><hr><p><a href='http://www.aspose.com/Wiki/default.aspx/Aspose.Corporate/ContactAspose.html'>We guarantee a prompt response to any inquiry!</a></p><p>&copy; 2003-2007 Aspose Pty Ltd. All rights reserved.</p></div></BODY></HTML>