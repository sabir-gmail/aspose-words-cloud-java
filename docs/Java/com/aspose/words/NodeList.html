<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
><HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- Generated by javadoc - compatibility string-->
<!-- Generated by Aspose.JavaDoc 09 Aug 2018 -->
<TITLE>NodeList</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style"></HEAD>
<BODY BGCOLOR="white">
<!-- ======== START OF CLASS DATA ======== -->
<H2><a href="package-summary.html"><FONT SIZE="-1">
com.aspose.words
</FONT></a><BR>Class NodeList</H2>
<PRE>
java.lang.Object
    <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.aspose.words.NodeList</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Iterable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>NodeList </B><DT>extends java.lang.Object</DL>
</PRE>

<P>

<summary>
            Represents a collection of nodes matching an XPath query executed using the <cref><A HREF="CompositeNode.html#selectNodes(java.lang.String)" title="method in class com.aspose.words.CompositeNode">CompositeNode.selectNodes(java.lang.String)</A></cref> method.
            </summary><remarks><p><b>NodeList</b> is returned by <cref><A HREF="CompositeNode.html#selectNodes(java.lang.String)" title="method in class com.aspose.words.CompositeNode">CompositeNode.selectNodes(java.lang.String)</A></cref> and contains a collection
            of nodes matching the XPath query.</p><p><b>NodeList</b> supports indexed access and iteration.</p><blockquote class="dtBlock"><b>Note:</b>   Treat the <b>NodeList</b> collection as a "snapshot" collection. <b>NodeList</b> starts
            as a "live" collection because the nodes are not actually retrieved when the XPath query is run.
            The nodes are only retrieved upon access and at this time the node and all nodes that precede
            it are cached forming a "snapshot" collection.</blockquote></remarks><example><p><b>Example:</b></p>Finds all hyperlinks in a Word document and changes their URL and display name.<pre>
package Examples;

import org.testng.annotations.Test;
import com.aspose.words.Document;
import com.aspose.words.NodeList;
import com.aspose.words.FieldStart;
import com.aspose.words.FieldType;
import com.aspose.words.NodeType;
import com.aspose.words.Run;
import com.aspose.words.Node;

import java.util.regex.Matcher;
import java.util.regex.Pattern;


/**
 * Shows how to replace hyperlinks in a Word document.
 */
public class ExReplaceHyperlinks extends ApiExampleBase
{
    /**
     * Finds all hyperlinks in a Word document and changes their URL and display name.
     */
    public void replaceHyperlinks() throws Exception
    {
        // Specify your document name here.
        Document doc = new Document(getMyDir() + "ReplaceHyperlinks.doc");

        // Hyperlinks in a Word documents are fields, select all field start nodes so we can find the hyperlinks.
        NodeList fieldStarts = doc.selectNodes("//FieldStart");
        for (FieldStart fieldStart : (Iterable&lt;FieldStart&gt;) fieldStarts)
        {
            if (fieldStart.getFieldType() == FieldType.FIELD_HYPERLINK)
            {
                // The field is a hyperlink field, use the "facade" class to help to deal with the field.
                Hyperlink hyperlink = new Hyperlink(fieldStart);

                // Some hyperlinks can be local (links to bookmarks inside the document), ignore these.
                if (hyperlink.isLocal()) continue;

                // The Hyperlink class allows to set the target URL and the display name
                // of the link easily by setting the properties.
                hyperlink.setTarget(NEW_URL);
                hyperlink.setName(NEW_NAME);
            }
        }

        doc.save(getMyDir() + "\\Artifacts\\ReplaceHyperlinks.doc");
    }

    private static final String NEW_URL = "http://www.aspose.com";
    private static final String NEW_NAME = "Aspose - The .NET &amp; Java Component Publisher";
}


/**
 * This "facade" class makes it easier to work with a hyperlink field in a Word document.
 * &lt;p&gt;
 * A hyperlink is represented by a HYPERLINK field in a Word document. A field in Aspose.Words
 * consists of several nodes and it might be difficult to work with all those nodes directly.
 * Note this is a simple implementation and will work only if the hyperlink code and name
 * each consist of one Run only.
 * &lt;p&gt;
 * [FieldStart][Run - field code][FieldSeparator][Run - field result][FieldEnd]
 * &lt;p&gt;
 * The field code contains a String in one of these formats:
 * HYPERLINK "url"
 * HYPERLINK \l "bookmark name"
 * &lt;p&gt;
 * The field result contains text that is displayed to the user.
 */
class Hyperlink
{
    Hyperlink(FieldStart fieldStart) throws Exception
    {
        if (fieldStart == null) throw new IllegalArgumentException("fieldStart");
        if (fieldStart.getFieldType() != FieldType.FIELD_HYPERLINK)
            throw new IllegalArgumentException("Field start type must be FieldHyperlink.");

        mFieldStart = fieldStart;

        // Find the field separator node.
        mFieldSeparator = findNextSibling(mFieldStart, NodeType.FIELD_SEPARATOR);
        if (mFieldSeparator == null) throw new IllegalStateException("Cannot find field separator.");

        // Find the field end node. Normally field end will always be found, but in the example document
        // there happens to be a paragraph break included in the hyperlink and this puts the field end
        // in the next paragraph. It will be much more complicated to handle fields which span several
        // paragraphs correctly, but in this case allowing field end to be null is enough for our purposes.
        mFieldEnd = findNextSibling(mFieldSeparator, NodeType.FIELD_END);

        // Field code looks something like [ HYPERLINK "http:\\www.myurl.com" ], but it can consist of several runs.
        String fieldCode = getTextSameParent(mFieldStart.getNextSibling(), mFieldSeparator);
        Matcher matcher = G_REGEX.matcher(fieldCode.trim());
        matcher.find();
        mIsLocal = (matcher.group(1) != null) &amp;&amp; (matcher.group(1).length() &gt; 0);    //The link is local if \l is present in the field code.
        mTarget = matcher.group(2).toString();
    }

    /**
     * Gets or sets the display name of the hyperlink.
     */
    String getName() throws Exception
    {
        return getTextSameParent(mFieldSeparator, mFieldEnd);
    }

    void setName(String value) throws Exception
    {
        // Hyperlink display name is stored in the field result which is a Run
        // node between field separator and field end.
        Run fieldResult = (Run) mFieldSeparator.getNextSibling();
        fieldResult.setText(value);

        // But sometimes the field result can consist of more than one run, delete these runs.
        removeSameParent(fieldResult.getNextSibling(), mFieldEnd);
    }

    /**
     * Gets or sets the target url or bookmark name of the hyperlink.
     */
    String getTarget()
    {
        return mTarget;
    }

    void setTarget(String value) throws Exception
    {
        mTarget = value;
        updateFieldCode();
    }

    /**
     * True if the hyperlink's target is a bookmark inside the document. False if the hyperlink is a url.
     */
    boolean isLocal()
    {
        return mIsLocal;
    }

    void isLocal(boolean value) throws Exception
    {
        mIsLocal = value;
        updateFieldCode();
    }

    private void updateFieldCode() throws Exception
    {
        // Field code is stored in a Run node between field start and field separator.
        Run fieldCode = (Run) mFieldStart.getNextSibling();
        fieldCode.setText(java.text.MessageFormat.format("HYPERLINK {0}\"{1}\"", ((mIsLocal) ? "\\l " : ""), mTarget));

        // But sometimes the field code can consist of more than one run, delete these runs.
        removeSameParent(fieldCode.getNextSibling(), mFieldSeparator);
    }

    /**
     * Goes through siblings starting from the start node until it finds a node of the specified type or null.
     */
    private static Node findNextSibling(Node startNode, int nodeType)
    {
        for (Node node = startNode; node != null; node = node.getNextSibling())
        {
            if (node.getNodeType() == nodeType) return node;
        }
        return null;
    }

    /**
     * Retrieves text from start up to but not including the end node.
     */
    private static String getTextSameParent(Node startNode, Node endNode)
    {
        if ((endNode != null) &amp;&amp; (startNode.getParentNode() != endNode.getParentNode()))
            throw new IllegalArgumentException("Start and end nodes are expected to have the same parent.");

        StringBuilder builder = new StringBuilder();
        for (Node child = startNode; !child.equals(endNode); child = child.getNextSibling())
            builder.append(child.getText());

        return builder.toString();
    }

    /**
     * Removes nodes from start up to but not including the end node.
     * Start and end are assumed to have the same parent.
     */
    private static void removeSameParent(Node startNode, Node endNode)
    {
        if ((endNode != null) &amp;&amp; (startNode.getParentNode() != endNode.getParentNode()))
            throw new IllegalArgumentException("Start and end nodes are expected to have the same parent.");

        Node curChild = startNode;
        while ((curChild != null) &amp;&amp; (curChild != endNode))
        {
            Node nextChild = curChild.getNextSibling();
            curChild.remove();
            curChild = nextChild;
        }
    }

    private final Node mFieldStart;
    private final Node mFieldSeparator;
    private final Node mFieldEnd;
    private boolean mIsLocal;
    private String mTarget;

    /**
     * RK I am notoriously bad at regexes. It seems I don't understand their way of thinking.
     */
    private static final Pattern G_REGEX = Pattern.compile("\\S+" +            // one or more non spaces HYPERLINK or other word in other languages
            "\\s+" +            // one or more spaces
            "(?:\"\"\\s+)?" +    // non capturing optional "" and one or more spaces, found in one of the customers files.
            "(\\\\l\\s+)?" +    // optional \l flag followed by one or more spaces
            "\"" +                // one apostrophe
            "([^\"]+)" +        // one or more chars except apostrophe (hyperlink target)
            "\""                // one closing apostrophe
    );
}</pre></example>
<HR>
<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<P>

<!-- ========== PROPERTY SUMMARY =========== -->

<A NAME="property_summary"><!-- --></A>
<TABLE RULES="GROUPS" BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Property Getters/Setters Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#Count">getCount</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the number of nodes in the list.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#Item(int)">get</A></B>(int&nbsp;index)</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Retrieves a node at the given index.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" RULES="GROUPS" FRAME="BOX" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>Aspose.Words.Node[]</CODE></TD><TD><CODE><B><A HREF="#toArray()">toArray</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Copies all nodes from the collection to a new array of nodes.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;<P>

<!-- ============ PROPERTY DETAIL ========== -->

<A NAME="property_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Property Getters/Setters Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Count"><!-- --></A><A NAME="getCount()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getCount</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getCount</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the number of nodes in the list.
            </summary>
</DL>
<HR>

<A NAME="Item(int)"><!-- --></A><A NAME="get(int)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>get</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>get</B>(int&nbsp;index)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Retrieves a node at the given index.
            </summary><remarks><p>The index is zero-based.</p><p>Negative indexes are allowed and indicate access from the back of the collection. 
For example -1 means the last item, -2 means the second before last and so on.</p><p>If index is greater than or equal to the number of items in the list, this returns a null reference.</p><p>If index is negative and its absolute value is greater than the number of items in the list, this returns a null reference.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="index"><CODE>index</CODE> - An index into the list of nodes.</DD></DL>
</DL>
<HR>



<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="toArray()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>toArray</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public Aspose.Words.Node[]&nbsp;<B>toArray</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Copies all nodes from the collection to a new array of nodes.
            </summary><remarks><p>You should not be adding/removing nodes while iterating over a collection 
of nodes because it invalidates the iterator and requires refreshes for live collections.</p><p>To be able to add/remove nodes during iteration, use this method to copy 
nodes into a fixed-size array and then iterate over the array.</p></remarks><DL><DT><B>Returns:</B></DT><DD returns="">An array of nodes.</DD></DL>
</DL>
<HR>

<B>See Also:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Products/Aspose.Words/Api/index.html" TARGET="_blank">Aspose.Words Documentation</A> - the home page for the Aspose.Words Product Documentation.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Community/forums/ShowForum.aspx?ForumID=75" TARGET="_blank">Aspose.Words Support Forum</A> - our preferred method of support.<P>
<div class="footer"><hr><p><a href='http://www.aspose.com/Wiki/default.aspx/Aspose.Corporate/ContactAspose.html'>We guarantee a prompt response to any inquiry!</a></p><p>&copy; 2003-2007 Aspose Pty Ltd. All rights reserved.</p></div></BODY></HTML>