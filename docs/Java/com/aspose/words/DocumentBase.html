<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
><HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- Generated by javadoc - compatibility string-->
<!-- Generated by Aspose.JavaDoc 09 Aug 2018 -->
<TITLE>DocumentBase</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style"></HEAD>
<BODY BGCOLOR="white">
<!-- ======== START OF CLASS DATA ======== -->
<H2><a href="package-summary.html"><FONT SIZE="-1">
com.aspose.words
</FONT></a><BR>Class DocumentBase</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="Node.html" title="class in com.aspose.words">Node</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>
          <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.aspose.words.DocumentBase</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Iterable, java.lang.Cloneable</DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="Document.html" title="class in com.aspose.words">Document</A>, <A HREF="GlossaryDocument.html" title="class in com.aspose.words">GlossaryDocument</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>DocumentBase </B><DT>extends <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></DL>
</PRE>

<P>

<summary>
            Provides the abstract base class for a main document and a glossary document of a Word document.
            </summary><remarks><p>Aspose.Words represents a Word document as a tree of nodes. <cref><i>DocumentBase</i></cref> is a 
            root node of the tree that contains all other nodes of the document.</p><p><cref><i>DocumentBase</i></cref> also stores document-wide information such as <cref><A HREF="#Styles" title="property in class com.aspose.words.DocumentBase">Styles</A></cref> and 
            <cref><A HREF="#Lists" title="property in class com.aspose.words.DocumentBase">Lists</A></cref> that the tree nodes might refer to.</p></remarks><DL><DT><B>See Also:</B></DT><DD><cref seealso=""><A HREF="Document.html" title="class in com.aspose.words">Document</A></cref>, <cref seealso=""><i>DocumentBase</i></cref></DD></DL>
<HR>
<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<P>

<!-- ========== PROPERTY SUMMARY =========== -->

<A NAME="property_summary"><!-- --></A>
<TABLE RULES="GROUPS" BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Property Getters/Setters Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Shape.html" title="class in com.aspose.words">Shape</A></CODE></TD><TD><CODE><B><A HREF="#BackgroundShape">getBackgroundShape</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#BackgroundShape">setBackgroundShape</A></B>(<A HREF="Shape.html" title="class in com.aspose.words">Shape</A>&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets the background shape of the document. Can be null.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="NodeCollection.html" title="class in com.aspose.words">NodeCollection</A></CODE></TD><TD><CODE><B><A HREF="#ChildNodes">getChildNodes</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Gets all immediate child nodes of this node.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#Count">getCount</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the number of immediate children of this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A></CODE></TD><TD><CODE><B><A HREF="#Document">getDocument</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the document to which this node belongs.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#FirstChild">getFirstChild</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first child of the node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="FontInfoCollection.html" title="class in com.aspose.words">FontInfoCollection</A></CODE></TD><TD><CODE><B><A HREF="#FontInfos">getFontInfos</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Provides access to properties of fonts used in this document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#HasChildNodes">hasChildNodes</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns true if this node has any child nodes.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsComposite">isComposite</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns true as this node can have child nodes.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#LastChild">getLastChild</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the last child of the node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="ListCollection.html" title="class in com.aspose.words">ListCollection</A></CODE></TD><TD><CODE><B><A HREF="#Lists">getLists</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Provides access to the list formatting used in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#NextSibling">getNextSibling</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node immediately following this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="INodeChangingCallback.html" title="interface in com.aspose.words">INodeChangingCallback</A></CODE></TD><TD><CODE><B><A HREF="#NodeChangingCallback">getNodeChangingCallback</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#NodeChangingCallback">setNodeChangingCallback</A></B>(<A HREF="INodeChangingCallback.html" title="interface in com.aspose.words">INodeChangingCallback</A>&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a node is inserted or removed in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>abstract&nbsp;int</CODE></TD><TD><CODE><B><A HREF="#NodeType">getNodeType</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the type of this node.
            The value of the property is <A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.awt.Color</CODE></TD><TD><CODE><B><A HREF="#PageColor">getPageColor</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#PageColor">setPageColor</A></B>(java.awt.Color&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets the page color of the document. This property is a simpler version of <cref><A HREF="#BackgroundShape" title="property in class com.aspose.words.DocumentBase">BackgroundShape</A></cref>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#ParentNode">getParentNode</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the immediate parent of this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#PreviousSibling">getPreviousSibling</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node immediately preceding this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Range.html" title="class in com.aspose.words">Range</A></CODE></TD><TD><CODE><B><A HREF="#Range">getRange</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a <b>Range</b> object that represents the portion of a document that is contained in this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="IResourceLoadingCallback.html" title="interface in com.aspose.words">IResourceLoadingCallback</A></CODE></TD><TD><CODE><B><A HREF="#ResourceLoadingCallback">getResourceLoadingCallback</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#ResourceLoadingCallback">setResourceLoadingCallback</A></B>(<A HREF="IResourceLoadingCallback.html" title="interface in com.aspose.words">IResourceLoadingCallback</A>&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Allows to control how external resources are loaded.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="StyleCollection.html" title="class in com.aspose.words">StyleCollection</A></CODE></TD><TD><CODE><B><A HREF="#Styles">getStyles</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a collection of styles defined in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="IWarningCallback.html" title="interface in com.aspose.words">IWarningCallback</A></CODE></TD><TD><CODE><B><A HREF="#WarningCallback">getWarningCallback</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#WarningCallback">setWarningCallback</A></B>(<A HREF="IWarningCallback.html" title="interface in com.aspose.words">IWarningCallback</A>&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called during various document processing procedures when an issue is detected that might result 
            in data or formatting fidelity loss.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" RULES="GROUPS" FRAME="BOX" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>abstract&nbsp;boolean</CODE></TD><TD><CODE><B><A HREF="#accept(com.aspose.words.DocumentVisitor)">accept</A></B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Accepts a visitor.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#appendChild(com.aspose.words.Node)">appendChild</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;newChild)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Adds the specified node to the end of the list of child nodes for this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#deepClone(boolean)">deepClone</A></B>(boolean&nbsp;isCloneChildren)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#getAncestor(int)">getAncestor</A></B>(int&nbsp;ancestorType)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first ancestor of the specified <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#getAncestor(java.lang.Class)">getAncestor</A></B>(java.lang.Class&nbsp;ancestorType)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first ancestor of the specified object type.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#getChild(int,int,boolean)">getChild</A></B>(int&nbsp;nodeType, int&nbsp;index, boolean&nbsp;isDeep)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns an Nth child node that matches the specified type.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="NodeCollection.html" title="class in com.aspose.words">NodeCollection</A></CODE></TD><TD><CODE><B><A HREF="#getChildNodes(int,boolean)">getChildNodes</A></B>(int&nbsp;nodeType, boolean&nbsp;isDeep)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Returns a live collection of child nodes that match the specified type.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#getText()">getText</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Gets the text of this node and of all its children.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#importNode(com.aspose.words.Node,boolean)">importNode</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;srcNode, boolean&nbsp;isImportChildren)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<p>Imports a node from another document to the current document.</p></TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#importNode(com.aspose.words.Node,boolean,int)">importNode</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;srcNode, boolean&nbsp;isImportChildren, int&nbsp;importFormatMode)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<p>Imports a node from another document to the current document with an option to control formatting.</p></TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#indexOf(com.aspose.words.Node)">indexOf</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;child)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns the index of the specified child node in the child node array.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#insertAfter(com.aspose.words.Node,com.aspose.words.Node)">insertAfter</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;newChild, <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;refChild)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Inserts the specified node immediately after the specified reference node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#insertBefore(com.aspose.words.Node,com.aspose.words.Node)">insertBefore</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;newChild, <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;refChild)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Inserts the specified node immediately before the specified reference node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#nextPreOrder(com.aspose.words.Node)">nextPreOrder</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets next node according to the pre-order tree traversal algorithm.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#prependChild(com.aspose.words.Node)">prependChild</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;newChild)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Adds the specified node to the beginning of the list of child nodes for this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#previousPreOrder(com.aspose.words.Node)">previousPreOrder</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the previous node according to the pre-order tree traversal algorithm.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#remove()">remove</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes itself from the parent.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#removeAllChildren()">removeAllChildren</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes all the child nodes of the current node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#removeChild(com.aspose.words.Node)">removeChild</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;oldChild)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes the specified child node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#removeSmartTags()">removeSmartTags</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes all <cref><A HREF="SmartTag.html" title="class in com.aspose.words">SmartTag</A></cref> descendant nodes of the current node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="NodeList.html" title="class in com.aspose.words">NodeList</A></CODE></TD><TD><CODE><B><A HREF="#selectNodes(java.lang.String)">selectNodes</A></B>(java.lang.String&nbsp;xpath)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Selects a list of nodes matching the XPath expression.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#selectSingleNode(java.lang.String)">selectSingleNode</A></B>(java.lang.String&nbsp;xpath)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Selects the first Node that matches the XPath expression.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#toString(com.aspose.words.SaveOptions)">toString</A></B>(<A HREF="SaveOptions.html" title="class in com.aspose.words">SaveOptions</A>&nbsp;saveOptions)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Exports the content of the node into a string using the specified save options.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#toString(int)">toString</A></B>(int&nbsp;saveFormat)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Exports the content of the node into a string in the specified format.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;<P>

<!-- ============ PROPERTY DETAIL ========== -->

<A NAME="property_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Property Getters/Setters Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="BackgroundShape"><!-- --></A><A NAME="getBackgroundShape()"><!-- --></A><A NAME="setBackgroundShape(com.aspose.words.Shape)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getBackgroundShape/setBackgroundShape</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Shape.html" title="class in com.aspose.words">Shape</A>&nbsp;<B>getBackgroundShape</B>()&nbsp;/&nbsp;public void&nbsp;<B>setBackgroundShape</B>(<A HREF="Shape.html" title="class in com.aspose.words">Shape</A>&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets the background shape of the document. Can be null.
            </summary><remarks><p>Microsoft Word allows only a shape that has its <cref><A HREF="ShapeBase.html#ShapeType" title="property in class com.aspose.words.ShapeBase">ShapeBase.ShapeType</A></cref> property equal 
            to <cref><A HREF="ShapeType.html#RECTANGLE" title="field in class com.aspose.words.ShapeType">ShapeType.RECTANGLE</A></cref> to be used as a background shape for a document.</p><p>Microsoft Word supports only the fill properties of a background shape. All other properties
            are ignored.</p><p>Setting this property to a non-null value will also set the <cref><A HREF="ViewOptions.html#DisplayBackgroundShape" title="property in class com.aspose.words.ViewOptions">ViewOptions.DisplayBackgroundShape</A></cref> to true.</p></remarks><DL><DT><B>See Also:</B></DT><DD><cref seealso=""><A HREF="ViewOptions.html#DisplayBackgroundShape" title="property in class com.aspose.words.ViewOptions">ViewOptions.DisplayBackgroundShape</A></cref>, <cref seealso=""><A HREF="#PageColor" title="property in class com.aspose.words.DocumentBase">PageColor</A></cref></DD></DL>
</DL>
<HR>

<A NAME="ChildNodes"><!-- --></A><A NAME="getChildNodes()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getChildNodes</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="NodeCollection.html" title="class in com.aspose.words">NodeCollection</A>&nbsp;<B>getChildNodes</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Gets all immediate child nodes of this node.
             </summary><remarks><p>Note, <cref><A HREF="#ChildNodes" title="property in class com.aspose.words.DocumentBase">ChildNodes</A></cref> is equivalent to calling <code>GetChildNodes(NodeType.Any, false)</code>
             and creates and returns a new collection every time it is accessed.</p><p>If there are no child nodes, this property returns an empty collection.</p></remarks><example><p><b>Example:</b></p>Shows how to enumerate immediate children of a CompositeNode using the enumerator provided by the ChildNodes collection.<pre>
NodeCollection children = paragraph.getChildNodes();
for (Node child : (Iterable&lt;Node&gt;) children)
{
    // Paragraph may contain children of various types such as runs, shapes and so on.
    if (child.getNodeType() == NodeType.RUN)
    {
        // Say we found the node that we want, do something useful.
        Run run = (Run) child;
        System.out.println(run.getText());
    }
}</pre></example>
</DL>
<HR>

<A NAME="Count"><!-- --></A><A NAME="getCount()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getCount</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getCount</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the number of immediate children of this node.
            </summary>
</DL>
<HR>

<A NAME="Document"><!-- --></A><A NAME="getDocument()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getDocument</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A>&nbsp;<B>getDocument</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the document to which this node belongs.
            </summary><remarks><p>The node always belongs to a document even if it has just been created
            and not yet added to the tree, or if it has been removed from the tree.</p></remarks><example><p><b>Example:</b></p>Shows that when you create any node, it requires a document that will own the node.<pre>
// Open a file from disk.
Document doc = new Document();

// Creating a new node of any type requires a document passed into the constructor.
Paragraph para = new Paragraph(doc);

// The new paragraph node does not yet have a parent.
System.out.println("Paragraph has no parent node: " + (para.getParentNode() == null));

// But the paragraph node knows its document.
System.out.println("Both nodes' documents are the same: " + (para.getDocument() == doc));

// The fact that a node always belongs to a document allows us to access and modify
// properties that reference the document-wide data such as styles or lists.
para.getParagraphFormat().setStyleName("Heading 1");

// Now add the paragraph to the main text of the first section.
doc.getFirstSection().getBody().appendChild(para);

// The paragraph node is now a child of the Body node.
System.out.println("Paragraph has a parent node: " + (para.getParentNode() != null));</pre></example>
</DL>
<HR>

<A NAME="FirstChild"><!-- --></A><A NAME="getFirstChild()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFirstChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getFirstChild</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first child of the node.
            </summary><remarks>
            If there is no first child node, a null is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to enumerate immediate child nodes of a composite node using NextSibling. In this example we enumerate all paragraphs of a section body.<pre>
// Get the section that we want to work on.
Section section = doc.getSections().get(0);
Body body = section.getBody();

// Loop starting from the first child until we reach null.
for (Node node = body.getFirstChild(); node != null; node = node.getNextSibling())
{
    // Output the types of the nodes that we come across.
    System.out.println(Node.nodeTypeToString(node.getNodeType()));
}</pre></example><example><p><b>Example:</b></p>Shows how to efficiently visit all direct and indirect children of a composite node.<pre>
public void recurseAllNodes() throws Exception
{
    // Open a document.
    Document doc = new Document(getMyDir() + "Node.RecurseAllNodes.doc");

    // Invoke the recursive function that will walk the tree.
    traverseAllNodes(doc);
}

/**
 * A simple function that will walk through all children of a specified node recursively
 * and print the type of each node to the screen.
 */
public void traverseAllNodes(CompositeNode parentNode)
{
    // This is the most efficient way to loop through immediate children of a node.
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling())
    {
        // Do some useful work.
        System.out.println(Node.nodeTypeToString(childNode.getNodeType()));

        // Recurse into the node if it is a composite node.
        if (childNode.isComposite()) traverseAllNodes((CompositeNode) childNode);
    }
}</pre></example>
</DL>
<HR>

<A NAME="FontInfos"><!-- --></A><A NAME="getFontInfos()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFontInfos</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="FontInfoCollection.html" title="class in com.aspose.words">FontInfoCollection</A>&nbsp;<B>getFontInfos</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Provides access to properties of fonts used in this document.
            </summary><remarks><p>This collection of font definitions is loaded as is from the document. 
            Font definitions might be optional, missing or incomplete in some documents.</p><p>Do not rely on this collection to ascertain that a particular font is used in the document.
            You should only use this collection to get information about fonts that might be used in the document.</p></remarks><example><p><b>Example:</b></p>Shows how to save a document with embedded TrueType fonts<pre>
Document doc = new Document(getMyDir() + "Document.docx");

FontInfoCollection fontInfos = doc.getFontInfos();
fontInfos.setEmbedTrueTypeFonts(true);
fontInfos.setEmbedSystemFonts(false);
fontInfos.setSaveSubsetFonts(false);

doc.save(getMyDir() + "/Artifacts/Document.docx");</pre></example><example><p><b>Example:</b></p>Shows how to gather the details of what fonts are present in a document.<pre>
Document doc = new Document(getMyDir() + "Document.doc");

FontInfoCollection fonts = doc.getFontInfos();
int fontIndex = 1;

// The fonts info extracted from this document does not necessarily mean that the fonts themselves are
// used in the document. If a font is present but not used then most likely they were referenced at some time
// and then removed from the Document.
for (FontInfo info : fonts)
{
    // Print out some important details about the font.
    System.out.println(MessageFormat.format("Font #{0}", fontIndex));
    System.out.println(MessageFormat.format("Name: {0}", info.getName()));
    System.out.println(MessageFormat.format("IsTrueType: {0}", info.isTrueType()));
    fontIndex++;
}</pre></example><DL><DT><B>See Also:</B></DT><DD><cref seealso=""><A HREF="FontInfoCollection.html" title="class in com.aspose.words">FontInfoCollection</A></cref>, <cref seealso=""><A HREF="FontInfo.html" title="class in com.aspose.words">FontInfo</A></cref></DD></DL>
</DL>
<HR>

<A NAME="HasChildNodes"><!-- --></A><A NAME="hasChildNodes()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>hasChildNodes</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>hasChildNodes</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns true if this node has any child nodes.
            </summary><example><p><b>Example:</b></p>Demonstrates how to use the InsertDocument method to insert a document into a merge field during mail merge.<pre>
public void insertDocumentAtMailMerge() throws Exception
{
    // Open the main document.
    Document mainDoc = new Document(getMyDir() + "InsertDocument1.doc");

    // Add a handler to MergeField event
    mainDoc.getMailMerge().setFieldMergingCallback(new InsertDocumentAtMailMergeHandler());

    // The main document has a merge field in it called "Document_1".
    // The corresponding data for this field contains fully qualified path to the document
    // that should be inserted to this field.
    mainDoc.getMailMerge().execute(new String[]{"Document_1"}, new String[]{getMyDir() + "InsertDocument2.doc"});

    mainDoc.save(getMyDir() + "\\Artifacts\\InsertDocumentAtMailMerge.doc");
}

private class InsertDocumentAtMailMergeHandler implements IFieldMergingCallback
{
    /**
     * This handler makes special processing for the "Document_1" field.
     * The field value contains the path to load the document.
     * We load the document and insert it into the current merge field.
     */
    public void fieldMerging(FieldMergingArgs e) throws Exception
    {
        if ("Document_1".equals(e.getDocumentFieldName()))
        {
            // Use document builder to navigate to the merge field with the specified name.
            DocumentBuilder builder = new DocumentBuilder(e.getDocument());
            builder.moveToMergeField(e.getDocumentFieldName());

            // The name of the document to load and insert is stored in the field value.
            Document subDoc = new Document((String) e.getFieldValue());

            // Insert the document.
            insertDocument(builder.getCurrentParagraph(), subDoc);

            // The paragraph that contained the merge field might be empty now and you probably want to delete it.
            if (!builder.getCurrentParagraph().hasChildNodes()) builder.getCurrentParagraph().remove();

            // Indicate to the mail merge engine that we have inserted what we wanted.
            e.setText(null);
        }
    }

    public void imageFieldMerging(ImageFieldMergingArgs args)
    {
        // Do nothing.
    }
}</pre></example>
</DL>
<HR>

<A NAME="IsComposite"><!-- --></A><A NAME="isComposite()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isComposite</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isComposite</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns true as this node can have child nodes.
            </summary><example><p><b>Example:</b></p>Shows how to efficiently visit all direct and indirect children of a composite node.<pre>
public void recurseAllNodes() throws Exception
{
    // Open a document.
    Document doc = new Document(getMyDir() + "Node.RecurseAllNodes.doc");

    // Invoke the recursive function that will walk the tree.
    traverseAllNodes(doc);
}

/**
 * A simple function that will walk through all children of a specified node recursively
 * and print the type of each node to the screen.
 */
public void traverseAllNodes(CompositeNode parentNode)
{
    // This is the most efficient way to loop through immediate children of a node.
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling())
    {
        // Do some useful work.
        System.out.println(Node.nodeTypeToString(childNode.getNodeType()));

        // Recurse into the node if it is a composite node.
        if (childNode.isComposite()) traverseAllNodes((CompositeNode) childNode);
    }
}</pre></example>
</DL>
<HR>

<A NAME="LastChild"><!-- --></A><A NAME="getLastChild()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getLastChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getLastChild</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the last child of the node.
            </summary><remarks>
            If there is no last child node, a null is returned.
            </remarks><example><p><b>Example:</b></p>Demonstrates use of methods of Node and CompositeNode to remove a section before the last section in the document.<pre>
// Document is a CompositeNode and LastChild returns the last child node in the Document node.
// Since the Document can contain only Section nodes, the last child is the last section.
Node lastSection = doc.getLastChild();

// Each node knows its next and previous sibling nodes.
// Previous sibling of a section is a section before the specified section.
// If the node is the first child, PreviousSibling will return null.
Node sectionBeforeLast = lastSection.getPreviousSibling();

if (sectionBeforeLast != null) doc.removeChild(sectionBeforeLast);</pre></example>
</DL>
<HR>

<A NAME="Lists"><!-- --></A><A NAME="getLists()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getLists</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="ListCollection.html" title="class in com.aspose.words">ListCollection</A>&nbsp;<B>getLists</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Provides access to the list formatting used in the document.
            </summary><remarks><p>For more information see the description of the <cref><A HREF="ListCollection.html" title="class in com.aspose.words">ListCollection</A></cref> class.</p></remarks><example><p><b>Example:</b></p>Shows how to specify list level number when building a list using DocumentBuilder.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create a numbered list based on one of the Microsoft Word list templates and
// apply it to the current paragraph in the document builder.
builder.getListFormat().setList(doc.getLists().add(ListTemplate.NUMBER_ARABIC_DOT));

// There are 9 levels in this list, lets try them all.
for (int i = 0; i &lt; 9; i++)
{
    builder.getListFormat().setListLevelNumber(i);
    builder.writeln("Level " + i);
}

// Create a bulleted list based on one of the Microsoft Word list templates
// and apply it to the current paragraph in the document builder.
builder.getListFormat().setList(doc.getLists().add(ListTemplate.BULLET_DIAMONDS));

// There are 9 levels in this list, lets try them all.
for (int i = 0; i &lt; 9; i++)
{
    builder.getListFormat().setListLevelNumber(i);
    builder.writeln("Level " + i);
}

// This is a way to stop list formatting.
builder.getListFormat().setList(null);

builder.getDocument().save(getMyDir() + "\\Artifacts\\Lists.SpecifyListLevel.doc");</pre></example><DL><DT><B>See Also:</B></DT><DD><cref seealso=""><A HREF="ListCollection.html" title="class in com.aspose.words">ListCollection</A></cref>, <cref seealso=""><A HREF="List.html" title="class in com.aspose.words">List</A></cref>, <cref seealso=""><A HREF="ListFormat.html" title="class in com.aspose.words">ListFormat</A></cref></DD></DL>
</DL>
<HR>

<A NAME="NextSibling"><!-- --></A><A NAME="getNextSibling()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNextSibling</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getNextSibling</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node immediately following this node.
            </summary><remarks>
            If there is no next node, a null is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to enumerate immediate child nodes of a composite node using NextSibling. In this example we enumerate all paragraphs of a section body.<pre>
// Get the section that we want to work on.
Section section = doc.getSections().get(0);
Body body = section.getBody();

// Loop starting from the first child until we reach null.
for (Node node = body.getFirstChild(); node != null; node = node.getNextSibling())
{
    // Output the types of the nodes that we come across.
    System.out.println(Node.nodeTypeToString(node.getNodeType()));
}</pre></example><example><p><b>Example:</b></p>Shows how to efficiently visit all direct and indirect children of a composite node.<pre>
public void recurseAllNodes() throws Exception
{
    // Open a document.
    Document doc = new Document(getMyDir() + "Node.RecurseAllNodes.doc");

    // Invoke the recursive function that will walk the tree.
    traverseAllNodes(doc);
}

/**
 * A simple function that will walk through all children of a specified node recursively
 * and print the type of each node to the screen.
 */
public void traverseAllNodes(CompositeNode parentNode)
{
    // This is the most efficient way to loop through immediate children of a node.
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling())
    {
        // Do some useful work.
        System.out.println(Node.nodeTypeToString(childNode.getNodeType()));

        // Recurse into the node if it is a composite node.
        if (childNode.isComposite()) traverseAllNodes((CompositeNode) childNode);
    }
}</pre></example>
</DL>
<HR>

<A NAME="NodeChangingCallback"><!-- --></A><A NAME="getNodeChangingCallback()"><!-- --></A><A NAME="setNodeChangingCallback(com.aspose.words.INodeChangingCallback)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNodeChangingCallback/setNodeChangingCallback</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="INodeChangingCallback.html" title="interface in com.aspose.words">INodeChangingCallback</A>&nbsp;<B>getNodeChangingCallback</B>()&nbsp;/&nbsp;public void&nbsp;<B>setNodeChangingCallback</B>(<A HREF="INodeChangingCallback.html" title="interface in com.aspose.words">INodeChangingCallback</A>&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a node is inserted or removed in the document.
            </summary><example><p><b>Example:</b></p>Shows how to implement custom logic over node insertion in the document by changing the font of inserted HTML content.<pre>
public void testNodeChangingInDocument() throws Exception
{
    // Create a blank document object
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // Set up and pass the object which implements the handler methods.
    doc.setNodeChangingCallback(new HandleNodeChanging_FontChanger());

    // Insert sample HTML content
    builder.insertHtml("&lt;p&gt;Hello World&lt;/p&gt;");

    doc.save(getMyDir() + "\\Artifacts\\Document.FontChanger.doc");

    // Check that the inserted content has the correct formatting
    Run run = (Run) doc.getChild(NodeType.RUN, 0, true);
    Assert.assertEquals(run.getFont().getSize(), 24.0);
    Assert.assertEquals(run.getFont().getName(), "Arial");
}

public class HandleNodeChanging_FontChanger implements INodeChangingCallback
{
    // Implement the NodeInserted handler to set default font settings for every Run node inserted into the Document
    public void nodeInserted(NodeChangingArgs args)
    {
        // Change the font of inserted text contained in the Run nodes.
        if (args.getNode().getNodeType() == NodeType.RUN)
        {
            Font font = ((Run) args.getNode()).getFont();
            font.setSize(24);
            font.setName("Arial");
        }
    }

    public void nodeInserting(NodeChangingArgs args)
    {
        // Do Nothing
    }

    public void nodeRemoved(NodeChangingArgs args)
    {
        // Do Nothing
    }

    public void nodeRemoving(NodeChangingArgs args)
    {
        // Do Nothing
    }
}</pre></example>
</DL>
<HR>

<A NAME="NodeType"><!-- --></A><A NAME="getNodeType()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNodeType</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public abstract&nbsp;int&nbsp;<B>getNodeType</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the type of this node.
            The value of the property is <A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A> integer constant.</summary><example><p><b>Example:</b></p>Shows how to enumerate immediate child nodes of a composite node using NextSibling. In this example we enumerate all paragraphs of a section body.<pre>
// Get the section that we want to work on.
Section section = doc.getSections().get(0);
Body body = section.getBody();

// Loop starting from the first child until we reach null.
for (Node node = body.getFirstChild(); node != null; node = node.getNextSibling())
{
    // Output the types of the nodes that we come across.
    System.out.println(Node.nodeTypeToString(node.getNodeType()));
}</pre></example><example><p><b>Example:</b></p>Shows how to remove all nodes of a specific type from a composite node. In this example we remove tables from a section body.<pre>
// Get the section that we want to work on.
Section section = doc.getSections().get(0);
Body body = section.getBody();

// Select the first child node in the body.
Node curNode = body.getFirstChild();

while (curNode != null)
{
    // Save the pointer to the next sibling node because if the current
    // node is removed from the parent in the next step, we will have
    // no way of finding the next node to continue the loop.
    Node nextNode = curNode.getNextSibling();

    // A section body can contain Paragraph and Table nodes.
    // If the node is a Table, remove it from the parent.
    if (curNode.getNodeType() == NodeType.TABLE) curNode.remove();

    // Continue going through child nodes until null (no more siblings) is reached.
    curNode = nextNode;
}</pre></example><example><p><b>Example:</b></p>Shows how to retrieve the NodeType enumeration of nodes.<pre>
Document doc = new Document(getMyDir() + "Document.doc");

// Let's pick a node that we can't be quite sure of what type it is.
// In this case lets pick the first node of the first paragraph in the body of the document
Node node = doc.getFirstSection().getBody().getFirstParagraph().getFirstChild();
System.out.println("NodeType of first child: " + Node.nodeTypeToString(node.getNodeType()));

// This time let's pick a node that we know the type of. Create a new paragraph and a table node.
Paragraph para = new Paragraph(doc);
Table table = new Table(doc);

// Access to NodeType for typed nodes will always return their specific NodeType.
// i.e A paragraph node will always return NodeType.Paragraph, a table node will always return NodeType.Table.
System.out.println("NodeType of Paragraph: " + Node.nodeTypeToString(para.getNodeType()));
System.out.println("NodeType of Table: " + Node.nodeTypeToString(table.getNodeType()));</pre></example>
</DL>
<HR>

<A NAME="PageColor"><!-- --></A><A NAME="getPageColor()"><!-- --></A><A NAME="setPageColor(java.awt.Color)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getPageColor/setPageColor</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.awt.Color&nbsp;<B>getPageColor</B>()&nbsp;/&nbsp;public void&nbsp;<B>setPageColor</B>(java.awt.Color&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets the page color of the document. This property is a simpler version of <cref><A HREF="#BackgroundShape" title="property in class com.aspose.words.DocumentBase">BackgroundShape</A></cref>.
            </summary><remarks><p>This property provides a simple way to specify a solid page color for the document.
            Setting this property creates and sets an appropriate <cref><A HREF="#BackgroundShape" title="property in class com.aspose.words.DocumentBase">BackgroundShape</A></cref>.</p><p>If the page color is not set (e.g. there is no background shape in the document) returns 
            a zero color.</p></remarks><DL><DT><B>See Also:</B></DT><DD><cref seealso=""><A HREF="#BackgroundShape" title="property in class com.aspose.words.DocumentBase">BackgroundShape</A></cref></DD></DL>
</DL>
<HR>

<A NAME="ParentNode"><!-- --></A><A NAME="getParentNode()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getParentNode</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getParentNode</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the immediate parent of this node.
            </summary><remarks><p>If a node has just been created and not yet added to the tree,
            or if it has been removed from the tree, the parent is null.</p></remarks><example><p><b>Example:</b></p>Shows how to access the parent node.<pre>
// Create a new empty document. It has one section.
Document doc = new Document();

// The section is the first child node of the document.
Node section = doc.getFirstChild();

// The section's parent node is the document.
System.out.println("Section parent is the document: " + (doc == section.getParentNode()));</pre></example><example><p><b>Example:</b></p>Shows that when you create any node, it requires a document that will own the node.<pre>
// Open a file from disk.
Document doc = new Document();

// Creating a new node of any type requires a document passed into the constructor.
Paragraph para = new Paragraph(doc);

// The new paragraph node does not yet have a parent.
System.out.println("Paragraph has no parent node: " + (para.getParentNode() == null));

// But the paragraph node knows its document.
System.out.println("Both nodes' documents are the same: " + (para.getDocument() == doc));

// The fact that a node always belongs to a document allows us to access and modify
// properties that reference the document-wide data such as styles or lists.
para.getParagraphFormat().setStyleName("Heading 1");

// Now add the paragraph to the main text of the first section.
doc.getFirstSection().getBody().appendChild(para);

// The paragraph node is now a child of the Body node.
System.out.println("Paragraph has a parent node: " + (para.getParentNode() != null));</pre></example>
</DL>
<HR>

<A NAME="PreviousSibling"><!-- --></A><A NAME="getPreviousSibling()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getPreviousSibling</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getPreviousSibling</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node immediately preceding this node.
            </summary><remarks>
            If there is no preceding node, a null is returned.
            </remarks><example><p><b>Example:</b></p>Demonstrates use of methods of Node and CompositeNode to remove a section before the last section in the document.<pre>
// Document is a CompositeNode and LastChild returns the last child node in the Document node.
// Since the Document can contain only Section nodes, the last child is the last section.
Node lastSection = doc.getLastChild();

// Each node knows its next and previous sibling nodes.
// Previous sibling of a section is a section before the specified section.
// If the node is the first child, PreviousSibling will return null.
Node sectionBeforeLast = lastSection.getPreviousSibling();

if (sectionBeforeLast != null) doc.removeChild(sectionBeforeLast);</pre></example>
</DL>
<HR>

<A NAME="Range"><!-- --></A><A NAME="getRange()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getRange</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Range.html" title="class in com.aspose.words">Range</A>&nbsp;<B>getRange</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a <b>Range</b> object that represents the portion of a document that is contained in this node.
            </summary><example><p><b>Example:</b></p>Shows how to delete all characters of a range.<pre>
// Open Word document.
Document doc = new Document(getMyDir() + "Range.DeleteSection.doc");

// The document contains two sections. Each section has a paragraph of text.
System.out.println(doc.getText());

// Delete the first section from the document.
doc.getSections().get(0).getRange().delete();

// Check the first section was deleted by looking at the text of the whole document again.
System.out.println(doc.getText());</pre></example>
</DL>
<HR>

<A NAME="ResourceLoadingCallback"><!-- --></A><A NAME="getResourceLoadingCallback()"><!-- --></A><A NAME="setResourceLoadingCallback(com.aspose.words.IResourceLoadingCallback)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getResourceLoadingCallback/setResourceLoadingCallback</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="IResourceLoadingCallback.html" title="interface in com.aspose.words">IResourceLoadingCallback</A>&nbsp;<B>getResourceLoadingCallback</B>()&nbsp;/&nbsp;public void&nbsp;<B>setResourceLoadingCallback</B>(<A HREF="IResourceLoadingCallback.html" title="interface in com.aspose.words">IResourceLoadingCallback</A>&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Allows to control how external resources are loaded.
            </summary>
</DL>
<HR>

<A NAME="Styles"><!-- --></A><A NAME="getStyles()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getStyles</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="StyleCollection.html" title="class in com.aspose.words">StyleCollection</A>&nbsp;<B>getStyles</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a collection of styles defined in the document.
            </summary><remarks><p>For more information see the description of the <cref><A HREF="StyleCollection.html" title="class in com.aspose.words">StyleCollection</A></cref> class.</p></remarks><example><p><b>Example:</b></p>Shows how to get access to the collection of styles defined in the document.<pre>
Document doc = new Document();
StyleCollection styles = doc.getStyles();

for (Style style : styles)
    System.out.println(style.getName());</pre></example><example><p><b>Example:</b></p>Shows how to create and use a paragraph style with list formatting.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create a paragraph style and specify some formatting for it.
Style style = doc.getStyles().add(StyleType.PARAGRAPH, "MyStyle1");
style.getFont().setSize(24);
style.getFont().setName("Verdana");
style.getParagraphFormat().setSpaceAfter(12);

// Create a list and make sure the paragraphs that use this style will use this list.
style.getListFormat().setList(doc.getLists().add(ListTemplate.BULLET_DEFAULT));
style.getListFormat().setListLevelNumber(0);

// Apply the paragraph style to the current paragraph in the document and add some text.
builder.getParagraphFormat().setStyle(style);
builder.writeln("Hello World: MyStyle1, bulleted.");

// Change to a paragraph style that has no list formatting.
builder.getParagraphFormat().setStyle(doc.getStyles().get("Normal"));
builder.writeln("Hello World: Normal.");

builder.getDocument().save(getMyDir() + "\\Artifacts\\Lists.ParagraphStyleBulleted.doc");</pre></example><DL><DT><B>See Also:</B></DT><DD><cref seealso=""><A HREF="StyleCollection.html" title="class in com.aspose.words">StyleCollection</A></cref>, <cref seealso=""><A HREF="Style.html" title="class in com.aspose.words">Style</A></cref></DD></DL>
</DL>
<HR>

<A NAME="WarningCallback"><!-- --></A><A NAME="getWarningCallback()"><!-- --></A><A NAME="setWarningCallback(com.aspose.words.IWarningCallback)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getWarningCallback/setWarningCallback</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="IWarningCallback.html" title="interface in com.aspose.words">IWarningCallback</A>&nbsp;<B>getWarningCallback</B>()&nbsp;/&nbsp;public void&nbsp;<B>setWarningCallback</B>(<A HREF="IWarningCallback.html" title="interface in com.aspose.words">IWarningCallback</A>&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called during various document processing procedures when an issue is detected that might result 
            in data or formatting fidelity loss.
            </summary><remarks>
            Document may generate warnings at any stage of its existence, so it's important to setup warning callback as
            early as possible to avoid the warnings loss. E.g. such properties as <cref><A HREF="Document.html#PageCount" title="property in class com.aspose.words.Document">Document.PageCount</A></cref>
            actually build the document layout which is used later for rendering, and the layout warnings may be lost if
            warning callback is specified just for the rendering calls later.
            </remarks><example><p><b>Example:</b></p>Demonstrates how to implement the IWarningCallback to be notified of any font substitution during document save.<pre>
public static class HandleDocumentWarnings implements IWarningCallback
{
    /// &lt;summary&gt;
    /// Our callback only needs to implement the "Warning" method. This method is called whenever there is a
    /// potential issue during document processing. The callback can be set to listen for warnings generated during document
    /// load and/or document save.
    /// &lt;/summary&gt;
    public void warning(WarningInfo info)
    {
        // We are only interested in fonts being substituted.
        if (info.getWarningType() == WarningType.FONT_SUBSTITUTION)
        {
            System.out.println("Font substitution: " + info.getDescription());
        }
    }

}</pre></example><example><p><b>Example:</b></p>Demonstrates how to receive notifications of font substitutions by using IWarningCallback.<pre>
// Load the document to render.
Document doc = new Document(getMyDir() + "Document.doc");

// Create a new class implementing IWarningCallback and assign it to the PdfSaveOptions class.
HandleDocumentWarnings callback = new HandleDocumentWarnings();
doc.setWarningCallback(callback);

// We can choose the default font to use in the case of any missing fonts.
FontSettings.getDefaultInstance().setDefaultFontName("Arial");

// For testing we will set Aspose.Words to look for fonts only in a folder which doesn't exist. Since Aspose.Words won't
// find any fonts in the specified directory, then during rendering the fonts in the document will be substituted with the default 
// font specified under FontSettings.DefaultFontName. We can pick up on this substitution using our callback.
FontSettings.getDefaultInstance().setFontsFolder("", false);

// Pass the save options along with the save path to the save method.
doc.save(getMyDir() + "\\Artifacts\\Rendering.MissingFontNotification.pdf");</pre></example>
</DL>
<HR>



<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="accept(com.aspose.words.DocumentVisitor)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>accept</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public abstract&nbsp;boolean&nbsp;<B>accept</B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)
                            throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
Accepts a visitor.
</summary><remarks><p>Enumerates over this node and all of its children. Each node calls a corresponding method on DocumentVisitor.</p><p>For more info see the Visitor design pattern.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="visitor"><CODE>visitor</CODE> - The visitor that will visit the nodes.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">True if all nodes were visited; false if DocumentVisitor stopped the operation before visiting all nodes.</DD></DL><example><p><b>Example:</b></p>Implements the Visitor Pattern to remove all content formatted as hidden from the document.<pre>
public void removeHiddenContentFromDocument() throws Exception
{
    // Open the document we want to remove hidden content from.
    Document doc = new Document(getMyDir() + "Font.Hidden.doc");

    // Create an object that inherits from the DocumentVisitor class.
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // This is the well known Visitor pattern. Get the model to accept a visitor.
    // The model will iterate through itself by calling the corresponding methods
    // on the visitor object (this is called visiting).

    // We can run it over the entire the document like so:
    doc.accept(hiddenContentRemover);

    // Or we can run it on only a specific node.
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // Or over a different type of node like below.
    Table table = (Table) doc.getChild(NodeType.TABLE, 0, true);
    table.accept(hiddenContentRemover);

    doc.save(getMyDir() + "\\Artifacts\\Font.Hidden.doc");

}

/**
 * This class when executed will remove all hidden content from the Document. Implemented as a Visitor.
 */
private class RemoveHiddenContentVisitor extends DocumentVisitor
{
    /**
     * Called when a FieldStart node is encountered in the document.
     */
    public int visitFieldStart(FieldStart fieldStart) throws Exception
    {
        // If this node is hidden, then remove it.
        if (isHidden(fieldStart)) fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldEnd node is encountered in the document.
     */
    public int visitFieldEnd(FieldEnd fieldEnd) throws Exception
    {
        if (isHidden(fieldEnd)) fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FieldSeparator node is encountered in the document.
     */
    public int visitFieldSeparator(FieldSeparator fieldSeparator) throws Exception
    {
        if (isHidden(fieldSeparator)) fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Run node is encountered in the document.
     */
    public int visitRun(Run run) throws Exception
    {
        if (isHidden(run)) run.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Paragraph node is encountered in the document.
     */
    public int visitParagraphStart(Paragraph paragraph) throws Exception
    {
        if (isHidden(paragraph)) paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a FormField is encountered in the document.
     */
    public int visitFormField(FormField field) throws Exception
    {
        if (isHidden(field)) field.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a GroupShape is encountered in the document.
     */
    public int visitGroupShapeStart(GroupShape groupShape) throws Exception
    {
        if (isHidden(groupShape)) groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Shape is encountered in the document.
     */
    public int visitShapeStart(Shape shape) throws Exception
    {
        if (isHidden(shape)) shape.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Comment is encountered in the document.
     */
    public int visitCommentStart(Comment comment) throws Exception
    {
        if (isHidden(comment)) comment.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a Footnote is encountered in the document.
     */
    public int visitFootnoteStart(Footnote footnote) throws Exception
    {
        if (isHidden(footnote)) footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Table node is ended in the document.
     */
    public int visitTableEnd(Table table)
    {
        // At the moment there is no way to tell if a particular Table/Row/Cell is hidden.
        // Instead, if the content of a table is hidden, then all inline child nodes of the table should be
        // hidden and thus removed by previous visits as well. This will result in the container being empty
        // so if this is the case we know to remove the table node.
        //
        // Note that a table which is not hidden but simply has no content will not be affected by this algorthim,
        // as technically they are not completely empty (for example a properly formed Cell will have at least
        // an empty paragraph in it)
        if (!table.hasChildNodes()) table.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Cell node is ended in the document.
     */
    public int visitCellEnd(Cell cell)
    {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null) cell.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when visiting of a Row node is ended in the document.
     */
    public int visitRowEnd(Row row)
    {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null) row.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Called when a SpecialCharacter is encountered in the document.
     */
    public int visitSpecialChar(SpecialChar character) throws Exception
    {
        if (isHidden(character)) character.remove();

        return VisitorAction.CONTINUE;
    }

    /**
     * Returns true if the node passed is set as hidden, returns false if it is visible.
     */
    private boolean isHidden(Node node)
    {
        if (node instanceof Inline)
        {
            // If the node is Inline then cast it to retrieve the Font property which contains the hidden property
            Inline currentNode = (Inline) node;
            return currentNode.getFont().getHidden();
        } else if (node.getNodeType() == NodeType.PARAGRAPH)
        {
            // If the node is a paragraph cast it to retrieve the ParagraphBreakFont which contains the hidden property
            Paragraph para = (Paragraph) node;
            return para.getParagraphBreakFont().getHidden();
        } else if (node instanceof ShapeBase)
        {
            // Node is a shape or groupshape.
            ShapeBase shape = (ShapeBase) node;
            return shape.getFont().getHidden();
        } else if (node instanceof InlineStory)
        {
            // Node is a comment or footnote.
            InlineStory inlineStory = (InlineStory) node;
            return inlineStory.getFont().getHidden();
        }

        // A node that is passed to this method which does not contain a hidden property will end up here.
        // By default nodes are not hidden so return false.
        return false;
    }
}</pre></example>
</DL>
<HR>

<A NAME="appendChild(com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>appendChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>appendChild</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;newChild)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Adds the specified node to the end of the list of child nodes for this node.
            </summary><remarks><p>If the newChild is already in the tree, it is first removed.</p><p>If the node being inserted was created from another document, you should use 
<cref><A HREF="#importNode(com.aspose.words.Node,boolean,int)" title="method in class com.aspose.words.DocumentBase">importNode(com.aspose.words.Node,boolean,int)</A></cref> to import the node to the current document. 
The imported node can then be inserted into the current document.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="newChild"><CODE>newChild</CODE> - The node to add.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The node added.</DD></DL><example><p><b>Example:</b></p>Creates a simple document from scratch using the Aspose.Words object model.<pre>
// Create an "empty" document. Note that like in Microsoft Word,
// the empty document has one section, body and one paragraph in it.
Document doc = new Document();

// This truly makes the document empty. No sections (not possible in Microsoft Word).
doc.removeAllChildren();

// Create a new section node.
// Note that the section has not yet been added to the document,
// but we have to specify the parent document.
Section section = new Section(doc);

// Append the section to the document.
doc.appendChild(section);

// Lets set some properties for the section.
section.getPageSetup().setSectionStart(SectionStart.NEW_PAGE);
section.getPageSetup().setPaperSize(PaperSize.LETTER);

// The section that we created is empty, lets populate it. The section needs at least the Body node.
Body body = new Body(doc);
section.appendChild(body);

// The body needs to have at least one paragraph.
// Note that the paragraph has not yet been added to the document,
// but we have to specify the parent document.
// The parent document is needed so the paragraph can correctly work
// with styles and other document-wide information.
Paragraph para = new Paragraph(doc);
body.appendChild(para);

// We can set some formatting for the paragraph
para.getParagraphFormat().setStyleName("Heading 1");
para.getParagraphFormat().setAlignment(ParagraphAlignment.CENTER);

// So far we have one empty paragraph in the document.
// The document is valid and can be saved, but lets add some text before saving.
// Create a new run of text and add it to our paragraph.
Run run = new Run(doc);
run.setText("Hello World!");
run.getFont().setColor(Color.RED);
para.appendChild(run);

// As a matter of interest, you can retrieve text of the whole document and
// see that \x000c is automatically appended. \x000c is the end of section character.
System.out.println(doc.getText());

// Save the document.
doc.save(getMyDir() + "\\Artifacts\\Section.CreateFromScratch.doc");</pre></example>
</DL>
<HR>

<A NAME="deepClone(boolean)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>deepClone</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>deepClone</B>(boolean&nbsp;isCloneChildren)</PRE></TD></TR></TABLE>
<DL><DD><!-- No matching elements were found for the following include tag --><include file="..\Docs\Text.xml" path="Topics/Topic[@name=&quot;Node.Clone&quot;]/*" /><summary /><example><p><b>Example:</b></p>Shows how to clone composite nodes with and without their child nodes.<pre>
// Create a new empty document.
Document doc = new Document();

// Add some text to the first paragraph
Paragraph para = doc.getFirstSection().getBody().getFirstParagraph();
para.appendChild(new Run(doc, "Some text"));

// Clone the paragraph and the child nodes.
Node cloneWithChildren = para.deepClone(true);
// Only clone the paragraph and no child nodes.
Node cloneWithoutChildren = para.deepClone(false);</pre></example>
</DL>
<HR>

<A NAME="getAncestor(int)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getAncestor</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getAncestor</B>(int&nbsp;ancestorType)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first ancestor of the specified <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref>.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="ancestorType"><CODE>ancestorType</CODE> - A <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref> value. The node type of the ancestor to retrieve.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The ancestor of the specified type or null if no ancestor of this type was found.</DD></DL><example><p><b>Example:</b></p>Shows how to find out if a table contains another table or if the table itself is nested inside another table.<pre>
public void calculateDepthOfNestedTables() throws Exception
{
    Document doc = new Document(getMyDir() + "Table.NestedTables.doc");
    int tableIndex = 0;

    for (Table table : (Iterable&lt;Table&gt;) doc.getChildNodes(NodeType.TABLE, true))
    {
        // First lets find if any cells in the table have tables themselves as children.
        int count = getChildTableCount(table);
        System.out.println(MessageFormat.format("Table #{0} has {1} tables directly within its cells", tableIndex, count));

        // Now let's try the other way around, lets try find if the table is nested inside another table and at what depth.
        int tableDepth = getNestedDepthOfTable(table);

        if (tableDepth &gt; 0)
            System.out.println(MessageFormat.format("Table #{0} is nested inside another table at depth of {1}", tableIndex, tableDepth));
        else
            System.out.println(MessageFormat.format("Table #{0} is a non nested table (is not a child of another table)", tableIndex));

        tableIndex++;
    }
}

/**
 * Calculates what level a table is nested inside other tables.
 *
 * @returns An integer containing the level the table is nested at.
 * 0 = Table is not nested inside any other table
 * 1 = Table is nested within one parent table
 * 2 = Table is nested within two parent tables etc..
 */
private static int getNestedDepthOfTable(Table table)
{
    int depth = 0;

    int type = table.getNodeType();
    // The parent of the table will be a Cell, instead attempt to find a grandparent that is of type Table
    Node parent = table.getAncestor(type);

    while (parent != null)
    {
        // Every time we find a table a level up we increase the depth counter and then try to find an
        // ancestor of type table from the parent.
        depth++;
        parent = parent.getAncestor(type);
    }

    return depth;
}

/**
 * Determines if a table contains any immediate child table within its cells.
 * Does not recursively traverse through those tables to check for further tables.
 *
 * @returns Returns true if at least one child cell contains a table.
 * Returns false if no cells in the table contains a table.
 */
private static int getChildTableCount(Table table)
{
    int tableCount = 0;
    // Iterate through all child rows in the table
    for (Row row : table.getRows())
    {
        // Iterate through all child cells in the row
        for (Cell Cell : row.getCells())
        {
            // Retrieve the collection of child tables of this cell
            TableCollection childTables = Cell.getTables();

            // If this cell has a table as a child then return true
            if (childTables.getCount() &gt; 0) tableCount++;
        }
    }

    // No cell contains a table
    return tableCount;
}</pre></example>
</DL>
<HR>

<A NAME="getAncestor(java.lang.Class)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getAncestor</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getAncestor</B>(java.lang.Class&nbsp;ancestorType)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first ancestor of the specified object type.
            </summary><remarks><p>The ancestor type matches if it is equal to ancestorType or derived from ancestorType.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="ancestorType"><CODE>ancestorType</CODE> - The object type of the ancestor to retrieve.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The ancestor of the specified type or null if no ancestor of this type was found.</DD></DL>
</DL>
<HR>

<A NAME="getChild(int,int,boolean)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getChild</B>(int&nbsp;nodeType, int&nbsp;index, boolean&nbsp;isDeep)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns an Nth child node that matches the specified type.
            </summary><remarks><p>If index is out of range, a null is returned.</p></remarks><remarks>Note that markup nodes (<cref><A HREF="NodeType.html#STRUCTURED_DOCUMENT_TAG" title="field in class com.aspose.words.NodeType">NodeType.STRUCTURED_DOCUMENT_TAG</A></cref> and <cref><A HREF="NodeType.html#SMART_TAG" title="field in class com.aspose.words.NodeType">NodeType.SMART_TAG</A></cref>)
            are traversed even when isDeep = false and GetChild is invoked for non-markup node type. For example if the first run in a para 
            is wrapped in a StructuredDocumentTag, it will still be returned by GetChild(NodeType.Run, 0, false).</remarks><DL><DT><B>Parameters:</B></DT><DD param="nodeType"><CODE>nodeType</CODE> - A <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref> value. Specifies the type of the child node.</DD><DD param="index"><CODE>index</CODE> - Zero based index of the child node to select.
            Negative indexes are also allowed and indicate access from the end,
            that is -1 means the last node.</DD><DD param="isDeep"><CODE>isDeep</CODE> - True to select from all child nodes recursively.
            False to select only among immediate children. See remarks for more info.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The child node that matches the criteria or null if no matching node is found.</DD></DL><example><p><b>Example:</b></p>Shows how to test if a node is inside a field by using an XPath expression.<pre>
// Let's pick a document we know has some fields in.
Document doc = new Document(getMyDir() + "MailMerge.MergeImage.doc");

// Let's say we want to check if the Run below is inside a field.
Run run = (Run) doc.getChild(NodeType.RUN, 5, true);

// Evaluate the XPath expression. The resulting NodeList will contain all nodes found inside a field a field (between FieldStart
// and FieldEnd exclusive). There can however be FieldStart and FieldEnd nodes in the list if there are nested fields
// in the path. Currently does not find rare fields in which the FieldCode or FieldResult spans across multiple paragraphs.
NodeList resultList = doc.selectNodes("//FieldStart/following-sibling::node()[following-sibling::FieldEnd]");

// Check if the specified run is one of the nodes that are inside the field.
for (Node node : (Iterable&lt;Node&gt;) resultList)
{
    if (node == run)
    {
        System.out.println("The node is found inside a field");
        break;
    }
}</pre></example><example><p><b>Example:</b></p>Shows how to extract a specific child node from a CompositeNode by using the GetChild method and passing the NodeType and index.<pre>
Paragraph paragraph = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 0, true);</pre></example>
</DL>
<HR>

<A NAME="getChildNodes(int,boolean)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getChildNodes</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="NodeCollection.html" title="class in com.aspose.words">NodeCollection</A>&nbsp;<B>getChildNodes</B>(int&nbsp;nodeType, boolean&nbsp;isDeep)</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Returns a live collection of child nodes that match the specified type.
             </summary><remarks><p>The collection of nodes returned by this method is always live.</p><remarks><p>A live collection is always in sync with the document. For example, if you
selected all sections in a document and enumerate through the collection
deleting the sections, the section is removed from the collection immediately
when it is removed from the document.</p></remarks></remarks><DL><DT><B>Parameters:</B></DT><DD param="nodeType"><CODE>nodeType</CODE> - A <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref> value. Specifies the type of nodes to select.</DD><DD param="isDeep"><CODE>isDeep</CODE> - True to select from all child nodes recursively.
             False to select only among immediate children. </DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A live collection of child nodes of the specified type.</DD></DL><example><p><b>Example:</b></p>Shows how to extract images from a document and save them as files.<pre>
public void extractImagesToFiles() throws Exception
{
    Document doc = new Document(getMyDir() + "Image.SampleImages.doc");

    NodeCollection shapes = doc.getChildNodes(NodeType.SHAPE, true);
    int imageIndex = 0;
    for (Shape shape : (Iterable&lt;Shape&gt;) shapes)
    {
        if (shape.hasImage())
        {
            String imageFileName = java.text.MessageFormat.format("\\Artifacts\\Image.ExportImages.{0} Out{1}", imageIndex, FileFormatUtil.imageTypeToExtension(shape.getImageData().getImageType()));
            shape.getImageData().save(getMyDir() + imageFileName);
            imageIndex++;
        }
    }
}</pre></example><example><p><b>Example:</b></p>Demonstrates how to remove a specified TOC from a document.<pre>
public void removeTOCFromDocument() throws Exception
{
    // Open a document which contains a TOC.
    Document doc = new Document(getMyDir() + "Document.TableOfContents.doc");

    // Remove the first TOC from the document.
    Field tocField = doc.getRange().getFields().get(0);
    tocField.remove();

    // Save the output.
    doc.save(getMyDir() + "\\Artifacts\\Document.TableOfContentsRemoveTOC.doc");
}</pre></example>
</DL>
<HR>

<A NAME="getText()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getText</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getText</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Gets the text of this node and of all its children.
             </summary><remarks><p>The returned string includes all control and special characters as described in <cref><A HREF="ControlChar.html" title="class in com.aspose.words">ControlChar</A></cref>.</p></remarks><example><p><b>Example:</b></p>Shows the difference between calling the GetText and ToString methods on a node.<pre>
Document doc = new Document();

// Enter a dummy field into the document.
DocumentBuilder builder = new DocumentBuilder(doc);
builder.insertField("MERGEFIELD Field");

// GetText will retrieve all field codes and special characters
System.out.println("GetText() Result: " + doc.getText());

// ToString will export the node to the specified format. When converted to text it will not retrieve fields code
// or special characters, but will still contain some natural formatting characters such as paragraph markers etc.
// This is the same as "viewing" the document as if it was opened in a text editor.
System.out.println("ToString() Result: " + doc.toString(SaveFormat.TEXT));</pre></example><example><p><b>Example:</b></p>Finds and outputs all paragraphs in a document that are bulleted or numbered.<pre>
NodeCollection paras = doc.getChildNodes(NodeType.PARAGRAPH, true);
for (Paragraph para : (Iterable&lt;Paragraph&gt;) paras)
{
    if (para.getListFormat().isListItem())
    {
        System.out.println(java.text.MessageFormat.format("*** A paragraph belongs to list {0}", para.getListFormat().getList().getListId()));
        System.out.println(para.getText());
    }
}</pre></example>
</DL>
<HR>

<A NAME="importNode(com.aspose.words.Node,boolean)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>importNode</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>importNode</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;srcNode, boolean&nbsp;isImportChildren)</PRE></TD></TR></TABLE>
<DL><DD><summary><p>Imports a node from another document to the current document.</p></summary><remarks><p>This method uses the <cref><A HREF="ImportFormatMode.html#USE_DESTINATION_STYLES" title="field in class com.aspose.words.ImportFormatMode">ImportFormatMode.USE_DESTINATION_STYLES</A></cref> option to resolve formatting.</p><p>Importing a node creates a copy of the source node belonging to the importing document. 
The returned node has no parent. The source node is not altered or removed from the original document.</p><p>Before a node from another document can be inserted into this document, it must be imported.
During import, document-specific properties such as references to styles and lists are translated
from the original to the importing document. After the node was imported, it can be inserted
into the appropriate place in the document using <cref><A HREF="#insertBefore(com.aspose.words.Node,com.aspose.words.Node)" title="method in class com.aspose.words.DocumentBase">insertBefore(com.aspose.words.Node,com.aspose.words.Node)</A></cref> or 
<cref><A HREF="#insertAfter(com.aspose.words.Node,com.aspose.words.Node)" title="method in class com.aspose.words.DocumentBase">insertAfter(com.aspose.words.Node,com.aspose.words.Node)</A></cref>.</p><p>If the source node already belongs to the destination document, then simply a deep clone
of the source node is created.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="srcNode"><CODE>srcNode</CODE> - The node being imported.</DD><DD param="isImportChildren"><CODE>isImportChildren</CODE> - True to import all child nodes recursively; otherwise, false.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The cloned node that belongs to the current document.</DD></DL><DL><DT><B>See Also:</B></DT><DD><cref seealso=""><A HREF="NodeImporter.html" title="class in com.aspose.words">NodeImporter</A></cref></DD></DL>
</DL>
<HR>

<A NAME="importNode(com.aspose.words.Node,boolean,int)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>importNode</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>importNode</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;srcNode, boolean&nbsp;isImportChildren, int&nbsp;importFormatMode)</PRE></TD></TR></TABLE>
<DL><DD><summary><p>Imports a node from another document to the current document with an option to control formatting.</p></summary><remarks><p>This overload is useful to control how styles and list formatting are imported.</p><p>Importing a node creates a copy of the source node belonging to the importing document. 
The returned node has no parent. The source node is not altered or removed from the original document.</p><p>Before a node from another document can be inserted into this document, it must be imported.
During import, document-specific properties such as references to styles and lists are translated
from the original to the importing document. After the node was imported, it can be inserted
into the appropriate place in the document using <cref><A HREF="#insertBefore(com.aspose.words.Node,com.aspose.words.Node)" title="method in class com.aspose.words.DocumentBase">insertBefore(com.aspose.words.Node,com.aspose.words.Node)</A></cref> or 
<cref><A HREF="#insertAfter(com.aspose.words.Node,com.aspose.words.Node)" title="method in class com.aspose.words.DocumentBase">insertAfter(com.aspose.words.Node,com.aspose.words.Node)</A></cref>.</p><p>If the source node already belongs to the destination document, then simply a deep clone
of the source node is created.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="srcNode"><CODE>srcNode</CODE> - The node to imported.</DD><DD param="isImportChildren"><CODE>isImportChildren</CODE> - True to import all child nodes recursively; otherwise, false.</DD><DD param="importFormatMode"><CODE>importFormatMode</CODE> - A <cref><A HREF="ImportFormatMode.html" title="Utility class in com.aspose.words">ImportFormatMode</A></cref> value. Specifies how to merge style formatting that clashes.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The cloned, imported node. The node belongs to the destination document, but has no parent.</DD></DL><DL><DT><B>See Also:</B></DT><DD><cref seealso=""><A HREF="ImportFormatMode.html" title="Utility class in com.aspose.words">ImportFormatMode</A></cref>, <cref seealso=""><A HREF="NodeImporter.html" title="class in com.aspose.words">NodeImporter</A></cref></DD></DL><example><p><b>Example:</b></p>Shows how to manually prepend the content from one document to the beginning of another document.<pre>
public static void prependDocumentMain() throws Exception
{
    Document dstDoc = new Document(gDataDir + "TestFile.Destination.doc");
    Document srcDoc = new Document(gDataDir + "TestFile.Source.doc");

    // Append the source document to the destination document. This causes the result to have line spacing problems.
    dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING);

    // Instead prepend the content of the destination document to the start of the source document.
    // This results in the same joined document but with no line spacing issues.
    prependDocument(srcDoc, dstDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING);
}


/**
 * A modified version of the AppendDocument method which prepends the content of one document to the start
 * of another.
 *
 * @param dstDoc The destination document where to prepend the source document to.
 * @param srcDoc The source document.
 */
public static void prependDocument(Document dstDoc, Document srcDoc, int mode) throws Exception
{
    // Loop through all sections in the source document.
    // Section nodes are immediate children of the Document node so we can just enumerate the Document.
    ArrayList sections = (ArrayList)Arrays.asList(srcDoc.getSections().toArray());

    // Reverse the order of the sections so they are prepended to start of the destination document in the correct order.
    Collections.reverse(sections);

    for (Section srcSection : (Iterable&lt;Section&gt;) sections)
    {
        // Import the nodes from the source document.
        Node dstSection = dstDoc.importNode(srcSection, true, mode);

        // Now the new section node can be prepended to the destination document.
        // Note how PrependChild is used instead of AppendChild. This is the only line changed compared
        // to the original method.
        dstDoc.prependChild(dstSection);
    }
}</pre></example><example><p><b>Example:</b></p>Shows how to manually append the content from one document to the end of another document.<pre>
/**
 * A manual implementation of the Document.AppendDocument function which shows the general
 * steps of how a document is appended to another.
 *
 * @param dstDoc The destination document where to append to.
 * @param srcDoc The source document.
 * @param mode The import mode to use when importing content from another document.
 */
public void appendDocument(Document dstDoc, Document srcDoc, int mode) throws Exception
{
    // Loop through all sections in the source document.
    // Section nodes are immediate children of the Document node so we can just enumerate the Document.
    for (Node srcNode : srcDoc)
    {
        Section srcSection = (Section)srcNode;

        // Because we are copying a section from one document to another,
        // it is required to import the Section node into the destination document.
        // This adjusts any document-specific references to styles, lists, etc.
        //
        // Importing a node creates a copy of the original node, but the copy
        // is ready to be inserted into the destination document.
        Node dstSection = dstDoc.importNode(srcSection, true, mode);

        // Now the new section node can be appended to the destination document.
        dstDoc.appendChild(dstSection);
    }
}</pre></example>
</DL>
<HR>

<A NAME="indexOf(com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>indexOf</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>indexOf</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;child)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns the index of the specified child node in the child node array.
            </summary><remarks>
            Returns -1 if the node is not found in the child nodes.
            </remarks><example><p><b>Example:</b></p>Shows how to get the index of a given child node from its parent.<pre>
Document doc = new Document(getMyDir() + "Rendering.doc");

// Get the body of the first section in the document.
Body body = doc.getFirstSection().getBody();
// Retrieve the index of the last paragraph in the body.
int index = body.getChildNodes().indexOf(body.getLastParagraph());</pre></example><example><p><b>Example:</b></p>Retrieves the index of a row in a table.<pre>
int rowIndex = table.indexOf(row);</pre></example><example><p><b>Example:</b></p>Retrieves the index of a cell in a row.<pre>
int cellIndex = row.indexOf(cell);</pre></example>
</DL>
<HR>

<A NAME="insertAfter(com.aspose.words.Node,com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>insertAfter</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>insertAfter</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;newChild, <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;refChild)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Inserts the specified node immediately after the specified reference node.
            </summary><remarks><p>If refChild is null, inserts newChild at the beginning of the list of child nodes.</p></remarks><remarks><p>If the newChild is already in the tree, it is first removed.</p><p>If the node being inserted was created from another document, you should use 
<cref><A HREF="#importNode(com.aspose.words.Node,boolean,int)" title="method in class com.aspose.words.DocumentBase">importNode(com.aspose.words.Node,boolean,int)</A></cref> to import the node to the current document. 
The imported node can then be inserted into the current document.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="newChild"><CODE>newChild</CODE> - The Node to insert.</DD><DD param="refChild"><CODE>refChild</CODE> - The Node that is the reference node. The newNode is placed after the refNode. </DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The inserted node.</DD></DL><example><p><b>Example:</b></p>Shows how to replace all textboxes with images.<pre>
Document doc = new Document(getMyDir() + "Shape.ReplaceTextboxesWithImages.doc");

// This gets a live collection of all shape nodes in the document.
NodeCollection shapeCollection = doc.getChildNodes(NodeType.SHAPE, true);

// Since we will be adding/removing nodes, it is better to copy all collection
// into a fixed size array, otherwise iterator will be invalidated.
Node[] shapes = shapeCollection.toArray();

for (Node node : shapes)
{
    Shape shape = (Shape) node;
    // Filter out all shapes that we don't need.
    if (shape.getShapeType() == ShapeType.TEXT_BOX)
    {
        // Create a new shape that will replace the existing shape.
        Shape image = new Shape(doc, ShapeType.IMAGE);

        // Load the image into the new shape.
        image.getImageData().setImage(getImageDir() + "Hammer.wmf");

        // Make new shape's position to match the old shape.
        image.setLeft(shape.getLeft());
        image.setTop(shape.getTop());
        image.setWidth(shape.getWidth());
        image.setHeight(shape.getHeight());
        image.setRelativeHorizontalPosition(shape.getRelativeHorizontalPosition());
        image.setRelativeVerticalPosition(shape.getRelativeVerticalPosition());
        image.setHorizontalAlignment(shape.getHorizontalAlignment());
        image.setVerticalAlignment(shape.getVerticalAlignment());
        image.setWrapType(shape.getWrapType());
        image.setWrapSide(shape.getWrapSide());

        // Insert new shape after the old shape and remove the old shape.
        shape.getParentNode().insertAfter(image, shape);
        shape.remove();
    }
}

doc.save(getMyDir() + "\\Artifacts\\Shape.ReplaceTextboxesWithImages.doc");</pre></example>
</DL>
<HR>

<A NAME="insertBefore(com.aspose.words.Node,com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>insertBefore</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>insertBefore</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;newChild, <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;refChild)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Inserts the specified node immediately before the specified reference node.
            </summary><remarks><p>If refChild is null, inserts newChild at the end of the list of child nodes.</p></remarks><remarks><p>If the newChild is already in the tree, it is first removed.</p><p>If the node being inserted was created from another document, you should use 
<cref><A HREF="#importNode(com.aspose.words.Node,boolean,int)" title="method in class com.aspose.words.DocumentBase">importNode(com.aspose.words.Node,boolean,int)</A></cref> to import the node to the current document. 
The imported node can then be inserted into the current document.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="newChild"><CODE>newChild</CODE> - The Node to insert.</DD><DD param="refChild"><CODE>refChild</CODE> - The Node that is the reference node. The newChild is placed before this node.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The inserted node.</DD></DL>
</DL>
<HR>

<A NAME="nextPreOrder(com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>nextPreOrder</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>nextPreOrder</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets next node according to the pre-order tree traversal algorithm.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="rootNode"><CODE>rootNode</CODE> - The top node (limit) of traversal.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">Next node in pre-order order. Null if reached the rootNode.</DD></DL><example><p><b>Example:</b></p>Shows how to delete all images from a document using pre-order tree traversal.<pre>
Node curNode = doc;
while (curNode != null)
{
    Node nextNode = curNode.nextPreOrder(doc);

    if (curNode.getNodeType() == NodeType.SHAPE)
    {
        Shape shape = (Shape) curNode;

        // Several shape types can have an image including image shapes and OLE objects.
        if (shape.hasImage()) shape.remove();
    }

    curNode = nextNode;
}</pre></example>
</DL>
<HR>

<A NAME="prependChild(com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>prependChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>prependChild</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;newChild)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Adds the specified node to the beginning of the list of child nodes for this node.
            </summary><remarks><p>If the newChild is already in the tree, it is first removed.</p><p>If the node being inserted was created from another document, you should use 
<cref><A HREF="#importNode(com.aspose.words.Node,boolean,int)" title="method in class com.aspose.words.DocumentBase">importNode(com.aspose.words.Node,boolean,int)</A></cref> to import the node to the current document. 
The imported node can then be inserted into the current document.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="newChild"><CODE>newChild</CODE> - The node to add.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The node added.</DD></DL><example><p><b>Example:</b></p>Shows how to manually prepend the content from one document to the beginning of another document.<pre>
public static void prependDocumentMain() throws Exception
{
    Document dstDoc = new Document(gDataDir + "TestFile.Destination.doc");
    Document srcDoc = new Document(gDataDir + "TestFile.Source.doc");

    // Append the source document to the destination document. This causes the result to have line spacing problems.
    dstDoc.appendDocument(srcDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING);

    // Instead prepend the content of the destination document to the start of the source document.
    // This results in the same joined document but with no line spacing issues.
    prependDocument(srcDoc, dstDoc, ImportFormatMode.KEEP_SOURCE_FORMATTING);
}


/**
 * A modified version of the AppendDocument method which prepends the content of one document to the start
 * of another.
 *
 * @param dstDoc The destination document where to prepend the source document to.
 * @param srcDoc The source document.
 */
public static void prependDocument(Document dstDoc, Document srcDoc, int mode) throws Exception
{
    // Loop through all sections in the source document.
    // Section nodes are immediate children of the Document node so we can just enumerate the Document.
    ArrayList sections = (ArrayList)Arrays.asList(srcDoc.getSections().toArray());

    // Reverse the order of the sections so they are prepended to start of the destination document in the correct order.
    Collections.reverse(sections);

    for (Section srcSection : (Iterable&lt;Section&gt;) sections)
    {
        // Import the nodes from the source document.
        Node dstSection = dstDoc.importNode(srcSection, true, mode);

        // Now the new section node can be prepended to the destination document.
        // Note how PrependChild is used instead of AppendChild. This is the only line changed compared
        // to the original method.
        dstDoc.prependChild(dstSection);
    }
}</pre></example>
</DL>
<HR>

<A NAME="previousPreOrder(com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>previousPreOrder</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>previousPreOrder</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the previous node according to the pre-order tree traversal algorithm.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="rootNode"><CODE>rootNode</CODE> - The top node (limit) of traversal.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">Previous node in pre-order order. Null if reached the rootNode.</DD></DL>
</DL>
<HR>

<A NAME="remove()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>remove</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>remove</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes itself from the parent.
            </summary><example><p><b>Example:</b></p>Shows how to remove all nodes of a specific type from a composite node. In this example we remove tables from a section body.<pre>
// Get the section that we want to work on.
Section section = doc.getSections().get(0);
Body body = section.getBody();

// Select the first child node in the body.
Node curNode = body.getFirstChild();

while (curNode != null)
{
    // Save the pointer to the next sibling node because if the current
    // node is removed from the parent in the next step, we will have
    // no way of finding the next node to continue the loop.
    Node nextNode = curNode.getNextSibling();

    // A section body can contain Paragraph and Table nodes.
    // If the node is a Table, remove it from the parent.
    if (curNode.getNodeType() == NodeType.TABLE) curNode.remove();

    // Continue going through child nodes until null (no more siblings) is reached.
    curNode = nextNode;
}</pre></example><example><p><b>Example:</b></p>Shows how to delete all images from a document.<pre>
// Here we get all shapes from the document node, but you can do this for any smaller
// node too, for example delete shapes from a single section or a paragraph.
NodeCollection shapes = doc.getChildNodes(NodeType.SHAPE, true);

// We cannot delete shape nodes while we enumerate through the collection.
// One solution is to add nodes that we want to delete to a temporary array and delete afterwards.
ArrayList shapesToDelete = new ArrayList();
for (Shape shape : (Iterable&lt;Shape&gt;) shapes)
{
    // Several shape types can have an image including image shapes and OLE objects.
    if (shape.hasImage()) shapesToDelete.add(shape);
}

// Now we can delete shapes.
for (Shape shape : (Iterable&lt;Shape&gt;) shapesToDelete)
    shape.remove();</pre></example>
</DL>
<HR>

<A NAME="removeAllChildren()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>removeAllChildren</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>removeAllChildren</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes all the child nodes of the current node.
            </summary><example><p><b>Example:</b></p>Creates a simple document from scratch using the Aspose.Words object model.<pre>
// Create an "empty" document. Note that like in Microsoft Word,
// the empty document has one section, body and one paragraph in it.
Document doc = new Document();

// This truly makes the document empty. No sections (not possible in Microsoft Word).
doc.removeAllChildren();

// Create a new section node.
// Note that the section has not yet been added to the document,
// but we have to specify the parent document.
Section section = new Section(doc);

// Append the section to the document.
doc.appendChild(section);

// Lets set some properties for the section.
section.getPageSetup().setSectionStart(SectionStart.NEW_PAGE);
section.getPageSetup().setPaperSize(PaperSize.LETTER);

// The section that we created is empty, lets populate it. The section needs at least the Body node.
Body body = new Body(doc);
section.appendChild(body);

// The body needs to have at least one paragraph.
// Note that the paragraph has not yet been added to the document,
// but we have to specify the parent document.
// The parent document is needed so the paragraph can correctly work
// with styles and other document-wide information.
Paragraph para = new Paragraph(doc);
body.appendChild(para);

// We can set some formatting for the paragraph
para.getParagraphFormat().setStyleName("Heading 1");
para.getParagraphFormat().setAlignment(ParagraphAlignment.CENTER);

// So far we have one empty paragraph in the document.
// The document is valid and can be saved, but lets add some text before saving.
// Create a new run of text and add it to our paragraph.
Run run = new Run(doc);
run.setText("Hello World!");
run.getFont().setColor(Color.RED);
para.appendChild(run);

// As a matter of interest, you can retrieve text of the whole document and
// see that \x000c is automatically appended. \x000c is the end of section character.
System.out.println(doc.getText());

// Save the document.
doc.save(getMyDir() + "\\Artifacts\\Section.CreateFromScratch.doc");</pre></example>
</DL>
<HR>

<A NAME="removeChild(com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>removeChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>removeChild</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;oldChild)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes the specified child node.
            </summary><remarks><p>The parent of oldChild is set to null after the node is removed.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="oldChild"><CODE>oldChild</CODE> - The node to remove.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The removed node.</DD></DL><example><p><b>Example:</b></p>Demonstrates use of methods of Node and CompositeNode to remove a section before the last section in the document.<pre>
// Document is a CompositeNode and LastChild returns the last child node in the Document node.
// Since the Document can contain only Section nodes, the last child is the last section.
Node lastSection = doc.getLastChild();

// Each node knows its next and previous sibling nodes.
// Previous sibling of a section is a section before the specified section.
// If the node is the first child, PreviousSibling will return null.
Node sectionBeforeLast = lastSection.getPreviousSibling();

if (sectionBeforeLast != null) doc.removeChild(sectionBeforeLast);</pre></example>
</DL>
<HR>

<A NAME="removeSmartTags()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>removeSmartTags</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>removeSmartTags</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes all <cref><A HREF="SmartTag.html" title="class in com.aspose.words">SmartTag</A></cref> descendant nodes of the current node.
            </summary><remarks>This method does not remove the content of the smart tags.</remarks><example><p><b>Example:</b></p>Removes all smart tags from descendant nodes of the composite node.<pre>
Document doc = new Document(getMyDir() + "Document.doc");

// Remove smart tags from the first paragraph in the document.
doc.getFirstSection().getBody().getFirstParagraph().removeSmartTags();</pre></example><example><p><b>Example:</b></p>Shows how to remove all smart tags from a document.<pre>
Document doc = new Document(getMyDir() + "Document.doc");
doc.removeSmartTags();</pre></example>
</DL>
<HR>

<A NAME="selectNodes(java.lang.String)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>selectNodes</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="NodeList.html" title="class in com.aspose.words">NodeList</A>&nbsp;<B>selectNodes</B>(java.lang.String&nbsp;xpath)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Selects a list of nodes matching the XPath expression.
            </summary><remarks><p>Only expressions with element names are supported at the moment. Expressions
            that use attribute names are not supported.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="xpath"><CODE>xpath</CODE> - The XPath expression.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A list of nodes matching the XPath query.</DD></DL><example><p><b>Example:</b></p>Shows how to test if a node is inside a field by using an XPath expression.<pre>
// Let's pick a document we know has some fields in.
Document doc = new Document(getMyDir() + "MailMerge.MergeImage.doc");

// Let's say we want to check if the Run below is inside a field.
Run run = (Run) doc.getChild(NodeType.RUN, 5, true);

// Evaluate the XPath expression. The resulting NodeList will contain all nodes found inside a field a field (between FieldStart
// and FieldEnd exclusive). There can however be FieldStart and FieldEnd nodes in the list if there are nested fields
// in the path. Currently does not find rare fields in which the FieldCode or FieldResult spans across multiple paragraphs.
NodeList resultList = doc.selectNodes("//FieldStart/following-sibling::node()[following-sibling::FieldEnd]");

// Check if the specified run is one of the nodes that are inside the field.
for (Node node : (Iterable&lt;Node&gt;) resultList)
{
    if (node == run)
    {
        System.out.println("The node is found inside a field");
        break;
    }
}</pre></example><example><p><b>Example:</b></p>Shows how to select certain nodes by using an XPath expression.<pre>
Document doc = new Document(getMyDir() + "Table.Document.doc");

// This expression will extract all paragraph nodes which are descendants of any table node in the document.
// This will return any paragraphs which are in a table.
NodeList nodeList = doc.selectNodes("//Table//Paragraph");

// This expression will select any paragraphs that are direct children of any body node in the document.
nodeList = doc.selectNodes("//Body/Paragraph");

// Use SelectSingleNode to select the first result of the same expression as above.
Node node = doc.selectSingleNode("//Body/Paragraph");</pre></example>
</DL>
<HR>

<A NAME="selectSingleNode(java.lang.String)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>selectSingleNode</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>selectSingleNode</B>(java.lang.String&nbsp;xpath)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Selects the first Node that matches the XPath expression.
            </summary><remarks><p>Only expressions with element names are supported at the moment. Expressions
            that use attribute names are not supported.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="xpath"><CODE>xpath</CODE> - The XPath expression.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The first Node that matches the XPath query or null if no matching node is found.</DD></DL><example><p><b>Example:</b></p>Shows how to select certain nodes by using an XPath expression.<pre>
Document doc = new Document(getMyDir() + "Table.Document.doc");

// This expression will extract all paragraph nodes which are descendants of any table node in the document.
// This will return any paragraphs which are in a table.
NodeList nodeList = doc.selectNodes("//Table//Paragraph");

// This expression will select any paragraphs that are direct children of any body node in the document.
nodeList = doc.selectNodes("//Body/Paragraph");

// Use SelectSingleNode to select the first result of the same expression as above.
Node node = doc.selectSingleNode("//Body/Paragraph");</pre></example>
</DL>
<HR>

<A NAME="toString(com.aspose.words.SaveOptions)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>toString</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>toString</B>(<A HREF="SaveOptions.html" title="class in com.aspose.words">SaveOptions</A>&nbsp;saveOptions)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Exports the content of the node into a string using the specified save options.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="saveOptions"><CODE>saveOptions</CODE> - Specifies the options that control how the node is saved.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The content of the node in the specified format.</DD></DL><example><p><b>Example:</b></p>Exports the content of a node to string in HTML format using custom specified options.<pre>
Document doc = new Document(getMyDir() + "Document.doc");

// Extract the last paragraph in the document to convert to HTML.
Node node = doc.getLastSection().getBody().getLastParagraph();

// Create an instance of HtmlSaveOptions and set a few options.
HtmlSaveOptions saveOptions = new HtmlSaveOptions();
saveOptions.setExportHeadersFootersMode(ExportHeadersFootersMode.PER_SECTION);
saveOptions.setExportRelativeFontSize(true);

// Convert the document to HTML and return as a string. Pass the instance of HtmlSaveOptions to
// to use the specified options during the conversion.
String nodeAsHtml = node.toString(saveOptions);</pre></example>
</DL>
<HR>

<A NAME="toString(int)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>toString</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>toString</B>(int&nbsp;saveFormat)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Exports the content of the node into a string in the specified format.
            </summary><DL><DT><B>Returns:</B></DT><DD returns="">The content of the node in the specified format.</DD></DL><DL><DT><B>Parameters:</B></DT><DD><CODE>saveFormat</CODE> - A <A HREF="SaveFormat.html" title="Utility class in com.aspose.words">SaveFormat</A> value.</DD></DL><example><p><b>Example:</b></p>Shows how to extract the label of each paragraph in a list as a value or a String.<pre>
Document doc = new Document(getMyDir() + "Lists.PrintOutAllLists.doc");
doc.updateListLabels();
int listParaCount = 1;

for (Paragraph paragraph : (Iterable&lt;Paragraph&gt;) doc.getChildNodes(NodeType.PARAGRAPH, true))
{
    // Find if we have the paragraph list. In our document our list uses plain arabic numbers,
    // which start at three and ends at six.
    if (paragraph.getListFormat().isListItem())
    {
        System.out.println(MessageFormat.format("Paragraph #{0}", listParaCount));

        // This is the text we get when actually getting when we output this node to text format.
        // The list labels are not included in this text output. Trim any paragraph formatting characters.
        String paragraphText = paragraph.toString(SaveFormat.TEXT).trim();
        System.out.println("Exported Text: " + paragraphText);

        ListLabel label = paragraph.getListLabel();
        // This gets the position of the paragraph in current level of the list. If we have a list with multiple level then this
        // will tell us what position it is on that particular level.
        System.out.println("Numerical Id: " + label.getLabelValue());

        // Combine them together to include the list label with the text in the output.
        System.out.println("List label combined with text: " + label.getLabelString() + " " + paragraphText);

        listParaCount++;
    }
}</pre></example><example><p><b>Example:</b></p>Shows the difference between calling the GetText and ToString methods on a node.<pre>
Document doc = new Document();

// Enter a dummy field into the document.
DocumentBuilder builder = new DocumentBuilder(doc);
builder.insertField("MERGEFIELD Field");

// GetText will retrieve all field codes and special characters
System.out.println("GetText() Result: " + doc.getText());

// ToString will export the node to the specified format. When converted to text it will not retrieve fields code
// or special characters, but will still contain some natural formatting characters such as paragraph markers etc.
// This is the same as "viewing" the document as if it was opened in a text editor.
System.out.println("ToString() Result: " + doc.toString(SaveFormat.TEXT));</pre></example><example><p><b>Example:</b></p>Exports the content of a node to string in HTML format using default options.<pre>
Document doc = new Document(getMyDir() + "Document.doc");

// Extract the last paragraph in the document to convert to HTML.
Node node = doc.getLastSection().getBody().getLastParagraph();

// When ToString is called using the SaveFormat overload then conversion is executed using default save options.
// When saving to HTML using default options the following settings are set:
//   ExportImagesAsBase64 = true
//   CssStyleSheetType = CssStyleSheetType.Inline
//   ExportFontResources = false
String nodeAsHtml = node.toString(SaveFormat.HTML);</pre></example>
</DL>
<HR>

<B>See Also:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Products/Aspose.Words/Api/index.html" TARGET="_blank">Aspose.Words Documentation</A> - the home page for the Aspose.Words Product Documentation.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Community/forums/ShowForum.aspx?ForumID=75" TARGET="_blank">Aspose.Words Support Forum</A> - our preferred method of support.<P>
<div class="footer"><hr><p><a href='http://www.aspose.com/Wiki/default.aspx/Aspose.Corporate/ContactAspose.html'>We guarantee a prompt response to any inquiry!</a></p><p>&copy; 2003-2007 Aspose Pty Ltd. All rights reserved.</p></div></BODY></HTML>