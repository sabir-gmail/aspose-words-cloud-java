<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
><HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- Generated by javadoc - compatibility string-->
<!-- Generated by Aspose.JavaDoc 09 Aug 2018 -->
<TITLE>FieldStart</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style"></HEAD>
<BODY BGCOLOR="white">
<!-- ======== START OF CLASS DATA ======== -->
<H2><a href="package-summary.html"><FONT SIZE="-1">
com.aspose.words
</FONT></a><BR>Class FieldStart</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="Node.html" title="class in com.aspose.words">Node</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="Inline.html" title="class in com.aspose.words">Inline</A>
          <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="SpecialChar.html" title="class in com.aspose.words">SpecialChar</A>
              <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A>
                  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.aspose.words.FieldStart</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Cloneable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>FieldStart </B><DT>extends <A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></DL>
</PRE>

<P>

<summary>
            Represents a start of a Word field in a document.
            </summary><remarks><p><cref><i>FieldStart</i></cref> is an inline-level node and represented by the 
            <cref><A HREF="ControlChar.html#FIELD_START_CHAR" title="field in class com.aspose.words.ControlChar">ControlChar.FIELD_START_CHAR</A></cref> control character in the document.</p><p><cref><i>FieldStart</i></cref> can only be a child of <cref><A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A></cref>.</p><p>A complete field in a Microsoft Word document is a complex structure consisting of
a field start character, field code, field separator character, field result
and field end character. Some fields only have field start, field code and field end.</p><p>To easily insert a new field into a document, use the <cref><A HREF="DocumentBuilder.html#insertField(java.lang.String)" title="method in class com.aspose.words.DocumentBuilder">DocumentBuilder.insertField(java.lang.String)</A></cref>
method.</p></remarks><example><p><b>Example:</b></p>Provides some helper functions by the methods above<pre>
/**
 * Retrieves the field code from a field.
 *
 * @param fieldStart The field start of the field which to gather the field code from.
 */
private static String getFieldCode(FieldStart fieldStart) throws Exception
{
    StringBuilder builder = new StringBuilder();

    for (Node node = fieldStart; node != null &amp;&amp; node.getNodeType() != NodeType.FIELD_SEPARATOR &amp;&amp;
        node.getNodeType() != NodeType.FIELD_END; node = node.nextPreOrder(node.getDocument()))
    {
        // Use text only of Run nodes to avoid duplication.
        if (node.getNodeType() == NodeType.RUN)
            builder.append(node.getText());
    }
    return builder.toString();
}

/**
 * Removes the Field from the document.
 *
 * @param fieldStart The field start node of the field to remove.
 */
private static void removeField(FieldStart fieldStart) throws Exception
{
    Node currentNode = fieldStart;
    boolean isRemoving = true;
    while (currentNode != null &amp;&amp; isRemoving)
    {
        if (currentNode.getNodeType() == NodeType.FIELD_END)
            isRemoving = false;

        Node nextNode = currentNode.nextPreOrder(currentNode.getDocument());
        currentNode.remove();
        currentNode = nextNode;
    }
}</pre></example><example><p><b>Example:</b></p>Finds all hyperlinks in a Word document and changes their URL and display name.<pre>
package Examples;

import org.testng.annotations.Test;
import com.aspose.words.Document;
import com.aspose.words.NodeList;
import com.aspose.words.FieldStart;
import com.aspose.words.FieldType;
import com.aspose.words.NodeType;
import com.aspose.words.Run;
import com.aspose.words.Node;

import java.util.regex.Matcher;
import java.util.regex.Pattern;


/**
 * Shows how to replace hyperlinks in a Word document.
 */
public class ExReplaceHyperlinks extends ApiExampleBase
{
    /**
     * Finds all hyperlinks in a Word document and changes their URL and display name.
     */
    public void replaceHyperlinks() throws Exception
    {
        // Specify your document name here.
        Document doc = new Document(getMyDir() + "ReplaceHyperlinks.doc");

        // Hyperlinks in a Word documents are fields, select all field start nodes so we can find the hyperlinks.
        NodeList fieldStarts = doc.selectNodes("//FieldStart");
        for (FieldStart fieldStart : (Iterable&lt;FieldStart&gt;) fieldStarts)
        {
            if (fieldStart.getFieldType() == FieldType.FIELD_HYPERLINK)
            {
                // The field is a hyperlink field, use the "facade" class to help to deal with the field.
                Hyperlink hyperlink = new Hyperlink(fieldStart);

                // Some hyperlinks can be local (links to bookmarks inside the document), ignore these.
                if (hyperlink.isLocal()) continue;

                // The Hyperlink class allows to set the target URL and the display name
                // of the link easily by setting the properties.
                hyperlink.setTarget(NEW_URL);
                hyperlink.setName(NEW_NAME);
            }
        }

        doc.save(getMyDir() + "\\Artifacts\\ReplaceHyperlinks.doc");
    }

    private static final String NEW_URL = "http://www.aspose.com";
    private static final String NEW_NAME = "Aspose - The .NET &amp; Java Component Publisher";
}


/**
 * This "facade" class makes it easier to work with a hyperlink field in a Word document.
 * &lt;p&gt;
 * A hyperlink is represented by a HYPERLINK field in a Word document. A field in Aspose.Words
 * consists of several nodes and it might be difficult to work with all those nodes directly.
 * Note this is a simple implementation and will work only if the hyperlink code and name
 * each consist of one Run only.
 * &lt;p&gt;
 * [FieldStart][Run - field code][FieldSeparator][Run - field result][FieldEnd]
 * &lt;p&gt;
 * The field code contains a String in one of these formats:
 * HYPERLINK "url"
 * HYPERLINK \l "bookmark name"
 * &lt;p&gt;
 * The field result contains text that is displayed to the user.
 */
class Hyperlink
{
    Hyperlink(FieldStart fieldStart) throws Exception
    {
        if (fieldStart == null) throw new IllegalArgumentException("fieldStart");
        if (fieldStart.getFieldType() != FieldType.FIELD_HYPERLINK)
            throw new IllegalArgumentException("Field start type must be FieldHyperlink.");

        mFieldStart = fieldStart;

        // Find the field separator node.
        mFieldSeparator = findNextSibling(mFieldStart, NodeType.FIELD_SEPARATOR);
        if (mFieldSeparator == null) throw new IllegalStateException("Cannot find field separator.");

        // Find the field end node. Normally field end will always be found, but in the example document
        // there happens to be a paragraph break included in the hyperlink and this puts the field end
        // in the next paragraph. It will be much more complicated to handle fields which span several
        // paragraphs correctly, but in this case allowing field end to be null is enough for our purposes.
        mFieldEnd = findNextSibling(mFieldSeparator, NodeType.FIELD_END);

        // Field code looks something like [ HYPERLINK "http:\\www.myurl.com" ], but it can consist of several runs.
        String fieldCode = getTextSameParent(mFieldStart.getNextSibling(), mFieldSeparator);
        Matcher matcher = G_REGEX.matcher(fieldCode.trim());
        matcher.find();
        mIsLocal = (matcher.group(1) != null) &amp;&amp; (matcher.group(1).length() &gt; 0);    //The link is local if \l is present in the field code.
        mTarget = matcher.group(2).toString();
    }

    /**
     * Gets or sets the display name of the hyperlink.
     */
    String getName() throws Exception
    {
        return getTextSameParent(mFieldSeparator, mFieldEnd);
    }

    void setName(String value) throws Exception
    {
        // Hyperlink display name is stored in the field result which is a Run
        // node between field separator and field end.
        Run fieldResult = (Run) mFieldSeparator.getNextSibling();
        fieldResult.setText(value);

        // But sometimes the field result can consist of more than one run, delete these runs.
        removeSameParent(fieldResult.getNextSibling(), mFieldEnd);
    }

    /**
     * Gets or sets the target url or bookmark name of the hyperlink.
     */
    String getTarget()
    {
        return mTarget;
    }

    void setTarget(String value) throws Exception
    {
        mTarget = value;
        updateFieldCode();
    }

    /**
     * True if the hyperlink's target is a bookmark inside the document. False if the hyperlink is a url.
     */
    boolean isLocal()
    {
        return mIsLocal;
    }

    void isLocal(boolean value) throws Exception
    {
        mIsLocal = value;
        updateFieldCode();
    }

    private void updateFieldCode() throws Exception
    {
        // Field code is stored in a Run node between field start and field separator.
        Run fieldCode = (Run) mFieldStart.getNextSibling();
        fieldCode.setText(java.text.MessageFormat.format("HYPERLINK {0}\"{1}\"", ((mIsLocal) ? "\\l " : ""), mTarget));

        // But sometimes the field code can consist of more than one run, delete these runs.
        removeSameParent(fieldCode.getNextSibling(), mFieldSeparator);
    }

    /**
     * Goes through siblings starting from the start node until it finds a node of the specified type or null.
     */
    private static Node findNextSibling(Node startNode, int nodeType)
    {
        for (Node node = startNode; node != null; node = node.getNextSibling())
        {
            if (node.getNodeType() == nodeType) return node;
        }
        return null;
    }

    /**
     * Retrieves text from start up to but not including the end node.
     */
    private static String getTextSameParent(Node startNode, Node endNode)
    {
        if ((endNode != null) &amp;&amp; (startNode.getParentNode() != endNode.getParentNode()))
            throw new IllegalArgumentException("Start and end nodes are expected to have the same parent.");

        StringBuilder builder = new StringBuilder();
        for (Node child = startNode; !child.equals(endNode); child = child.getNextSibling())
            builder.append(child.getText());

        return builder.toString();
    }

    /**
     * Removes nodes from start up to but not including the end node.
     * Start and end are assumed to have the same parent.
     */
    private static void removeSameParent(Node startNode, Node endNode)
    {
        if ((endNode != null) &amp;&amp; (startNode.getParentNode() != endNode.getParentNode()))
            throw new IllegalArgumentException("Start and end nodes are expected to have the same parent.");

        Node curChild = startNode;
        while ((curChild != null) &amp;&amp; (curChild != endNode))
        {
            Node nextChild = curChild.getNextSibling();
            curChild.remove();
            curChild = nextChild;
        }
    }

    private final Node mFieldStart;
    private final Node mFieldSeparator;
    private final Node mFieldEnd;
    private boolean mIsLocal;
    private String mTarget;

    /**
     * RK I am notoriously bad at regexes. It seems I don't understand their way of thinking.
     */
    private static final Pattern G_REGEX = Pattern.compile("\\S+" +            // one or more non spaces HYPERLINK or other word in other languages
            "\\s+" +            // one or more spaces
            "(?:\"\"\\s+)?" +    // non capturing optional "" and one or more spaces, found in one of the customers files.
            "(\\\\l\\s+)?" +    // optional \l flag followed by one or more spaces
            "\"" +                // one apostrophe
            "([^\"]+)" +        // one or more chars except apostrophe (hyperlink target)
            "\""                // one closing apostrophe
    );
}</pre></example>
<HR>
<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<P>

<!-- ========== PROPERTY SUMMARY =========== -->

<A NAME="property_summary"><!-- --></A>
<TABLE RULES="GROUPS" BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Property Getters/Setters Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A></CODE></TD><TD><CODE><B><A HREF="#Document">getDocument</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the document to which this node belongs.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#FieldType">getFieldType</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns the type of the field.
            The value of the property is <A HREF="FieldType.html" title="Utility class in com.aspose.words">FieldType</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Font.html" title="class in com.aspose.words">Font</A></CODE></TD><TD><CODE><B><A HREF="#Font">getFont</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Provides access to the font formatting of this object.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsComposite">isComposite</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns true if this node can contain other nodes.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsDeleteRevision">isDeleteRevision</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns true if this object was deleted in Microsoft Word while change tracking was enabled.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsDirty">isDirty</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></B></CODE></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#IsDirty">isDirty</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets whether the current result of the field is no longer correct (stale) due to other modifications
            made to the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsFormatRevision">isFormatRevision</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns true if formatting of the object was changed in Microsoft Word while change tracking was enabled.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsInsertRevision">isInsertRevision</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns true if this object was inserted in Microsoft Word while change tracking was enabled.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsLocked">isLocked</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></B></CODE></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#IsLocked">isLocked</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets whether the parent field is locked (should not recalculate its result). 
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsMoveFromRevision">isMoveFromRevision</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns <b>true</b> if this object was moved (deleted) in Microsoft Word while change tracking was enabled.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsMoveToRevision">isMoveToRevision</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns <b>true</b> if this object was moved (inserted) in Microsoft Word while change tracking was enabled.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#NextSibling">getNextSibling</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node immediately following this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#NodeType">getNodeType</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns <cref><A HREF="NodeType.html#FIELD_START" title="field in class com.aspose.words.NodeType">NodeType.FIELD_START</A></cref>.
            The value of the property is <A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#ParentNode">getParentNode</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the immediate parent of this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A></CODE></TD><TD><CODE><B><A HREF="#ParentParagraph">getParentParagraph</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Retrieves the parent <cref><A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A></cref> of this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#PreviousSibling">getPreviousSibling</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node immediately preceding this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Range.html" title="class in com.aspose.words">Range</A></CODE></TD><TD><CODE><B><A HREF="#Range">getRange</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a <b>Range</b> object that represents the portion of a document that is contained in this node.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" RULES="GROUPS" FRAME="BOX" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#accept(com.aspose.words.DocumentVisitor)">accept</A></B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Accepts a visitor.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#deepClone(boolean)">deepClone</A></B>(boolean&nbsp;isCloneChildren)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#getAncestor(int)">getAncestor</A></B>(int&nbsp;ancestorType)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first ancestor of the specified <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#getAncestor(java.lang.Class)">getAncestor</A></B>(java.lang.Class&nbsp;ancestorType)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first ancestor of the specified object type.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Field.html" title="class in com.aspose.words">Field</A></CODE></TD><TD><CODE><B><A HREF="#getField()">getField</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a field for the field char.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#getText()">getText</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="SpecialChar.html" title="class in com.aspose.words">SpecialChar</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the special character that this node represents.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#nextPreOrder(com.aspose.words.Node)">nextPreOrder</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets next node according to the pre-order tree traversal algorithm.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#previousPreOrder(com.aspose.words.Node)">previousPreOrder</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the previous node according to the pre-order tree traversal algorithm.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#remove()">remove</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes itself from the parent.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#toString(com.aspose.words.SaveOptions)">toString</A></B>(<A HREF="SaveOptions.html" title="class in com.aspose.words">SaveOptions</A>&nbsp;saveOptions)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Exports the content of the node into a string using the specified save options.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#toString(int)">toString</A></B>(int&nbsp;saveFormat)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Exports the content of the node into a string in the specified format.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;<P>

<!-- ============ PROPERTY DETAIL ========== -->

<A NAME="property_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Property Getters/Setters Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Document"><!-- --></A><A NAME="getDocument()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getDocument</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A>&nbsp;<B>getDocument</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the document to which this node belongs.
            </summary><remarks><p>The node always belongs to a document even if it has just been created
            and not yet added to the tree, or if it has been removed from the tree.</p></remarks><example><p><b>Example:</b></p>Shows that when you create any node, it requires a document that will own the node.<pre>
// Open a file from disk.
Document doc = new Document();

// Creating a new node of any type requires a document passed into the constructor.
Paragraph para = new Paragraph(doc);

// The new paragraph node does not yet have a parent.
System.out.println("Paragraph has no parent node: " + (para.getParentNode() == null));

// But the paragraph node knows its document.
System.out.println("Both nodes' documents are the same: " + (para.getDocument() == doc));

// The fact that a node always belongs to a document allows us to access and modify
// properties that reference the document-wide data such as styles or lists.
para.getParagraphFormat().setStyleName("Heading 1");

// Now add the paragraph to the main text of the first section.
doc.getFirstSection().getBody().appendChild(para);

// The paragraph node is now a child of the Body node.
System.out.println("Paragraph has a parent node: " + (para.getParentNode() != null));</pre></example>
</DL>
<HR>

<A NAME="FieldType"><!-- --></A><A NAME="getFieldType()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFieldType</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getFieldType</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns the type of the field.
            The value of the property is <A HREF="FieldType.html" title="Utility class in com.aspose.words">FieldType</A> integer constant.</summary><example><p><b>Example:</b></p>Shows how to find the type of field that is represented by a node which is derived from FieldChar.<pre>
FieldChar fieldStart = (FieldChar) doc.getChild(NodeType.FIELD_START, 0, true);
int type = fieldStart.getFieldType();</pre></example>
</DL>
<HR>

<A NAME="Font"><!-- --></A><A NAME="getFont()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFont</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Font.html" title="class in com.aspose.words">Font</A>&nbsp;<B>getFont</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Provides access to the font formatting of this object.
            </summary><example><p><b>Example:</b></p>Creates a simple document from scratch using the Aspose.Words object model.<pre>
// Create an "empty" document. Note that like in Microsoft Word,
// the empty document has one section, body and one paragraph in it.
Document doc = new Document();

// This truly makes the document empty. No sections (not possible in Microsoft Word).
doc.removeAllChildren();

// Create a new section node.
// Note that the section has not yet been added to the document,
// but we have to specify the parent document.
Section section = new Section(doc);

// Append the section to the document.
doc.appendChild(section);

// Lets set some properties for the section.
section.getPageSetup().setSectionStart(SectionStart.NEW_PAGE);
section.getPageSetup().setPaperSize(PaperSize.LETTER);

// The section that we created is empty, lets populate it. The section needs at least the Body node.
Body body = new Body(doc);
section.appendChild(body);

// The body needs to have at least one paragraph.
// Note that the paragraph has not yet been added to the document,
// but we have to specify the parent document.
// The parent document is needed so the paragraph can correctly work
// with styles and other document-wide information.
Paragraph para = new Paragraph(doc);
body.appendChild(para);

// We can set some formatting for the paragraph
para.getParagraphFormat().setStyleName("Heading 1");
para.getParagraphFormat().setAlignment(ParagraphAlignment.CENTER);

// So far we have one empty paragraph in the document.
// The document is valid and can be saved, but lets add some text before saving.
// Create a new run of text and add it to our paragraph.
Run run = new Run(doc);
run.setText("Hello World!");
run.getFont().setColor(Color.RED);
para.appendChild(run);

// As a matter of interest, you can retrieve text of the whole document and
// see that \x000c is automatically appended. \x000c is the end of section character.
System.out.println(doc.getText());

// Save the document.
doc.save(getMyDir() + "\\Artifacts\\Section.CreateFromScratch.doc");</pre></example>
</DL>
<HR>

<A NAME="IsComposite"><!-- --></A><A NAME="isComposite()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isComposite</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isComposite</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns true if this node can contain other nodes.
            </summary><value>This method returns false as Node cannot have child nodes.</value><example><p><b>Example:</b></p>Shows how to efficiently visit all direct and indirect children of a composite node.<pre>
public void recurseAllNodes() throws Exception
{
    // Open a document.
    Document doc = new Document(getMyDir() + "Node.RecurseAllNodes.doc");

    // Invoke the recursive function that will walk the tree.
    traverseAllNodes(doc);
}

/**
 * A simple function that will walk through all children of a specified node recursively
 * and print the type of each node to the screen.
 */
public void traverseAllNodes(CompositeNode parentNode)
{
    // This is the most efficient way to loop through immediate children of a node.
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling())
    {
        // Do some useful work.
        System.out.println(Node.nodeTypeToString(childNode.getNodeType()));

        // Recurse into the node if it is a composite node.
        if (childNode.isComposite()) traverseAllNodes((CompositeNode) childNode);
    }
}</pre></example>
</DL>
<HR>

<A NAME="IsDeleteRevision"><!-- --></A><A NAME="isDeleteRevision()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isDeleteRevision</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isDeleteRevision</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
Returns true if this object was deleted in Microsoft Word while change tracking was enabled.
</summary>
</DL>
<HR>

<A NAME="IsDirty"><!-- --></A><A NAME="isDirty()"><!-- --></A><A NAME="isDirty(boolean)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isDirty/isDirty</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isDirty</B>()&nbsp;/&nbsp;public void&nbsp;<B>isDirty</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets whether the current result of the field is no longer correct (stale) due to other modifications
            made to the document.
            </summary>
</DL>
<HR>

<A NAME="IsFormatRevision"><!-- --></A><A NAME="isFormatRevision()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isFormatRevision</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isFormatRevision</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
Returns true if formatting of the object was changed in Microsoft Word while change tracking was enabled.
</summary>
</DL>
<HR>

<A NAME="IsInsertRevision"><!-- --></A><A NAME="isInsertRevision()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isInsertRevision</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isInsertRevision</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
Returns true if this object was inserted in Microsoft Word while change tracking was enabled.
</summary>
</DL>
<HR>

<A NAME="IsLocked"><!-- --></A><A NAME="isLocked()"><!-- --></A><A NAME="isLocked(boolean)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isLocked/isLocked</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isLocked</B>()&nbsp;/&nbsp;public void&nbsp;<B>isLocked</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets whether the parent field is locked (should not recalculate its result). 
            </summary>
</DL>
<HR>

<A NAME="IsMoveFromRevision"><!-- --></A><A NAME="isMoveFromRevision()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isMoveFromRevision</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isMoveFromRevision</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
Returns <b>true</b> if this object was moved (deleted) in Microsoft Word while change tracking was enabled.
</summary>
</DL>
<HR>

<A NAME="IsMoveToRevision"><!-- --></A><A NAME="isMoveToRevision()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isMoveToRevision</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isMoveToRevision</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
Returns <b>true</b> if this object was moved (inserted) in Microsoft Word while change tracking was enabled.
</summary>
</DL>
<HR>

<A NAME="NextSibling"><!-- --></A><A NAME="getNextSibling()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNextSibling</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getNextSibling</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node immediately following this node.
            </summary><remarks>
            If there is no next node, a null is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to enumerate immediate child nodes of a composite node using NextSibling. In this example we enumerate all paragraphs of a section body.<pre>
// Get the section that we want to work on.
Section section = doc.getSections().get(0);
Body body = section.getBody();

// Loop starting from the first child until we reach null.
for (Node node = body.getFirstChild(); node != null; node = node.getNextSibling())
{
    // Output the types of the nodes that we come across.
    System.out.println(Node.nodeTypeToString(node.getNodeType()));
}</pre></example><example><p><b>Example:</b></p>Shows how to efficiently visit all direct and indirect children of a composite node.<pre>
public void recurseAllNodes() throws Exception
{
    // Open a document.
    Document doc = new Document(getMyDir() + "Node.RecurseAllNodes.doc");

    // Invoke the recursive function that will walk the tree.
    traverseAllNodes(doc);
}

/**
 * A simple function that will walk through all children of a specified node recursively
 * and print the type of each node to the screen.
 */
public void traverseAllNodes(CompositeNode parentNode)
{
    // This is the most efficient way to loop through immediate children of a node.
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling())
    {
        // Do some useful work.
        System.out.println(Node.nodeTypeToString(childNode.getNodeType()));

        // Recurse into the node if it is a composite node.
        if (childNode.isComposite()) traverseAllNodes((CompositeNode) childNode);
    }
}</pre></example>
</DL>
<HR>

<A NAME="NodeType"><!-- --></A><A NAME="getNodeType()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNodeType</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getNodeType</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns <cref><A HREF="NodeType.html#FIELD_START" title="field in class com.aspose.words.NodeType">NodeType.FIELD_START</A></cref>.
            The value of the property is <A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A> integer constant.</summary><example><p><b>Example:</b></p>Shows how to retrieve the NodeType enumeration of nodes.<pre>
Document doc = new Document(getMyDir() + "Document.doc");

// Let's pick a node that we can't be quite sure of what type it is.
// In this case lets pick the first node of the first paragraph in the body of the document
Node node = doc.getFirstSection().getBody().getFirstParagraph().getFirstChild();
System.out.println("NodeType of first child: " + Node.nodeTypeToString(node.getNodeType()));

// This time let's pick a node that we know the type of. Create a new paragraph and a table node.
Paragraph para = new Paragraph(doc);
Table table = new Table(doc);

// Access to NodeType for typed nodes will always return their specific NodeType.
// i.e A paragraph node will always return NodeType.Paragraph, a table node will always return NodeType.Table.
System.out.println("NodeType of Paragraph: " + Node.nodeTypeToString(para.getNodeType()));
System.out.println("NodeType of Table: " + Node.nodeTypeToString(table.getNodeType()));</pre></example>
</DL>
<HR>

<A NAME="ParentNode"><!-- --></A><A NAME="getParentNode()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getParentNode</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getParentNode</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the immediate parent of this node.
            </summary><remarks><p>If a node has just been created and not yet added to the tree,
            or if it has been removed from the tree, the parent is null.</p></remarks><example><p><b>Example:</b></p>Shows how to access the parent node.<pre>
// Create a new empty document. It has one section.
Document doc = new Document();

// The section is the first child node of the document.
Node section = doc.getFirstChild();

// The section's parent node is the document.
System.out.println("Section parent is the document: " + (doc == section.getParentNode()));</pre></example><example><p><b>Example:</b></p>Shows that when you create any node, it requires a document that will own the node.<pre>
// Open a file from disk.
Document doc = new Document();

// Creating a new node of any type requires a document passed into the constructor.
Paragraph para = new Paragraph(doc);

// The new paragraph node does not yet have a parent.
System.out.println("Paragraph has no parent node: " + (para.getParentNode() == null));

// But the paragraph node knows its document.
System.out.println("Both nodes' documents are the same: " + (para.getDocument() == doc));

// The fact that a node always belongs to a document allows us to access and modify
// properties that reference the document-wide data such as styles or lists.
para.getParagraphFormat().setStyleName("Heading 1");

// Now add the paragraph to the main text of the first section.
doc.getFirstSection().getBody().appendChild(para);

// The paragraph node is now a child of the Body node.
System.out.println("Paragraph has a parent node: " + (para.getParentNode() != null));</pre></example>
</DL>
<HR>

<A NAME="ParentParagraph"><!-- --></A><A NAME="getParentParagraph()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getParentParagraph</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A>&nbsp;<B>getParentParagraph</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Retrieves the parent <cref><A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A></cref> of this node.
            </summary>
</DL>
<HR>

<A NAME="PreviousSibling"><!-- --></A><A NAME="getPreviousSibling()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getPreviousSibling</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getPreviousSibling</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node immediately preceding this node.
            </summary><remarks>
            If there is no preceding node, a null is returned.
            </remarks><example><p><b>Example:</b></p>Demonstrates use of methods of Node and CompositeNode to remove a section before the last section in the document.<pre>
// Document is a CompositeNode and LastChild returns the last child node in the Document node.
// Since the Document can contain only Section nodes, the last child is the last section.
Node lastSection = doc.getLastChild();

// Each node knows its next and previous sibling nodes.
// Previous sibling of a section is a section before the specified section.
// If the node is the first child, PreviousSibling will return null.
Node sectionBeforeLast = lastSection.getPreviousSibling();

if (sectionBeforeLast != null) doc.removeChild(sectionBeforeLast);</pre></example>
</DL>
<HR>

<A NAME="Range"><!-- --></A><A NAME="getRange()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getRange</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Range.html" title="class in com.aspose.words">Range</A>&nbsp;<B>getRange</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a <b>Range</b> object that represents the portion of a document that is contained in this node.
            </summary><example><p><b>Example:</b></p>Shows how to delete all characters of a range.<pre>
// Open Word document.
Document doc = new Document(getMyDir() + "Range.DeleteSection.doc");

// The document contains two sections. Each section has a paragraph of text.
System.out.println(doc.getText());

// Delete the first section from the document.
doc.getSections().get(0).getRange().delete();

// Check the first section was deleted by looking at the text of the whole document again.
System.out.println(doc.getText());</pre></example>
</DL>
<HR>



<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="accept(com.aspose.words.DocumentVisitor)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>accept</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>accept</B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)
              throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Accepts a visitor.
            </summary><remarks><p>Calls <cref><A HREF="DocumentVisitor.html#visitFieldStart(com.aspose.words.FieldStart)" title="method in class com.aspose.words.DocumentVisitor">DocumentVisitor.visitFieldStart(com.aspose.words.FieldStart)</A></cref>.</p><p>For more info see the Visitor design pattern.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="visitor"><CODE>visitor</CODE> - The visitor that will visit the node.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns=""><b>False</b> if the visitor requested the enumeration to stop.</DD></DL>
</DL>
<HR>

<A NAME="deepClone(boolean)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>deepClone</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>deepClone</B>(boolean&nbsp;isCloneChildren)</PRE></TD></TR></TABLE>
<DL><DD><!-- No matching elements were found for the following include tag --><include file="..\Docs\Text.xml" path="Topics/Topic[@name=&quot;Node.Clone&quot;]/*" /><summary /><example><p><b>Example:</b></p>Shows how to clone composite nodes with and without their child nodes.<pre>
// Create a new empty document.
Document doc = new Document();

// Add some text to the first paragraph
Paragraph para = doc.getFirstSection().getBody().getFirstParagraph();
para.appendChild(new Run(doc, "Some text"));

// Clone the paragraph and the child nodes.
Node cloneWithChildren = para.deepClone(true);
// Only clone the paragraph and no child nodes.
Node cloneWithoutChildren = para.deepClone(false);</pre></example>
</DL>
<HR>

<A NAME="getAncestor(int)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getAncestor</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getAncestor</B>(int&nbsp;ancestorType)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first ancestor of the specified <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref>.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="ancestorType"><CODE>ancestorType</CODE> - A <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref> value. The node type of the ancestor to retrieve.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The ancestor of the specified type or null if no ancestor of this type was found.</DD></DL><example><p><b>Example:</b></p>Shows how to find out if a table contains another table or if the table itself is nested inside another table.<pre>
public void calculateDepthOfNestedTables() throws Exception
{
    Document doc = new Document(getMyDir() + "Table.NestedTables.doc");
    int tableIndex = 0;

    for (Table table : (Iterable&lt;Table&gt;) doc.getChildNodes(NodeType.TABLE, true))
    {
        // First lets find if any cells in the table have tables themselves as children.
        int count = getChildTableCount(table);
        System.out.println(MessageFormat.format("Table #{0} has {1} tables directly within its cells", tableIndex, count));

        // Now let's try the other way around, lets try find if the table is nested inside another table and at what depth.
        int tableDepth = getNestedDepthOfTable(table);

        if (tableDepth &gt; 0)
            System.out.println(MessageFormat.format("Table #{0} is nested inside another table at depth of {1}", tableIndex, tableDepth));
        else
            System.out.println(MessageFormat.format("Table #{0} is a non nested table (is not a child of another table)", tableIndex));

        tableIndex++;
    }
}

/**
 * Calculates what level a table is nested inside other tables.
 *
 * @returns An integer containing the level the table is nested at.
 * 0 = Table is not nested inside any other table
 * 1 = Table is nested within one parent table
 * 2 = Table is nested within two parent tables etc..
 */
private static int getNestedDepthOfTable(Table table)
{
    int depth = 0;

    int type = table.getNodeType();
    // The parent of the table will be a Cell, instead attempt to find a grandparent that is of type Table
    Node parent = table.getAncestor(type);

    while (parent != null)
    {
        // Every time we find a table a level up we increase the depth counter and then try to find an
        // ancestor of type table from the parent.
        depth++;
        parent = parent.getAncestor(type);
    }

    return depth;
}

/**
 * Determines if a table contains any immediate child table within its cells.
 * Does not recursively traverse through those tables to check for further tables.
 *
 * @returns Returns true if at least one child cell contains a table.
 * Returns false if no cells in the table contains a table.
 */
private static int getChildTableCount(Table table)
{
    int tableCount = 0;
    // Iterate through all child rows in the table
    for (Row row : table.getRows())
    {
        // Iterate through all child cells in the row
        for (Cell Cell : row.getCells())
        {
            // Retrieve the collection of child tables of this cell
            TableCollection childTables = Cell.getTables();

            // If this cell has a table as a child then return true
            if (childTables.getCount() &gt; 0) tableCount++;
        }
    }

    // No cell contains a table
    return tableCount;
}</pre></example>
</DL>
<HR>

<A NAME="getAncestor(java.lang.Class)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getAncestor</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getAncestor</B>(java.lang.Class&nbsp;ancestorType)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first ancestor of the specified object type.
            </summary><remarks><p>The ancestor type matches if it is equal to ancestorType or derived from ancestorType.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="ancestorType"><CODE>ancestorType</CODE> - The object type of the ancestor to retrieve.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The ancestor of the specified type or null if no ancestor of this type was found.</DD></DL>
</DL>
<HR>

<A NAME="getField()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getField</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Field.html" title="class in com.aspose.words">Field</A>&nbsp;<B>getField</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a field for the field char.
            </summary><remarks>
            A new <cref><A HREF="Field.html" title="class in com.aspose.words">Field</A></cref> object is created each time the method is called.
            </remarks><DL><DT><B>Returns:</B></DT><DD returns="">A field for the field char.</DD></DL><example><p><b>Example:</b></p>Demonstrates how to retrieve the field class from an existing FieldStart node in the document.<pre>
Document doc = new Document(getMyDir() + "Document.TableOfContents.doc");

FieldStart fieldStart = (FieldStart) doc.getChild(NodeType.FIELD_START, 0, true);

// Retrieve the facade object which represents the field in the document.
Field field = fieldStart.getField();

System.out.println("Field code:" + field.getFieldCode());
System.out.println("Field result: " + field.getResult());
System.out.println("Is locked: " + field.isLocked());

// This updates only this field in the document.
field.update();</pre></example>
</DL>
<HR>

<A NAME="getText()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getText</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="SpecialChar.html" title="class in com.aspose.words">SpecialChar</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getText</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the special character that this node represents.
            </summary><DL><DT><B>Returns:</B></DT><DD returns="">The string that contains the character that this node represents.</DD></DL>
</DL>
<HR>

<A NAME="nextPreOrder(com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>nextPreOrder</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>nextPreOrder</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets next node according to the pre-order tree traversal algorithm.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="rootNode"><CODE>rootNode</CODE> - The top node (limit) of traversal.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">Next node in pre-order order. Null if reached the rootNode.</DD></DL><example><p><b>Example:</b></p>Shows how to delete all images from a document using pre-order tree traversal.<pre>
Node curNode = doc;
while (curNode != null)
{
    Node nextNode = curNode.nextPreOrder(doc);

    if (curNode.getNodeType() == NodeType.SHAPE)
    {
        Shape shape = (Shape) curNode;

        // Several shape types can have an image including image shapes and OLE objects.
        if (shape.hasImage()) shape.remove();
    }

    curNode = nextNode;
}</pre></example>
</DL>
<HR>

<A NAME="previousPreOrder(com.aspose.words.Node)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>previousPreOrder</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>previousPreOrder</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the previous node according to the pre-order tree traversal algorithm.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="rootNode"><CODE>rootNode</CODE> - The top node (limit) of traversal.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">Previous node in pre-order order. Null if reached the rootNode.</DD></DL>
</DL>
<HR>

<A NAME="remove()"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>remove</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>remove</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes itself from the parent.
            </summary><example><p><b>Example:</b></p>Shows how to remove all nodes of a specific type from a composite node. In this example we remove tables from a section body.<pre>
// Get the section that we want to work on.
Section section = doc.getSections().get(0);
Body body = section.getBody();

// Select the first child node in the body.
Node curNode = body.getFirstChild();

while (curNode != null)
{
    // Save the pointer to the next sibling node because if the current
    // node is removed from the parent in the next step, we will have
    // no way of finding the next node to continue the loop.
    Node nextNode = curNode.getNextSibling();

    // A section body can contain Paragraph and Table nodes.
    // If the node is a Table, remove it from the parent.
    if (curNode.getNodeType() == NodeType.TABLE) curNode.remove();

    // Continue going through child nodes until null (no more siblings) is reached.
    curNode = nextNode;
}</pre></example><example><p><b>Example:</b></p>Shows how to delete all images from a document.<pre>
// Here we get all shapes from the document node, but you can do this for any smaller
// node too, for example delete shapes from a single section or a paragraph.
NodeCollection shapes = doc.getChildNodes(NodeType.SHAPE, true);

// We cannot delete shape nodes while we enumerate through the collection.
// One solution is to add nodes that we want to delete to a temporary array and delete afterwards.
ArrayList shapesToDelete = new ArrayList();
for (Shape shape : (Iterable&lt;Shape&gt;) shapes)
{
    // Several shape types can have an image including image shapes and OLE objects.
    if (shape.hasImage()) shapesToDelete.add(shape);
}

// Now we can delete shapes.
for (Shape shape : (Iterable&lt;Shape&gt;) shapesToDelete)
    shape.remove();</pre></example>
</DL>
<HR>

<A NAME="toString(com.aspose.words.SaveOptions)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>toString</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>toString</B>(<A HREF="SaveOptions.html" title="class in com.aspose.words">SaveOptions</A>&nbsp;saveOptions)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Exports the content of the node into a string using the specified save options.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="saveOptions"><CODE>saveOptions</CODE> - Specifies the options that control how the node is saved.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The content of the node in the specified format.</DD></DL><example><p><b>Example:</b></p>Exports the content of a node to string in HTML format using custom specified options.<pre>
Document doc = new Document(getMyDir() + "Document.doc");

// Extract the last paragraph in the document to convert to HTML.
Node node = doc.getLastSection().getBody().getLastParagraph();

// Create an instance of HtmlSaveOptions and set a few options.
HtmlSaveOptions saveOptions = new HtmlSaveOptions();
saveOptions.setExportHeadersFootersMode(ExportHeadersFootersMode.PER_SECTION);
saveOptions.setExportRelativeFontSize(true);

// Convert the document to HTML and return as a string. Pass the instance of HtmlSaveOptions to
// to use the specified options during the conversion.
String nodeAsHtml = node.toString(saveOptions);</pre></example>
</DL>
<HR>

<A NAME="toString(int)"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>toString</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>toString</B>(int&nbsp;saveFormat)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Exports the content of the node into a string in the specified format.
            </summary><DL><DT><B>Returns:</B></DT><DD returns="">The content of the node in the specified format.</DD></DL><DL><DT><B>Parameters:</B></DT><DD><CODE>saveFormat</CODE> - A <A HREF="SaveFormat.html" title="Utility class in com.aspose.words">SaveFormat</A> value.</DD></DL><example><p><b>Example:</b></p>Shows how to extract the label of each paragraph in a list as a value or a String.<pre>
Document doc = new Document(getMyDir() + "Lists.PrintOutAllLists.doc");
doc.updateListLabels();
int listParaCount = 1;

for (Paragraph paragraph : (Iterable&lt;Paragraph&gt;) doc.getChildNodes(NodeType.PARAGRAPH, true))
{
    // Find if we have the paragraph list. In our document our list uses plain arabic numbers,
    // which start at three and ends at six.
    if (paragraph.getListFormat().isListItem())
    {
        System.out.println(MessageFormat.format("Paragraph #{0}", listParaCount));

        // This is the text we get when actually getting when we output this node to text format.
        // The list labels are not included in this text output. Trim any paragraph formatting characters.
        String paragraphText = paragraph.toString(SaveFormat.TEXT).trim();
        System.out.println("Exported Text: " + paragraphText);

        ListLabel label = paragraph.getListLabel();
        // This gets the position of the paragraph in current level of the list. If we have a list with multiple level then this
        // will tell us what position it is on that particular level.
        System.out.println("Numerical Id: " + label.getLabelValue());

        // Combine them together to include the list label with the text in the output.
        System.out.println("List label combined with text: " + label.getLabelString() + " " + paragraphText);

        listParaCount++;
    }
}</pre></example><example><p><b>Example:</b></p>Shows the difference between calling the GetText and ToString methods on a node.<pre>
Document doc = new Document();

// Enter a dummy field into the document.
DocumentBuilder builder = new DocumentBuilder(doc);
builder.insertField("MERGEFIELD Field");

// GetText will retrieve all field codes and special characters
System.out.println("GetText() Result: " + doc.getText());

// ToString will export the node to the specified format. When converted to text it will not retrieve fields code
// or special characters, but will still contain some natural formatting characters such as paragraph markers etc.
// This is the same as "viewing" the document as if it was opened in a text editor.
System.out.println("ToString() Result: " + doc.toString(SaveFormat.TEXT));</pre></example><example><p><b>Example:</b></p>Exports the content of a node to string in HTML format using default options.<pre>
Document doc = new Document(getMyDir() + "Document.doc");

// Extract the last paragraph in the document to convert to HTML.
Node node = doc.getLastSection().getBody().getLastParagraph();

// When ToString is called using the SaveFormat overload then conversion is executed using default save options.
// When saving to HTML using default options the following settings are set:
//   ExportImagesAsBase64 = true
//   CssStyleSheetType = CssStyleSheetType.Inline
//   ExportFontResources = false
String nodeAsHtml = node.toString(SaveFormat.HTML);</pre></example>
</DL>
<HR>

<B>See Also:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Products/Aspose.Words/Api/index.html" TARGET="_blank">Aspose.Words Documentation</A> - the home page for the Aspose.Words Product Documentation.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Community/forums/ShowForum.aspx?ForumID=75" TARGET="_blank">Aspose.Words Support Forum</A> - our preferred method of support.<P>
<div class="footer"><hr><p><a href='http://www.aspose.com/Wiki/default.aspx/Aspose.Corporate/ContactAspose.html'>We guarantee a prompt response to any inquiry!</a></p><p>&copy; 2003-2007 Aspose Pty Ltd. All rights reserved.</p></div></BODY></HTML>